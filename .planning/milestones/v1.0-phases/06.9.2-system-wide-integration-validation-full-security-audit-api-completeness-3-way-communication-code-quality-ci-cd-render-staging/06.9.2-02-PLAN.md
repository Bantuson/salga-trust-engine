---
phase: 06.9.2-system-wide-integration-validation
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - frontend-dashboard/src/services/api.ts
  - frontend-dashboard/src/hooks/useAnalytics.ts
  - frontend-dashboard/src/hooks/useTeams.ts
  - frontend-dashboard/src/hooks/useSettings.ts
  - frontend-dashboard/src/hooks/useOnboarding.ts
  - frontend-dashboard/src/pages/RequestAccessPage.tsx
  - frontend-dashboard/src/pages/OnboardingWizardPage.tsx
  - frontend-public/src/hooks/usePublicStats.ts
  - frontend-public/src/hooks/useCitizenReports.ts
autonomous: true
requirements:
  - OPS-01
  - OPS-02
  - TRNS-01
  - TRNS-02
  - TRNS-03

must_haves:
  truths:
    - "Municipal dashboard API calls include proper error handling with retry on 401 (token refresh)"
    - "Public dashboard Supabase queries gracefully fall back to mock data on connection failure"
    - "Dashboard hooks display user-facing error messages on persistent failures"
    - "Stale auth tokens trigger automatic session refresh, not crash"
  artifacts:
    - path: "frontend-dashboard/src/services/api.ts"
      provides: "Axios interceptor with 401 retry + token refresh"
      contains: "interceptors.response"
    - path: "frontend-public/src/hooks/usePublicStats.ts"
      provides: "Supabase queries with mock fallback"
      contains: "mockSystemSummary"
  key_links:
    - from: "frontend-dashboard/src/services/api.ts"
      to: "frontend-dashboard/src/lib/supabase.ts"
      via: "auth.getSession() for JWT"
      pattern: "supabase.auth.getSession"
    - from: "frontend-public/src/hooks/usePublicStats.ts"
      to: "frontend-public/src/lib/supabase.ts"
      via: "Supabase client for RLS view queries"
      pattern: "supabase.*from"
---

<objective>
Investigate and fix failing dashboard fetches in both municipal and public dashboards.

Purpose: User reports failing fetches. Research identified potential failure points: auth token expiry, CORS misconfig, missing error handling on network failures, stale Supabase sessions, and RLS view misconfiguration.

Output: Both dashboards handle all failure modes gracefully with proper error states, token refresh, and mock fallbacks.
</objective>

<execution_context>
@C:/Users/Bantu/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Bantu/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@frontend-dashboard/src/services/api.ts
@frontend-dashboard/src/hooks/useTeams.ts
@frontend-dashboard/src/hooks/useSettings.ts
@frontend-public/src/hooks/usePublicStats.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Municipal dashboard — add response interceptor with token refresh and error handling</name>
  <files>frontend-dashboard/src/services/api.ts, frontend-dashboard/src/hooks/useAnalytics.ts, frontend-dashboard/src/hooks/useTeams.ts, frontend-dashboard/src/hooks/useSettings.ts, frontend-dashboard/src/hooks/useOnboarding.ts, frontend-dashboard/src/pages/RequestAccessPage.tsx, frontend-dashboard/src/pages/OnboardingWizardPage.tsx</files>
  <action>
1. In frontend-dashboard/src/services/api.ts, add a response interceptor that handles 401 errors:
   ```typescript
   // Track if we're already refreshing to prevent infinite loops
   let isRefreshing = false;
   let failedQueue: Array<{ resolve: Function; reject: Function }> = [];

   const processQueue = (error: any, token: string | null = null) => {
     failedQueue.forEach((prom) => {
       if (token) prom.resolve(token);
       else prom.reject(error);
     });
     failedQueue = [];
   };

   api.interceptors.response.use(
     (response) => response,
     async (error) => {
       const originalRequest = error.config;

       // If 401 and not already retrying
       if (error.response?.status === 401 && !originalRequest._retry) {
         if (isRefreshing) {
           // Queue this request while refresh is in progress
           return new Promise((resolve, reject) => {
             failedQueue.push({ resolve, reject });
           }).then((token) => {
             originalRequest.headers.Authorization = `Bearer ${token}`;
             return api(originalRequest);
           });
         }

         originalRequest._retry = true;
         isRefreshing = true;

         try {
           const { data: { session }, error: refreshError } = await supabase.auth.refreshSession();
           if (refreshError || !session) {
             processQueue(refreshError, null);
             // Session truly expired — redirect to login
             window.location.href = '/login';
             return Promise.reject(refreshError);
           }

           const newToken = session.access_token;
           processQueue(null, newToken);
           originalRequest.headers.Authorization = `Bearer ${newToken}`;
           return api(originalRequest);
         } catch (refreshErr) {
           processQueue(refreshErr, null);
           return Promise.reject(refreshErr);
         } finally {
           isRefreshing = false;
         }
       }

       return Promise.reject(error);
     }
   );
   ```

2. In hooks (useAnalytics.ts, useTeams.ts, useSettings.ts, useOnboarding.ts):
   - Ensure each hook's error state is set with a user-readable message (not raw exception)
   - Add console.warn for debugging (not console.error for expected failures)
   - Verify that isLoading is ALWAYS set to false in the finally block (check for missing finally blocks)

3. In pages (RequestAccessPage.tsx, OnboardingWizardPage.tsx):
   - Check for bare try/catch blocks that silently swallow errors
   - Ensure network errors are displayed to the user (not just console.logged)
   - If using direct fetch() calls instead of api service, migrate to api service or add equivalent error handling

4. DO NOT change any API call URLs or Supabase config — only improve error handling and recovery.
  </action>
  <verify>
    - `cd frontend-dashboard && npm run build:check` — TypeScript compiles without errors
    - `cd frontend-dashboard && npm run build` — production build succeeds
  </verify>
  <done>Municipal dashboard has 401 retry with token refresh, all hooks have proper error states with user-readable messages, no silently swallowed errors</done>
</task>

<task type="auto">
  <name>Task 2: Public dashboard — verify Supabase query resilience and error handling</name>
  <files>frontend-public/src/hooks/usePublicStats.ts, frontend-public/src/hooks/useCitizenReports.ts</files>
  <action>
1. In frontend-public/src/hooks/usePublicStats.ts:
   - Audit all 6 hook functions (useMunicipalities, useResponseTimes, useResolutionRates, useHeatmapData, useCategoryBreakdown, useSystemSummary)
   - Each already has try/catch with mock fallback — VERIFY this pattern is consistent:
     a. On Supabase error: log warning, set data to mock fallback, set error to null (graceful degradation)
     b. On empty data: use mock fallback (already implemented — verify)
     c. Ensure no hook leaves isLoading=true on error path (check finally blocks)
   - Add a connection check at the top of the file:
     ```typescript
     // Log Supabase connectivity status on first load for debugging
     const _checkConnection = supabase.from('public_municipalities').select('*', { count: 'exact', head: true })
       .then(({ error }) => {
         if (error) console.warn('[PublicStats] Supabase connection issue:', error.message);
       });
     ```
   - This is a diagnostic log only — does not block rendering.

2. In frontend-public/src/hooks/useCitizenReports.ts:
   - Read file and audit error handling pattern
   - This hook queries citizen's own tickets (authenticated) — ensure it handles:
     a. No auth session → return empty array (not crash)
     b. Supabase error → display user-friendly message
     c. Empty data → show "no reports" state (not loading spinner forever)
   - Add session check before querying:
     ```typescript
     const { data: { session } } = await supabase.auth.getSession();
     if (!session) {
       setReports([]);
       setIsLoading(false);
       return;
     }
     ```

3. Verify that public dashboard builds correctly:
   - `cd frontend-public && npm run build:check`
   - `cd frontend-public && npm run build`
  </action>
  <verify>
    - `cd frontend-public && npm run build:check` — TypeScript compiles without errors
    - `cd frontend-public && npm run build` — production build succeeds
  </verify>
  <done>Public dashboard queries gracefully degrade to mock data on Supabase errors, useCitizenReports handles missing auth session, all hooks have consistent error/loading states</done>
</task>

</tasks>

<verification>
- Both frontend apps build successfully (npm run build)
- TypeScript type checking passes (npm run build:check)
- No silent error swallowing in any hook or page
- 401 responses trigger token refresh in municipal dashboard
- Public dashboard falls back to mock data on Supabase errors
</verification>

<success_criteria>
- Both dashboards build with zero errors
- Municipal dashboard retries 401 with fresh token before redirecting to login
- Public dashboard displays mock data when Supabase is unreachable
- All hooks set isLoading=false on all code paths (no infinite loading spinners)
</success_criteria>

<output>
After completion, create `.planning/phases/06.9.2-system-wide-integration-validation-full-security-audit-api-completeness-3-way-communication-code-quality-ci-cd-render-staging/06.9.2-02-SUMMARY.md`
</output>
