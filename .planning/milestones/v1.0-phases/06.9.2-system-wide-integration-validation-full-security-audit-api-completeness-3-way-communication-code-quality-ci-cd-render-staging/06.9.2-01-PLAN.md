---
phase: 06.9.2-system-wide-integration-validation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/api/v1/crew_server.py
  - src/middleware/rate_limit.py
  - src/api/v1/tickets.py
  - src/api/v1/teams.py
  - src/api/v1/dashboard.py
  - src/api/v1/settings.py
  - src/api/v1/invitations.py
  - src/api/v1/municipalities.py
  - src/api/v1/export.py
  - src/api/v1/onboarding.py
  - src/api/v1/access_requests.py
  - src/api/v1/uploads.py
  - src/api/v1/reports.py
  - src/api/v1/citizen.py
  - src/api/v1/consent.py
  - src/api/v1/verification.py
  - src/api/v1/messages.py
  - src/api/v1/audit_logs.py
  - src/api/v1/events.py
  - src/api/v1/users.py
autonomous: true
requirements:
  - PLAT-05
  - SEC-01
  - SEC-04

must_haves:
  truths:
    - "All 71 API endpoints have explicit rate limiting (not just global default)"
    - "Crew server has CORS configured to match main app security posture"
    - "Crew server has rate limiting (chat: 20/min, session/reset: 10/min)"
    - "Sensitive endpoints have tighter rate limits (uploads, verification, exports)"
  artifacts:
    - path: "src/api/v1/crew_server.py"
      provides: "Rate limiting + CORS on crew server"
      contains: "CORSMiddleware"
    - path: "src/middleware/rate_limit.py"
      provides: "Endpoint-specific rate limit constants"
      contains: "CREW_CHAT_RATE_LIMIT"
  key_links:
    - from: "src/api/v1/crew_server.py"
      to: "src/middleware/rate_limit.py"
      via: "slowapi limiter import"
      pattern: "from src.middleware.rate_limit import"
---

<objective>
Harden API security across all 71 endpoints (68 main app + 3 crew server).

Purpose: Research found most endpoints rely only on global rate limiting. Crew server has zero rate limiting, no CORS, and no input validation beyond basic Pydantic. This plan closes those gaps.

Output: All endpoints have explicit rate limits. Crew server has CORS + rate limiting + input length validation.
</objective>

<execution_context>
@C:/Users/Bantu/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Bantu/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/middleware/rate_limit.py
@src/api/v1/crew_server.py
@src/main.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Crew server security hardening (CORS, rate limiting, input validation)</name>
  <files>src/api/v1/crew_server.py, src/middleware/rate_limit.py</files>
  <action>
1. In src/middleware/rate_limit.py, add new rate limit constants:
   - CREW_CHAT_RATE_LIMIT = "20/minute"
   - CREW_RESET_RATE_LIMIT = "10/minute"
   - UPLOAD_RATE_LIMIT = "10/minute"
   - VERIFICATION_RATE_LIMIT = "5/minute"
   - REPORT_RATE_LIMIT = "10/minute"
   - SENSITIVE_WRITE_RATE_LIMIT = "30/minute"
   - SENSITIVE_READ_RATE_LIMIT = "60/minute"

2. In src/api/v1/crew_server.py:
   a. Add CORS middleware matching main app pattern:
      ```python
      from fastapi.middleware.cors import CORSMiddleware
      from src.core.config import settings
      crew_app.add_middleware(
          CORSMiddleware,
          allow_origins=settings.ALLOWED_ORIGINS,
          allow_credentials=True,
          allow_methods=["GET", "POST"],
          allow_headers=["X-API-Key", "Content-Type"],
      )
      ```
   b. Add slowapi rate limiting:
      ```python
      from src.middleware.rate_limit import limiter, CREW_CHAT_RATE_LIMIT, CREW_RESET_RATE_LIMIT, setup_rate_limiting
      setup_rate_limiting(crew_app)
      ```
   c. Add @limiter.limit(CREW_CHAT_RATE_LIMIT) to chat endpoint
   d. Add @limiter.limit(CREW_RESET_RATE_LIMIT) to reset_session endpoint
   e. Add input length validation to ChatRequest model:
      ```python
      from pydantic import BaseModel, field_validator
      # In ChatRequest:
      @field_validator('message')
      @classmethod
      def validate_message_length(cls, v):
          if len(v) > 2000:
              raise ValueError('Message must be under 2000 characters')
          return v
      @field_validator('phone')
      @classmethod
      def validate_phone(cls, v):
          cleaned = v.strip()
          if len(cleaned) < 7 or len(cleaned) > 20:
              raise ValueError('Invalid phone number length')
          return cleaned
      ```
   f. Add Request parameter to chat and reset_session endpoint signatures (required by slowapi):
      `from starlette.requests import Request` then add `request_obj: Request` parameter

3. Verify crew_server imports do not cause circular dependencies.
  </action>
  <verify>
    - `python -c "from src.api.v1.crew_server import crew_app; print('OK')"` succeeds
    - `python -c "from src.middleware.rate_limit import CREW_CHAT_RATE_LIMIT; print(CREW_CHAT_RATE_LIMIT)"` prints "20/minute"
  </verify>
  <done>Crew server has CORS matching main app, rate limiting on chat (20/min) and reset (10/min), input validation (message length, phone format)</done>
</task>

<task type="auto">
  <name>Task 2: Add explicit rate limits to all main app endpoints</name>
  <files>src/api/v1/tickets.py, src/api/v1/teams.py, src/api/v1/dashboard.py, src/api/v1/settings.py, src/api/v1/invitations.py, src/api/v1/municipalities.py, src/api/v1/export.py, src/api/v1/onboarding.py, src/api/v1/access_requests.py, src/api/v1/uploads.py, src/api/v1/reports.py, src/api/v1/citizen.py, src/api/v1/consent.py, src/api/v1/verification.py, src/api/v1/messages.py, src/api/v1/audit_logs.py, src/api/v1/events.py, src/api/v1/users.py</files>
  <action>
Add explicit @limiter.limit() decorators to every endpoint in each route module that does not already have one. Use tiered rate limits based on sensitivity:

**Already rate-limited (verify, do not duplicate):**
- auth.py: login (5/min), register (3/hour) — SKIP
- data_rights.py: export (5/hour), deletion (1/day) — SKIP
- whatsapp.py: Twilio webhook (external) — SKIP
- public.py: Public endpoints (high traffic allowed) — use "120/minute"

**Pattern for each file:**
```python
from starlette.requests import Request
from src.middleware.rate_limit import limiter, SENSITIVE_READ_RATE_LIMIT  # or appropriate constant
```
Then add `@limiter.limit(CONSTANT)` before each endpoint and add `request: Request` parameter if not present.

**Tier assignments (add to each file's endpoints):**
- Read endpoints (GET): SENSITIVE_READ_RATE_LIMIT ("60/minute")
- Write endpoints (POST/PUT/PATCH/DELETE): SENSITIVE_WRITE_RATE_LIMIT ("30/minute")
- uploads.py: UPLOAD_RATE_LIMIT ("10/minute")
- verification.py: VERIFICATION_RATE_LIMIT ("5/minute")
- reports.py: REPORT_RATE_LIMIT ("10/minute")
- export.py: Already has DATA_EXPORT_RATE_LIMIT ("5/hour") — verify existing
- events.py (SSE): "30/minute" for SSE connection
- public.py: "120/minute" for unauthenticated public endpoints

NOTE: slowapi requires `request: Request` (from starlette) as a function parameter. Many endpoint functions already have a parameter named `request` that is the Pydantic body model. For those, rename the starlette Request to `http_request: Request` and use `key_func=lambda r: get_remote_address(r)` in the limiter limit call, or add the Request as a separate param. The simplest approach: if the endpoint already has a `request` parameter that is a Pydantic model, rename the starlette param to something else or use `Request` from starlette and ensure slowapi can find it. Check slowapi docs — it typically uses the first `Request` typed parameter.

IMPORTANT: If an endpoint function signature already has many parameters (from FastAPI dependency injection), add `request: Request` as the FIRST positional parameter. FastAPI resolves Request type automatically.

Do NOT change any business logic. Only add the decorator and the Request parameter.
  </action>
  <verify>
    - `python -c "from src.main import app; print(f'{len(app.routes)} routes loaded')"` succeeds without import errors
    - `grep -r "@limiter.limit" src/api/v1/ | wc -l` — prints a count >= 68 (one decorator per main-app endpoint; if lower, identify which files are missing decorators and add them before proceeding)
    - `pytest tests/ -x -q --timeout=60 2>&1 | tail -5` — existing tests still pass (rate limiting should not affect unit tests using TestClient)
  </verify>
  <done>All 68 main app endpoints have explicit rate limit decorators with tiered limits. No business logic changed. Existing tests pass.</done>
</task>

</tasks>

<verification>
- Import crew_server and main app without errors
- All rate limit constants defined and importable
- Crew server CORS configured
- Existing unit tests pass (rate limiting is transparent in test mode with in-memory storage)
</verification>

<success_criteria>
- 71/71 endpoints have explicit rate limiting
- Crew server has CORS, rate limiting, and input validation
- Zero import errors, zero test regressions
</success_criteria>

<output>
After completion, create `.planning/phases/06.9.2-system-wide-integration-validation-full-security-audit-api-completeness-3-way-communication-code-quality-ci-cd-render-staging/06.9.2-01-SUMMARY.md`
</output>
