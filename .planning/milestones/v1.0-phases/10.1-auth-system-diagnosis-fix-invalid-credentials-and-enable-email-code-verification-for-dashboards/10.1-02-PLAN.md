---
phase: 10.1-auth-system-diagnosis-fix-invalid-credentials-and-enable-email-code-verification-for-dashboards
plan: 02
type: execute
wave: 2
depends_on:
  - 10.1-01
files_modified:
  - frontend-public/src/pages/CitizenLoginPage.tsx
  - frontend-dashboard/src/pages/LoginPage.tsx
  - scripts/remediate_unconfirmed_accounts.sql
autonomous: false
requirements:
  - SEC-01
  - SEC-02

must_haves:
  truths:
    - "Citizen login page has 3 auth modes: email+password, phone OTP, and email OTP"
    - "Municipal login page has 3 auth modes: email+password, phone OTP, and email OTP"
    - "Email OTP login sends a 6-digit code to the user's email and verifies it inline"
    - "Existing stuck accounts (email_confirmed_at = NULL) are confirmed via SQL remediation"
    - "Users receive a 6-digit numeric code (not a magic link URL) in their email for both registration and sign-in OTP flows"
  artifacts:
    - path: "frontend-public/src/pages/CitizenLoginPage.tsx"
      provides: "Email OTP sign-in mode"
      contains: "email-otp"
    - path: "frontend-dashboard/src/pages/LoginPage.tsx"
      provides: "Email OTP sign-in mode"
      contains: "email-otp"
    - path: "scripts/remediate_unconfirmed_accounts.sql"
      provides: "Version-controlled SQL remediation for stuck accounts"
      contains: "email_confirmed_at"
  key_links:
    - from: "frontend-public/src/pages/CitizenLoginPage.tsx"
      to: "frontend-public/src/contexts/AuthContext.tsx"
      via: "useAuth().signInWithEmailOtp and verifyEmailOtp"
      pattern: "signInWithEmailOtp\\("
    - from: "frontend-dashboard/src/pages/LoginPage.tsx"
      to: "frontend-dashboard/src/hooks/useAuth.ts"
      via: "useAuth().signInWithEmailOtp and verifyEmailOtp"
      pattern: "signInWithEmailOtp\\("
---

<objective>
Add email OTP sign-in mode to both login pages, remediate stuck accounts, and verify Supabase email template configuration.

Purpose: Completes the email OTP feature by adding it as a login method alongside existing email+password and phone OTP. Also fixes the two existing stuck accounts and verifies the Supabase Dashboard template is correctly configured for both signup confirmation and passwordless login.

Output: Both login pages support 3 auth modes. Stuck accounts can sign in. OTP template verified in Dashboard.
</objective>

<execution_context>
@C:/Users/Bantu/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Bantu/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10.1-auth-system-diagnosis-fix-invalid-credentials-and-enable-email-code-verification-for-dashboards/10.1-RESEARCH.md
@.planning/phases/10.1-auth-system-diagnosis-fix-invalid-credentials-and-enable-email-code-verification-for-dashboards/10.1-01-SUMMARY.md

@frontend-public/src/pages/CitizenLoginPage.tsx
@frontend-dashboard/src/pages/LoginPage.tsx
@frontend-public/src/contexts/AuthContext.tsx
@frontend-dashboard/src/hooks/useAuth.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add email OTP sign-in mode to both login pages and remediate stuck accounts</name>
  <files>
    frontend-public/src/pages/CitizenLoginPage.tsx
    frontend-dashboard/src/pages/LoginPage.tsx
    scripts/remediate_unconfirmed_accounts.sql
  </files>
  <action>
**SQL Remediation (tracked script + MCP execution):**

1. Create `scripts/remediate_unconfirmed_accounts.sql` with the following content:
```sql
-- Remediate stuck accounts created via frontend signUp() that never confirmed email.
-- Targets real user accounts with full_name in metadata (test profiles use email_confirm: true instead).
-- Run via: mcp__supabase__execute_sql or psql against the Supabase project.

UPDATE auth.users
SET email_confirmed_at = NOW(), updated_at = NOW()
WHERE email_confirmed_at IS NULL
  AND raw_user_meta_data->>'full_name' IS NOT NULL;

-- Verification: confirm 0 unconfirmed real accounts remain
SELECT count(*) AS remaining_unconfirmed
FROM auth.users
WHERE email_confirmed_at IS NULL
  AND raw_user_meta_data->>'full_name' IS NOT NULL;
```

2. Execute the UPDATE statement via the `mcp__supabase__execute_sql` tool.

3. Execute the verification SELECT via `mcp__supabase__execute_sql` and confirm the result is `remaining_unconfirmed = 0`. If count > 0, investigate and re-run.

This fixes the 2 stuck accounts (`bantuson.enquiries@gmail.com` and `sipho.ndlovu@gmail.com`) that were created via frontend signUp() but never confirmed. The WHERE clause targets only real user accounts (test profiles don't have full_name in metadata, they use email_confirm: true).

**frontend-public/src/pages/CitizenLoginPage.tsx:**

1. Expand `AuthMode` type to include email OTP:
```typescript
type AuthMode = 'email' | 'phone' | 'verify-otp' | 'email-otp' | 'verify-email-otp';
```

2. Destructure the new methods from `useAuth()`:
```typescript
const { signInWithEmail, signInWithPhone, verifyOtp, signInWithEmailOtp, verifyEmailOtp } = useAuth();
```

3. Add `emailForOtp` state to capture the email when sending OTP:
```typescript
const [emailForOtp, setEmailForOtp] = useState('');
```

4. Add `handleEmailOtpSend` handler:
```typescript
const handleEmailOtpSend = async (e: React.FormEvent) => {
  e.preventDefault();
  setLoading(true);
  setError(null);
  try {
    await signInWithEmailOtp(email);
    setEmailForOtp(email);
    setMode('verify-email-otp');
  } catch (err) {
    setError(err instanceof Error ? err.message : 'Failed to send verification code');
  } finally {
    setLoading(false);
  }
};
```

5. Add `handleVerifyEmailOtp` handler:
```typescript
const handleVerifyEmailOtp = async (e: React.FormEvent) => {
  e.preventDefault();
  setLoading(true);
  setError(null);
  try {
    await verifyEmailOtp(emailForOtp, otpToken);
    const returnUrl = location.state?.from?.pathname || sessionStorage.getItem('returnUrl') || '/profile';
    sessionStorage.removeItem('returnUrl');
    navigate(returnUrl, { replace: true });
  } catch (err) {
    setError(err instanceof Error ? err.message : 'Invalid verification code');
  } finally {
    setLoading(false);
  }
};
```

6. Add UI for `email-otp` mode (between phone and verify-otp modes):
   - Email input field (reuse `email` state)
   - "Send Verification Code" submit button
   - "Back to email login" link button

7. Add UI for `verify-email-otp` mode:
   - Info box: "Verification code sent to {emailForOtp}"
   - 6-digit OTP input (same styling as phone OTP: `inputMode="numeric"`, `maxLength={6}`, `pattern="[0-9]{6}"`, `autoComplete="one-time-code"`)
   - "Verify Code" submit button
   - "Resend Code" button that calls `signInWithEmailOtp(emailForOtp)` again

8. Update the `mode === 'email'` form to add an "Email OTP" option button:
   - After the existing "Sign in with Phone OTP" button, add a new button: "Sign in with Email Code"
   - `onClick={() => setMode('email-otp')}`
   - Same `styles.linkButton` styling

**frontend-dashboard/src/pages/LoginPage.tsx:**

Apply the identical pattern as citizen login:

1. Expand `AuthMode` type to include `'email-otp' | 'verify-email-otp'`
2. Destructure `signInWithEmailOtp` and `verifyEmailOtp` from `useAuth()`
3. Add `emailForOtp` state
4. Add `handleEmailOtpSend` and `handleVerifyEmailOtp` handlers
5. Add `email-otp` mode UI (email input + send button)
6. Add `verify-email-otp` mode UI (info box + OTP input + verify button)
7. Add "Sign in with Email Code" link button in the `mode === 'email'` form

**For the municipal login page**, after successful email OTP verification, do NOT navigate manually — auth state change triggers redirect via App.tsx (same pattern as existing email+password login).

**Styling notes:**
- Reuse existing `styles.infoBox` (green/teal) for the "code sent" message
- Reuse existing `styles.input`, `styles.button`, `styles.linkButton`
- OTP input should have centered text with letter spacing for code-entry feel
  </action>
  <verify>
    <automated>cd C:/Users/Bantu/mzansi-agentive/salga-trust-engine/frontend-public && npx tsc --noEmit 2>&1 | head -20 && cd C:/Users/Bantu/mzansi-agentive/salga-trust-engine/frontend-dashboard && npx tsc --noEmit 2>&1 | head -20</automated>
    <automated>mcp__supabase__execute_sql: SELECT count(*) AS remaining_unconfirmed FROM auth.users WHERE email_confirmed_at IS NULL AND raw_user_meta_data->>'full_name' IS NOT NULL; -- must return 0</automated>
    <manual>Visit /login on both dashboards. Verify 3 auth modes are available: email+password, phone OTP, email OTP. Test email OTP flow: enter email, send code, enter 6-digit code, verify redirect.</manual>
  </verify>
  <done>Both login pages support email OTP sign-in mode alongside existing email+password and phone OTP. Stuck accounts confirmed via SQL (remaining_unconfirmed = 0). scripts/remediate_unconfirmed_accounts.sql exists as version-controlled artifact. Both frontends compile without TypeScript errors.</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 2: Verify Supabase Dashboard email template configuration</name>
  <files>templates/email/otp-supabase-paste.html</files>
  <action>
This is a human verification checkpoint. Claude has completed all code changes. The user must verify Supabase Dashboard email template configuration manually:

1. Go to Supabase Dashboard > Authentication > Email Templates
2. Check the "Confirm signup" template slot — it should contain the branded OTP HTML from templates/email/otp-supabase-paste.html with {{ .Token }} as plain text (NOT inside an anchor tag). If it shows a magic link or default template, paste the contents of otp-supabase-paste.html into this slot.
3. Check the "Magic Link" template slot — same check. Phase 06.8-05 already deployed here; verify it is still active.
4. Test registration flow: register a new test account on /register, check email for 6-digit code (not a magic link URL), enter code in OTP input, verify redirect to /profile.
5. Test email OTP login: sign out, go to /login, click "Sign in with Email Code", enter email, receive 6-digit code, enter code, verify logged in.
  </action>
  <verify>User confirms both Supabase template slots show branded OTP with {{ .Token }} and both flows (registration OTP + login email OTP) produce 6-digit codes in email.</verify>
  <done>Both Supabase template slots verified. Registration OTP flow and email OTP login flow work end-to-end with 6-digit codes. User types "approved".</done>
</task>

</tasks>

<verification>
1. `cd frontend-public && npx tsc --noEmit` — zero TypeScript errors
2. `cd frontend-dashboard && npx tsc --noEmit` — zero TypeScript errors
3. Both login pages have email OTP mode accessible from the email login form
4. Email OTP sends code via signInWithEmailOtp (shouldCreateUser: false)
5. Email OTP verifies via verifyEmailOtp (type: 'email')
6. SQL remediation executed for stuck accounts
7. Supabase Dashboard templates verified (checkpoint)
</verification>

<success_criteria>
- Both login pages support 3 auth modes: email+password, phone OTP, email OTP
- Email OTP flow: enter email -> receive 6-digit code -> enter code -> logged in
- Stuck accounts (email_confirmed_at = NULL) are fixed
- Supabase Dashboard "Confirm signup" and "Magic Link" slots both have branded OTP template
- No TypeScript errors in either frontend
</success_criteria>

<output>
After completion, create `.planning/phases/10.1-auth-system-diagnosis-fix-invalid-credentials-and-enable-email-code-verification-for-dashboards/10.1-02-SUMMARY.md`
</output>
