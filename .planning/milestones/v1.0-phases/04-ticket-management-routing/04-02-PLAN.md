---
phase: 04-ticket-management-routing
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - src/services/routing_service.py
  - src/services/assignment_service.py
autonomous: true

must_haves:
  truths:
    - "System finds nearest team by location and category using PostGIS spatial queries"
    - "GBV tickets are NEVER routed to municipal teams - only to SAPS teams"
    - "Ticket assignment creates TicketAssignment record and updates ticket.assigned_team_id"
    - "Previous assignments marked is_current=False when new assignment created"
    - "Fallback to any active team in municipality when no geospatial match found"
  artifacts:
    - path: "src/services/routing_service.py"
      provides: "Geospatial ticket routing logic"
      contains: "class RoutingService"
    - path: "src/services/assignment_service.py"
      provides: "Ticket assignment with history tracking"
      contains: "class AssignmentService"
  key_links:
    - from: "src/services/routing_service.py"
      to: "src/models/team.py"
      via: "PostGIS ST_DWithin query on Team.service_area"
      pattern: "ST_DWithin|ST_Distance"
    - from: "src/services/routing_service.py"
      to: "src/models/ticket.py"
      via: "reads ticket.location and ticket.category"
      pattern: "ticket\\.location|ticket\\.category"
    - from: "src/services/assignment_service.py"
      to: "src/models/assignment.py"
      via: "creates TicketAssignment records"
      pattern: "TicketAssignment"
---

<objective>
Implement geospatial routing service that finds the nearest municipal team based on ticket location and category, and assignment service that records ticket-to-team assignments with full history.

Purpose: TKT-02 (geospatial routing) and SEC-05 (GBV firewall) are the core routing requirements. This plan creates the routing logic that will be called from API endpoints (Plan 04) and Celery tasks (Plan 03).

Output: RoutingService and AssignmentService classes ready for use by API and background tasks.
</objective>

<execution_context>
@C:/Users/Bantu/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Bantu/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-ticket-management-routing/04-RESEARCH.md
@.planning/phases/04-ticket-management-routing/04-01-SUMMARY.md
@src/models/team.py
@src/models/assignment.py
@src/models/ticket.py
@src/models/base.py
@src/core/database.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create geospatial routing service with GBV firewall</name>
  <files>src/services/routing_service.py</files>
  <action>
    Create `src/services/routing_service.py` with class `RoutingService`:

    1. `async def route_ticket(self, ticket: Ticket, db: AsyncSession) -> Team | None`:
       - Entry point for routing. Checks `ticket.is_sensitive` / `ticket.category == "gbv"`.
       - If GBV: calls `_route_gbv_ticket()` -- MUST only return SAPS teams
       - If municipal: calls `_route_municipal_ticket()`
       - Returns matched Team or None (if no match, ticket stays unassigned for manual routing)

    2. `async def _route_municipal_ticket(self, ticket: Ticket, db: AsyncSession) -> Team | None`:
       - If ticket.location is not None:
         - Query teams WHERE category matches ticket.category AND is_active=True AND is_saps=False
         - Use `ST_DWithin(Team.service_area, ticket.location, 10000)` for 10km radius
         - Order by `ST_Distance(Team.service_area, ticket.location)` ascending
         - Limit 1 (nearest team)
       - If no spatial match OR ticket.location is None:
         - Fallback: find any active team matching category within same tenant
         - `select(Team).where(Team.category == ticket.category, Team.tenant_id == ticket.tenant_id, Team.is_active == True, Team.is_saps == False).limit(1)`
       - Return team or None

    3. `async def _route_gbv_ticket(self, ticket: Ticket, db: AsyncSession) -> Team | None`:
       - SECURITY: Only query teams WHERE is_saps=True AND is_active=True
       - NEVER include is_saps=False teams in GBV routing
       - If ticket.location is not None:
         - Find nearest SAPS team using ST_DWithin (same pattern as municipal but is_saps=True)
       - Fallback: any active SAPS team in same tenant
       - Log warning if no SAPS team found: "No SAPS team configured for tenant {tenant_id}"
       - Return team or None

    4. `async def find_teams_near_location(self, location, category: str, tenant_id: str, db: AsyncSession, radius_meters: int = 10000) -> list[Team]`:
       - Utility method for API: returns list of teams within radius, ordered by distance
       - Useful for manual re-routing in Phase 5 dashboard

    Import notes:
    - Use `from geoalchemy2.functions import ST_DWithin, ST_Distance` for spatial queries
    - Use `from sqlalchemy import select` for query building
    - Use `from sqlalchemy.ext.asyncio import AsyncSession`
    - Add logging throughout (import logging, get logger)
    - All methods are async (database is async)

    GBV FIREWALL (SEC-05):
    - The `_route_gbv_ticket` method MUST have an explicit guard at the top: `assert ticket.is_sensitive or ticket.category == "gbv"`
    - The query MUST filter `Team.is_saps == True` -- no conditional logic that could be bypassed
    - Add a comment block: "# SEC-05: GBV tickets MUST only route to SAPS teams. This is a security boundary."
  </action>
  <verify>
    Run `python -c "from src.services.routing_service import RoutingService; print('RoutingService OK')"` succeeds.
    Verify file contains "is_saps == True" in _route_gbv_ticket.
    Verify file contains "is_saps == False" in _route_municipal_ticket (ensures municipal routing excludes SAPS teams).
    Verify file contains ST_DWithin or ST_Distance import.
  </verify>
  <done>
    RoutingService routes municipal tickets by location+category using PostGIS, routes GBV tickets exclusively to SAPS teams, and falls back to category-based routing when no spatial match exists.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create ticket assignment service with history tracking</name>
  <files>src/services/assignment_service.py</files>
  <action>
    Create `src/services/assignment_service.py` with class `AssignmentService`:

    1. `async def assign_ticket(self, ticket_id: UUID, team_id: UUID | None, assigned_to: UUID | None, assigned_by: str, reason: str, db: AsyncSession) -> TicketAssignment`:
       - Deactivate previous active assignments: `UPDATE ticket_assignments SET is_current=False WHERE ticket_id=:ticket_id AND is_current=True`
       - Create new TicketAssignment record with is_current=True
       - Update Ticket: set `assigned_team_id = team_id`, `assigned_to = assigned_to`
       - If `assigned_to` is set and ticket.status == "open", update status to "in_progress" and set `first_responded_at = datetime.utcnow()` (only if first_responded_at is None)
       - Commit and return the new TicketAssignment
       - Log: "Ticket {ticket_id} assigned to team {team_id} by {assigned_by} reason={reason}"

    2. `async def auto_route_and_assign(self, ticket: Ticket, db: AsyncSession) -> TicketAssignment | None`:
       - Convenience method combining RoutingService + assignment
       - Instantiate RoutingService, call route_ticket()
       - If team found, call assign_ticket() with assigned_by="system", reason="geospatial_routing"
       - If no team found, log warning and return None (ticket stays unassigned)
       - Return the TicketAssignment or None

    3. `async def reassign_ticket(self, ticket_id: UUID, new_team_id: UUID, assigned_by: str, reason: str, db: AsyncSession) -> TicketAssignment`:
       - Load ticket, validate new_team_id exists
       - GBV GUARD: If ticket.is_sensitive, verify new team has is_saps=True. Raise ValueError("GBV tickets can only be assigned to SAPS teams") if not.
       - Call assign_ticket() with the new values

    4. `async def get_assignment_history(self, ticket_id: UUID, db: AsyncSession) -> list[TicketAssignment]`:
       - Return all TicketAssignment records for ticket, ordered by created_at descending
       - Used for audit trail (TKT-05)

    Import notes:
    - Import RoutingService from src.services.routing_service
    - Import TicketAssignment from src.models.assignment
    - Import Ticket from src.models.ticket
    - Import Team from src.models.team
    - Use `from sqlalchemy import select, update`
    - Add logging throughout
  </action>
  <verify>
    Run `python -c "from src.services.assignment_service import AssignmentService; print('AssignmentService OK')"` succeeds.
    Verify file contains GBV guard in reassign_ticket (checks is_saps).
    Verify file deactivates previous assignments before creating new one.
  </verify>
  <done>
    AssignmentService creates/deactivates assignments with full history, auto-routes via RoutingService, enforces GBV-to-SAPS constraint on reassignment, and tracks first response time for SLA.
  </done>
</task>

</tasks>

<verification>
1. RoutingService imports and instantiates without errors
2. AssignmentService imports and instantiates without errors
3. GBV routing explicitly filters is_saps=True (SEC-05)
4. Municipal routing explicitly filters is_saps=False
5. Assignment history tracked (TKT-05 partial)
6. Existing tests still pass
</verification>

<success_criteria>
- RoutingService.route_ticket() routes municipal tickets via PostGIS proximity and GBV tickets to SAPS teams only
- AssignmentService.assign_ticket() creates TicketAssignment with history and updates Ticket
- GBV firewall prevents GBV ticket assignment to non-SAPS teams at both routing and reassignment
- Fallback routing works when no spatial match (category-based within tenant)
- Zero test regressions
</success_criteria>

<output>
After completion, create `.planning/phases/04-ticket-management-routing/04-02-SUMMARY.md`
</output>
