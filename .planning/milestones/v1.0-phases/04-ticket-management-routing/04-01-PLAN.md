---
phase: 04-ticket-management-routing
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/models/team.py
  - src/models/assignment.py
  - src/models/sla_config.py
  - src/models/ticket.py
  - src/models/__init__.py
  - src/schemas/team.py
  - src/schemas/assignment.py
  - src/schemas/__init__.py
  - alembic/versions/04_01_postgis_teams_sla.py
  - alembic/env.py
  - pyproject.toml
  - src/tasks/__init__.py
  - src/tasks/celery_app.py
  - src/core/config.py
autonomous: true

must_haves:
  truths:
    - "Team model stores service area polygon and category specialization"
    - "Assignment model tracks ticket-to-team assignment history"
    - "SLA configuration is per-municipality with category overrides"
    - "Ticket model has PostGIS geometry column for spatial queries"
    - "Celery app is configured with Redis broker and beat schedule"
    - "Alembic migration creates PostGIS extension and migrates lat/lng to geometry"
  artifacts:
    - path: "src/models/team.py"
      provides: "Municipal team model with service_area polygon"
      contains: "class Team"
    - path: "src/models/assignment.py"
      provides: "Ticket assignment history model"
      contains: "class TicketAssignment"
    - path: "src/models/sla_config.py"
      provides: "SLA configuration per municipality/category"
      contains: "class SLAConfig"
    - path: "src/models/ticket.py"
      provides: "Updated ticket with PostGIS location and SLA fields"
      contains: "Geometry"
    - path: "src/tasks/celery_app.py"
      provides: "Celery application instance"
      contains: "Celery"
    - path: "alembic/versions/04_01_postgis_teams_sla.py"
      provides: "Database migration for Phase 4 models"
      contains: "CREATE EXTENSION"
  key_links:
    - from: "src/models/team.py"
      to: "src/models/base.py"
      via: "inherits TenantAwareModel"
      pattern: "class Team\\(TenantAwareModel\\)"
    - from: "src/models/assignment.py"
      to: "src/models/ticket.py"
      via: "ForeignKey to tickets"
      pattern: "ForeignKey.*tickets"
    - from: "src/tasks/celery_app.py"
      to: "src/core/config.py"
      via: "reads REDIS_URL for broker"
      pattern: "settings\\.REDIS_URL"
---

<objective>
Create all Phase 4 data models (Team, TicketAssignment, SLAConfig), migrate Ticket location from separate lat/lng to PostGIS GEOMETRY, set up Celery infrastructure, and install new dependencies.

Purpose: Everything in Phase 4 depends on these models and infrastructure. Team routes tickets, SLAConfig defines targets, TicketAssignment records history, PostGIS enables spatial queries, Celery enables background SLA monitoring.

Output: New models with migration, Celery app configured, dependencies installed.
</objective>

<execution_context>
@C:/Users/Bantu/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Bantu/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-ticket-management-routing/04-RESEARCH.md
@src/models/base.py
@src/models/ticket.py
@src/models/__init__.py
@src/core/config.py
@src/core/database.py
@alembic/env.py
@pyproject.toml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install dependencies, create Team/Assignment/SLAConfig models, and update Ticket for PostGIS</name>
  <files>
    pyproject.toml
    src/models/team.py
    src/models/assignment.py
    src/models/sla_config.py
    src/models/ticket.py
    src/models/__init__.py
    src/schemas/team.py
    src/schemas/assignment.py
    src/schemas/__init__.py
    src/core/config.py
  </files>
  <action>
    1. Add dependencies to pyproject.toml:
       - `geoalchemy2>=0.18.0` (PostGIS integration)
       - `shapely>=2.0.0` (geometry manipulation)
       - `celery[redis]>=5.6.0` (task queue with Redis broker)
       Run `pip install -e ".[dev]"` to install.

    2. Create `src/models/team.py` - Municipal team model (TenantAwareModel):
       - `name: Mapped[str]` (String(100), not null)
       - `category: Mapped[str]` (String(20), not null) - matches TicketCategory values
       - `service_area: Mapped[str | None]` mapped_column with `Geometry("POLYGON", srid=4326)` from geoalchemy2, nullable=True (placeholder polygon initially, admin defines later in Phase 5)
       - `manager_id: Mapped[UUID | None]` ForeignKey to users.id (nullable, the team manager for escalation)
       - `is_active: Mapped[bool]` default True
       - `is_saps: Mapped[bool]` default False (True for SAPS liaison teams handling GBV)
       - Add `__repr__` method

    3. Create `src/models/assignment.py` - TicketAssignment model (TenantAwareModel):
       - `ticket_id: Mapped[UUID]` ForeignKey to tickets.id, not null, indexed
       - `team_id: Mapped[UUID | None]` ForeignKey to teams.id, nullable (manual assignments may not have team)
       - `assigned_to: Mapped[UUID | None]` ForeignKey to users.id, nullable
       - `assigned_by: Mapped[str | None]` String - "system" for auto-routing, user_id for manual
       - `reason: Mapped[str | None]` String(200) - "geospatial_routing", "manual_override", "escalation", "sla_breach"
       - `is_current: Mapped[bool]` default True (only one active assignment per ticket)
       - Add `__repr__` method

    4. Create `src/models/sla_config.py` - SLA configuration model (NonTenantModel, since admins configure cross-tenant):
       - `municipality_id: Mapped[UUID]` ForeignKey to municipalities.id, not null
       - `category: Mapped[str | None]` String(20), nullable (null = default for municipality)
       - `response_hours: Mapped[int]` default 24 (hours until first response required)
       - `resolution_hours: Mapped[int]` default 168 (7 days in hours)
       - `warning_threshold_pct: Mapped[int]` default 80 (percent of SLA elapsed triggers warning)
       - `is_active: Mapped[bool]` default True
       - UniqueConstraint on (municipality_id, category) named "uq_sla_config_municipality_category"
       - Add `__repr__` method

    5. Update `src/models/ticket.py`:
       - Add import: `from geoalchemy2 import Geometry`
       - Replace `latitude` and `longitude` Float columns with single `location` column: `mapped_column(Geometry("POINT", srid=4326), nullable=True)`
       - KEEP the `address` column (manual address fallback)
       - Add `assigned_team_id: Mapped[UUID | None]` ForeignKey to teams.id, nullable
       - Add `escalated_at: Mapped[datetime | None]` nullable
       - Add `escalation_reason: Mapped[str | None]` String(200), nullable
       - Add `first_responded_at: Mapped[datetime | None]` nullable (tracks SLA response time)
       - Add `sla_response_deadline: Mapped[datetime | None]` nullable
       - Add `sla_resolution_deadline: Mapped[datetime | None]` nullable
       - Keep existing `latitude` and `longitude` as DEPRECATED properties that read from/write to `location` using `from geoalchemy2.shape import to_shape` and `from geoalchemy2.elements import WKTElement` -- this maintains backward compatibility with Phase 2-3 code that sets lat/lng. Add `@property` for `latitude` and `longitude` that extract from self.location using `to_shape(self.location).y` and `.x` respectively (return None if location is None). These are READ-ONLY properties. Remove the mapped_column versions of latitude and longitude.

    6. Update `src/models/__init__.py` to export new models:
       - Import and export Team, TicketAssignment, SLAConfig

    7. Create `src/schemas/team.py`:
       - `TeamCreate(BaseModel)`: name, category, manager_id (optional UUID), is_saps (bool, default False)
       - `TeamResponse(BaseModel)`: id, name, category, manager_id, is_active, is_saps, created_at. ConfigDict(from_attributes=True)
       - Validate category against TicketCategory values

    8. Create `src/schemas/assignment.py`:
       - `AssignmentCreate(BaseModel)`: ticket_id (UUID), team_id (optional UUID), assigned_to (optional UUID), reason (optional str)
       - `AssignmentResponse(BaseModel)`: id, ticket_id, team_id, assigned_to, assigned_by, reason, is_current, created_at. ConfigDict(from_attributes=True)

    9. Update `src/schemas/__init__.py` to export new schemas.

    10. Update `src/core/config.py`:
        - Add `CELERY_BROKER_URL: str = Field(default="redis://localhost:6379/1", description="Celery broker URL")` (use DB 1, not 0 which is used for rate limiting/sessions)
        - Add `CELERY_RESULT_BACKEND: str = Field(default="redis://localhost:6379/1", description="Celery result backend URL")`
        - Add `SLA_CHECK_INTERVAL_SECONDS: int = Field(default=300, description="SLA check interval in seconds (default 5 minutes)")`

    IMPORTANT: When creating the Geometry column in Team and Ticket, import from geoalchemy2 at the top of the file. Use `from geoalchemy2 import Geometry` (not `from geoalchemy2.types import Geometry`).

    IMPORTANT: The latitude/longitude backward-compat properties in Ticket should use try/except ImportError for geoalchemy2 to prevent import errors in unit tests that don't have PostGIS. If geoalchemy2 is not available or location is a raw string (in tests), return None.
  </action>
  <verify>
    Run `python -c "from src.models.team import Team; from src.models.assignment import TicketAssignment; from src.models.sla_config import SLAConfig; print('Models OK')"` succeeds.
    Run `python -c "from src.schemas.team import TeamCreate, TeamResponse; from src.schemas.assignment import AssignmentCreate, AssignmentResponse; print('Schemas OK')"` succeeds.
    Run `python -c "from src.models.ticket import Ticket; print(Ticket.__table__.columns.keys())"` shows 'location' instead of separate 'latitude'/'longitude'.
    Run `python -c "from src.core.config import Settings; print('Config OK')"` succeeds.
  </verify>
  <done>
    Team, TicketAssignment, and SLAConfig models exist with correct fields and constraints. Ticket model has PostGIS location column with backward-compatible lat/lng properties. Schemas for team and assignment exist. Config has Celery settings. All new dependencies installed.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Alembic migration and Celery app infrastructure</name>
  <files>
    alembic/versions/04_01_postgis_teams_sla.py
    alembic/env.py
    src/tasks/__init__.py
    src/tasks/celery_app.py
  </files>
  <action>
    1. Update `alembic/env.py`:
       - Add import: `from src.models import team, assignment, sla_config` alongside existing model imports
       - This ensures Alembic detects the new models for autogenerate

    2. Create Alembic migration `alembic/versions/04_01_postgis_teams_sla.py` (MANUAL migration, not autogenerate since PostGIS needs special handling):
       - revision = "04_01_postgis"
       - down_revision = "02_01_ticket" (the last migration from Phase 2)
       - depends_on = None

       upgrade():
       ```python
       # Enable PostGIS extension
       op.execute("CREATE EXTENSION IF NOT EXISTS postgis")

       # Create teams table
       op.create_table(
           "teams",
           sa.Column("id", sa.Uuid(), nullable=False, default=uuid4),
           sa.Column("tenant_id", sa.String(), nullable=False),
           sa.Column("name", sa.String(100), nullable=False),
           sa.Column("category", sa.String(20), nullable=False),
           sa.Column("service_area", Geometry("POLYGON", srid=4326), nullable=True),
           sa.Column("manager_id", sa.Uuid(), sa.ForeignKey("users.id"), nullable=True),
           sa.Column("is_active", sa.Boolean(), nullable=False, server_default="true"),
           sa.Column("is_saps", sa.Boolean(), nullable=False, server_default="false"),
           sa.Column("created_at", sa.DateTime(timezone=True), server_default=func.now(), nullable=False),
           sa.Column("updated_at", sa.DateTime(timezone=True), nullable=True),
           sa.Column("created_by", sa.String(), nullable=True),
           sa.Column("updated_by", sa.String(), nullable=True),
           sa.PrimaryKeyConstraint("id"),
       )
       op.create_index("ix_teams_tenant_id", "teams", ["tenant_id"])
       op.create_index("ix_teams_category", "teams", ["category"])
       # GIST index for spatial queries
       op.create_index("ix_teams_service_area", "teams", ["service_area"], postgresql_using="gist")

       # Create ticket_assignments table
       op.create_table(
           "ticket_assignments",
           sa.Column("id", sa.Uuid(), nullable=False, default=uuid4),
           sa.Column("tenant_id", sa.String(), nullable=False),
           sa.Column("ticket_id", sa.Uuid(), sa.ForeignKey("tickets.id"), nullable=False),
           sa.Column("team_id", sa.Uuid(), sa.ForeignKey("teams.id"), nullable=True),
           sa.Column("assigned_to", sa.Uuid(), sa.ForeignKey("users.id"), nullable=True),
           sa.Column("assigned_by", sa.String(), nullable=True),
           sa.Column("reason", sa.String(200), nullable=True),
           sa.Column("is_current", sa.Boolean(), nullable=False, server_default="true"),
           sa.Column("created_at", sa.DateTime(timezone=True), server_default=func.now(), nullable=False),
           sa.Column("updated_at", sa.DateTime(timezone=True), nullable=True),
           sa.Column("created_by", sa.String(), nullable=True),
           sa.Column("updated_by", sa.String(), nullable=True),
           sa.PrimaryKeyConstraint("id"),
       )
       op.create_index("ix_ticket_assignments_ticket_id", "ticket_assignments", ["ticket_id"])
       op.create_index("ix_ticket_assignments_tenant_id", "ticket_assignments", ["tenant_id"])

       # Create sla_configs table (NonTenantModel - no tenant_id in base)
       op.create_table(
           "sla_configs",
           sa.Column("id", sa.Uuid(), nullable=False, default=uuid4),
           sa.Column("municipality_id", sa.Uuid(), sa.ForeignKey("municipalities.id"), nullable=False),
           sa.Column("category", sa.String(20), nullable=True),
           sa.Column("response_hours", sa.Integer(), nullable=False, server_default="24"),
           sa.Column("resolution_hours", sa.Integer(), nullable=False, server_default="168"),
           sa.Column("warning_threshold_pct", sa.Integer(), nullable=False, server_default="80"),
           sa.Column("is_active", sa.Boolean(), nullable=False, server_default="true"),
           sa.Column("created_at", sa.DateTime(timezone=True), server_default=func.now(), nullable=False),
           sa.Column("updated_at", sa.DateTime(timezone=True), nullable=True),
           sa.UniqueConstraint("municipality_id", "category", name="uq_sla_config_municipality_category"),
       )

       # Modify tickets table: migrate lat/lng to PostGIS geometry
       # Add new location geometry column
       op.add_column("tickets", sa.Column("location", Geometry("POINT", srid=4326), nullable=True))
       # Migrate existing lat/lng data to location geometry
       op.execute("""
           UPDATE tickets SET location = ST_SetSRID(ST_MakePoint(longitude, latitude), 4326)
           WHERE latitude IS NOT NULL AND longitude IS NOT NULL
       """)
       # Drop old lat/lng columns
       op.drop_column("tickets", "latitude")
       op.drop_column("tickets", "longitude")
       # Create GIST index on location
       op.create_index("ix_tickets_location", "tickets", ["location"], postgresql_using="gist")

       # Add new ticket columns for SLA and escalation
       op.add_column("tickets", sa.Column("assigned_team_id", sa.Uuid(), sa.ForeignKey("teams.id"), nullable=True))
       op.add_column("tickets", sa.Column("escalated_at", sa.DateTime(timezone=True), nullable=True))
       op.add_column("tickets", sa.Column("escalation_reason", sa.String(200), nullable=True))
       op.add_column("tickets", sa.Column("first_responded_at", sa.DateTime(timezone=True), nullable=True))
       op.add_column("tickets", sa.Column("sla_response_deadline", sa.DateTime(timezone=True), nullable=True))
       op.add_column("tickets", sa.Column("sla_resolution_deadline", sa.DateTime(timezone=True), nullable=True))

       # Add partial index for SLA monitoring (only open/in_progress tickets)
       op.create_index(
           "ix_tickets_sla_monitoring",
           "tickets",
           ["status", "sla_response_deadline"],
           postgresql_where=sa.text("status IN ('open', 'in_progress')")
       )

       # Add CHECK constraint: GBV tickets cannot be assigned to non-SAPS teams
       # This is enforced at the database level as defense-in-depth
       op.execute("""
           ALTER TABLE ticket_assignments
           ADD CONSTRAINT chk_gbv_saps_only
           CHECK (NOT EXISTS (
               SELECT 1 FROM tickets t
               JOIN teams tm ON tm.id = ticket_assignments.team_id
               WHERE t.id = ticket_assignments.ticket_id
               AND t.category = 'gbv'
               AND tm.is_saps = false
           ) OR team_id IS NULL)
       """)
       # NOTE: The above CHECK with subquery may not be supported in all PostgreSQL versions.
       # If it fails, remove it and rely on application-level enforcement only.
       # Actually, PostgreSQL CHECK constraints cannot reference other tables.
       # Use a trigger instead or rely purely on application-level enforcement.
       # REMOVE the CHECK constraint above. Application-level enforcement in routing_service.py
       # is sufficient, with integration tests verifying the constraint.
       ```

       downgrade():
       - Add back latitude/longitude columns to tickets
       - Migrate location data back: `UPDATE tickets SET latitude = ST_Y(location), longitude = ST_X(location) WHERE location IS NOT NULL`
       - Drop location column and new columns
       - Drop ticket_assignments, sla_configs, teams tables
       - `DROP EXTENSION IF EXISTS postgis CASCADE`

       IMPORTANT: Do NOT include the CHECK constraint with subquery -- PostgreSQL does not support CHECK constraints that reference other tables. The GBV routing constraint will be enforced at the application level in routing_service.py.

    3. Create `src/tasks/__init__.py` (empty, makes it a package):
       ```python
       """Celery tasks for background processing."""
       ```

    4. Create `src/tasks/celery_app.py`:
       ```python
       """Celery application configuration for SALGA Trust Engine.

       Configures Celery with Redis broker/backend and beat schedule for periodic SLA monitoring.
       Uses Africa/Johannesburg timezone for SLA calculations.
       """
       from celery import Celery
       from src.core.config import settings

       app = Celery(
           "salga_trust_engine",
           broker=settings.CELERY_BROKER_URL,
           backend=settings.CELERY_RESULT_BACKEND,
           include=[
               "src.tasks.sla_monitor",
               "src.tasks.status_notify",
           ]
       )

       # Configuration
       app.conf.update(
           timezone="Africa/Johannesburg",
           task_serializer="json",
           accept_content=["json"],
           result_serializer="json",
           result_expires=86400,  # Results expire after 24 hours
           task_track_started=True,
           task_acks_late=True,  # Acknowledge after task completes (not before)
           worker_prefetch_multiplier=1,  # One task at a time per worker
       )

       # Beat schedule for periodic tasks
       app.conf.beat_schedule = {
           "check-sla-breaches": {
               "task": "src.tasks.sla_monitor.check_sla_breaches",
               "schedule": settings.SLA_CHECK_INTERVAL_SECONDS,
           },
       }
       ```

       NOTE: The `include` references sla_monitor and status_notify which will be created in Plan 03. The Celery app itself is valid without those modules being present yet (they're lazy-loaded).
  </action>
  <verify>
    Run `python -c "from src.tasks.celery_app import app; print(f'Celery app: {app.main}')"` prints "Celery app: salga_trust_engine".
    Run `python -c "from alembic.config import Config; print('Alembic OK')"` succeeds.
    Verify migration file exists and has correct revision chain.
    Run `pytest tests/ -x -m "not integration" --ignore=tests/test_intake_flow.py --ignore=tests/test_municipal_crew.py --ignore=tests/test_gbv_crew.py -q` to confirm no regressions in existing tests.
  </verify>
  <done>
    Alembic migration creates PostGIS extension, teams table with GIST index, ticket_assignments table, sla_configs table, migrates ticket lat/lng to geometry, adds SLA/escalation columns to tickets. Celery app configured with Redis broker and beat schedule. All existing tests still pass.
  </done>
</task>

</tasks>

<verification>
1. All new models importable: `python -c "from src.models import Team, TicketAssignment, SLAConfig"`
2. Ticket model has location (Geometry) instead of latitude/longitude columns
3. Celery app starts without errors: `python -c "from src.tasks.celery_app import app; print(app.conf.beat_schedule)"`
4. Migration file has correct revision chain (down_revision = "02_01_ticket")
5. Existing unit tests pass with no regressions
</verification>

<success_criteria>
- Team, TicketAssignment, SLAConfig models exist with all specified fields
- Ticket model migrated from lat/lng to PostGIS GEOMETRY(Point, 4326)
- Backward-compatible latitude/longitude properties on Ticket
- Alembic migration creates all tables and indexes
- Celery app configured with Redis broker and 5-minute SLA beat schedule
- GeoAlchemy2, Shapely, and Celery dependencies installed
- Zero test regressions
</success_criteria>

<output>
After completion, create `.planning/phases/04-ticket-management-routing/04-01-SUMMARY.md`
</output>
