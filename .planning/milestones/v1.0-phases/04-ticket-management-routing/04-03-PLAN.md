---
phase: 04-ticket-management-routing
plan: 03
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - src/services/sla_service.py
  - src/services/escalation_service.py
  - src/services/notification_service.py
  - src/tasks/sla_monitor.py
  - src/tasks/status_notify.py
autonomous: true

must_haves:
  truths:
    - "SLA deadlines calculated from ticket creation time and SLA config"
    - "SLA breach detection identifies overdue tickets by status and deadline"
    - "Escalation changes ticket status to ESCALATED and assigns to team manager"
    - "WhatsApp status notifications sent to citizen when ticket status changes"
    - "Celery tasks run SLA checks periodically and send notifications asynchronously"
    - "Advisory locks prevent duplicate escalation of same ticket"
  artifacts:
    - path: "src/services/sla_service.py"
      provides: "SLA calculation and breach detection"
      contains: "class SLAService"
    - path: "src/services/escalation_service.py"
      provides: "Ticket escalation to higher authority"
      contains: "class EscalationService"
    - path: "src/services/notification_service.py"
      provides: "WhatsApp status update sender"
      contains: "class NotificationService"
    - path: "src/tasks/sla_monitor.py"
      provides: "Periodic SLA breach checker Celery task"
      contains: "check_sla_breaches"
    - path: "src/tasks/status_notify.py"
      provides: "Async status notification Celery task"
      contains: "send_status_notification"
  key_links:
    - from: "src/tasks/sla_monitor.py"
      to: "src/services/sla_service.py"
      via: "calls SLAService.find_breached_tickets"
      pattern: "sla_service|find_breached"
    - from: "src/tasks/sla_monitor.py"
      to: "src/services/escalation_service.py"
      via: "calls EscalationService.escalate_ticket on breach"
      pattern: "escalation_service|escalate_ticket"
    - from: "src/tasks/status_notify.py"
      to: "src/services/notification_service.py"
      via: "calls NotificationService.send_status_update"
      pattern: "notification_service|send_status_update"
    - from: "src/services/escalation_service.py"
      to: "src/models/ticket.py"
      via: "updates ticket.status to ESCALATED"
      pattern: "TicketStatus\\.ESCALATED"
---

<objective>
Implement SLA tracking, automatic escalation, and WhatsApp citizen notification services, plus the Celery background tasks that run SLA checks periodically and send notifications asynchronously.

Purpose: TKT-01 (status notifications), TKT-03 (SLA tracking), and TKT-04 (auto-escalation) are the ticket lifecycle requirements. This plan creates the background processing layer that monitors and acts on SLA breaches and status changes.

Output: SLAService, EscalationService, NotificationService, plus Celery tasks for periodic SLA monitoring and async notification sending.
</objective>

<execution_context>
@C:/Users/Bantu/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Bantu/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-ticket-management-routing/04-RESEARCH.md
@.planning/phases/04-ticket-management-routing/04-01-SUMMARY.md
@src/models/ticket.py
@src/models/sla_config.py
@src/tasks/celery_app.py
@src/services/whatsapp_service.py
@src/core/config.py
@src/core/database.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create SLA service, escalation service, and notification service</name>
  <files>
    src/services/sla_service.py
    src/services/escalation_service.py
    src/services/notification_service.py
  </files>
  <action>
    1. Create `src/services/sla_service.py` with class `SLAService`:

       a. `async def get_sla_config(self, municipality_id: UUID, category: str, db: AsyncSession) -> SLAConfig | None`:
          - First try exact match: SLAConfig WHERE municipality_id AND category AND is_active
          - If not found, try default: SLAConfig WHERE municipality_id AND category IS NULL AND is_active
          - If still not found, return None (use system defaults)
          - Cache results in-memory dict keyed by (municipality_id, category) for duration of task run

       b. `async def calculate_deadlines(self, ticket: Ticket, db: AsyncSession) -> tuple[datetime, datetime]`:
          - Look up SLAConfig via get_sla_config using ticket's tenant_id (which maps to municipality) and category
          - If no config found, use defaults: response_hours=24, resolution_hours=168
          - response_deadline = ticket.created_at + timedelta(hours=response_hours)
          - resolution_deadline = ticket.created_at + timedelta(hours=resolution_hours)
          - Return (response_deadline, resolution_deadline)

       c. `async def set_ticket_deadlines(self, ticket: Ticket, db: AsyncSession) -> None`:
          - Call calculate_deadlines
          - Set ticket.sla_response_deadline and ticket.sla_resolution_deadline
          - Skip if ticket.is_sensitive (GBV tickets have no SLA per research recommendation)
          - Commit

       d. `async def find_breached_tickets(self, db: AsyncSession) -> list[dict]`:
          - Query tickets WHERE status IN ('open', 'in_progress') AND sla_response_deadline IS NOT NULL
          - For each ticket, determine breach type:
            - If status=='open' AND now > sla_response_deadline: "response_breach"
            - If status IN ('open','in_progress') AND now > sla_resolution_deadline: "resolution_breach"
          - Return list of dicts: [{ticket_id, ticket, breach_type, overdue_by_hours}]
          - Use efficient query: `WHERE (status = 'open' AND sla_response_deadline < now()) OR (status IN ('open','in_progress') AND sla_resolution_deadline < now())`

       e. `async def find_warning_tickets(self, db: AsyncSession) -> list[dict]`:
          - Find tickets approaching SLA breach (within warning threshold %)
          - For each, calculate: elapsed_pct = (now - created_at) / (deadline - created_at) * 100
          - Return tickets where elapsed_pct >= warning_threshold_pct AND not yet breached
          - Used for early warning notifications

       IMPORTANT: GBV tickets (is_sensitive=True) MUST be excluded from SLA monitoring. They are handled by SAPS internally.

    2. Create `src/services/escalation_service.py` with class `EscalationService`:

       a. `async def escalate_ticket(self, ticket_id: UUID, reason: str, db: AsyncSession) -> bool`:
          - Use PostgreSQL advisory lock to prevent duplicate escalation:
            `SELECT pg_try_advisory_xact_lock(:lock_key)` where lock_key = hash(str(ticket_id)) % (2**31)
          - If lock not acquired, log info and return False
          - Load ticket, verify not already ESCALATED
          - Set ticket.status = TicketStatus.ESCALATED
          - Set ticket.escalated_at = datetime.utcnow()
          - Set ticket.escalation_reason = reason
          - Find team manager: load Team by ticket.assigned_team_id, get manager_id
          - If manager found, set ticket.assigned_to = manager_id
          - Create TicketAssignment record (deactivate previous, reason="escalation")
          - Commit
          - Return True

       b. `async def bulk_escalate(self, breached_tickets: list[dict], db: AsyncSession) -> int`:
          - Iterate over breached tickets list from SLAService
          - Call escalate_ticket for each
          - Return count of successfully escalated
          - Log summary: "Escalated {count}/{total} breached tickets"

    3. Create `src/services/notification_service.py` with class `NotificationService`:

       a. `__init__(self)`:
          - Create Twilio client if credentials configured (same pattern as WhatsAppService)
          - Store TWILIO_WHATSAPP_NUMBER from settings

       b. `async def send_status_update(self, phone: str, tracking_number: str, new_status: str, language: str = "en") -> str | None`:
          - Map status to human-readable text in user's language:
            - EN: {"open": "received and under review", "in_progress": "being worked on", "escalated": "escalated to senior team", "resolved": "resolved - please confirm", "closed": "closed"}
            - ZU: {"open": "yamukelwe futhi ibhekwa", "in_progress": "kuyasebenzelwa", "escalated": "idluliselwe ethimini eliphezulu", "resolved": "ixazululiwe - sicela uqinisekise", "closed": "ivaliwe"}
            - AF: {"open": "ontvang en onder hersiening", "in_progress": "word aan gewerk", "escalated": "verwys na senior span", "resolved": "opgelos - bevestig asseblief", "closed": "gesluit"}
          - Format message: "Update for {tracking_number}: Your report is now {status_text}."
            - ZU: "Isibuyekezo se-{tracking_number}: Umbiko wakho manje {status_text}."
            - AF: "Opdatering vir {tracking_number}: U verslag is nou {status_text}."
          - Send via Twilio (same pattern as WhatsAppService.send_whatsapp_message)
          - Return message SID or None on failure
          - IMPORTANT: In production, use Twilio Content API templates (content_sid + content_variables). For now, use body text since templates require pre-approval. Add TODO comment for template migration.

       c. `async def send_sla_warning(self, ticket: Ticket, warning_type: str, db: AsyncSession) -> None`:
          - Internal notification only (no WhatsApp to citizen for warnings)
          - Log: "SLA warning for ticket {ticket.tracking_number}: {warning_type}"
          - Future: send to team lead via internal notification system (Phase 5)

       d. `async def send_escalation_notice(self, ticket: Ticket, db: AsyncSession) -> str | None`:
          - Look up citizen's phone from ticket.user_id -> User.phone
          - Send WhatsApp: "Your report {tracking_number} has been escalated for faster resolution."
          - Trilingual as above
          - Return message SID or None

       IMPORTANT: For the Twilio client, reuse the pattern from `src/services/whatsapp_service.py`. If TWILIO_ACCOUNT_SID or TWILIO_AUTH_TOKEN is empty, log warning and return None (dev mode).
  </action>
  <verify>
    Run `python -c "from src.services.sla_service import SLAService; print('SLAService OK')"` succeeds.
    Run `python -c "from src.services.escalation_service import EscalationService; print('EscalationService OK')"` succeeds.
    Run `python -c "from src.services.notification_service import NotificationService; print('NotificationService OK')"` succeeds.
    Verify SLAService excludes is_sensitive tickets from breach detection.
    Verify EscalationService uses advisory locks.
    Verify NotificationService has trilingual status messages.
  </verify>
  <done>
    SLAService calculates deadlines and finds breached/warning tickets (excluding GBV). EscalationService uses advisory locks and escalates to team manager. NotificationService sends trilingual WhatsApp status updates via Twilio.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Celery tasks for SLA monitoring and status notifications</name>
  <files>
    src/tasks/sla_monitor.py
    src/tasks/status_notify.py
  </files>
  <action>
    1. Create `src/tasks/sla_monitor.py`:
       ```python
       """Periodic SLA breach detection and auto-escalation task.

       Runs every 5 minutes via Celery Beat. Checks all open/in_progress tickets
       for SLA breaches and triggers escalation for overdue tickets.
       """
       import logging
       from src.tasks.celery_app import app

       logger = logging.getLogger(__name__)

       @app.task(bind=True, name="src.tasks.sla_monitor.check_sla_breaches", max_retries=3)
       def check_sla_breaches(self):
           """Check all open/in_progress tickets for SLA breaches.

           Uses synchronous database session (Celery workers are synchronous).
           Finds breached tickets and triggers escalation for each.
           """
           import asyncio
           from src.services.sla_service import SLAService
           from src.services.escalation_service import EscalationService
           from src.core.database import AsyncSessionLocal

           async def _run():
               sla_service = SLAService()
               escalation_service = EscalationService()

               async with AsyncSessionLocal() as db:
                   try:
                       # Find breached tickets
                       breached = await sla_service.find_breached_tickets(db)

                       if not breached:
                           logger.debug("No SLA breaches found")
                           return {"breached": 0, "escalated": 0}

                       logger.info(f"Found {len(breached)} SLA breaches")

                       # Escalate breached tickets
                       escalated = await escalation_service.bulk_escalate(breached, db)

                       logger.info(f"Escalated {escalated}/{len(breached)} tickets")
                       return {"breached": len(breached), "escalated": escalated}

                   except Exception as e:
                       logger.error(f"SLA check failed: {e}", exc_info=True)
                       raise

           try:
               # Run async code in Celery's sync context
               # Use asyncio.run() for clean event loop
               return asyncio.run(_run())
           except Exception as exc:
               logger.error(f"SLA monitor task failed, retrying: {exc}")
               raise self.retry(exc=exc, countdown=60 * (2 ** self.request.retries))
       ```

       IMPORTANT: Celery workers are synchronous. The task wraps async code with asyncio.run().
       On Windows, may need `asyncio.set_event_loop_policy(asyncio.WindowsSelectorEventLoopPolicy())` before asyncio.run().
       Add this at the top of the async _run wrapper if on Windows (check sys.platform).

    2. Create `src/tasks/status_notify.py`:
       ```python
       """Asynchronous ticket status notification task.

       Sends WhatsApp status updates to citizens when ticket status changes.
       Called asynchronously from API endpoints to avoid blocking the request.
       """
       import logging
       from src.tasks.celery_app import app

       logger = logging.getLogger(__name__)

       @app.task(bind=True, name="src.tasks.status_notify.send_status_notification", max_retries=3, default_retry_delay=60)
       def send_status_notification(self, ticket_id: str, user_phone: str, tracking_number: str, old_status: str, new_status: str, language: str = "en"):
           """Send WhatsApp status update notification.

           Args:
               ticket_id: UUID of the ticket (as string for JSON serialization)
               user_phone: Citizen phone number (with country code)
               tracking_number: Ticket tracking number for reference
               old_status: Previous ticket status
               new_status: New ticket status
               language: User's preferred language (en/zu/af)
           """
           import asyncio
           import sys

           if sys.platform == "win32":
               asyncio.set_event_loop_policy(asyncio.WindowsSelectorEventLoopPolicy())

           from src.services.notification_service import NotificationService

           async def _send():
               notification_service = NotificationService()
               result = await notification_service.send_status_update(
                   phone=user_phone,
                   tracking_number=tracking_number,
                   new_status=new_status,
                   language=language,
               )
               return result

           try:
               message_sid = asyncio.run(_send())

               if message_sid:
                   logger.info(
                       f"Status notification sent",
                       extra={
                           "ticket_id": ticket_id,
                           "tracking_number": tracking_number,
                           "new_status": new_status,
                           "message_sid": message_sid,
                       }
                   )
               else:
                   logger.warning(
                       f"Status notification not sent (no Twilio client or failure)",
                       extra={"ticket_id": ticket_id, "new_status": new_status}
                   )

               return {"sent": message_sid is not None, "message_sid": message_sid}

           except Exception as exc:
               logger.error(f"Status notification failed: {exc}", exc_info=True)
               raise self.retry(exc=exc, countdown=60 * (2 ** self.request.retries))
       ```

       IMPORTANT: Only pass primitive types (str, int) to Celery tasks. No SQLAlchemy model instances.
       The task accepts ticket_id as string (not UUID) because Celery uses JSON serialization.
  </action>
  <verify>
    Run `python -c "from src.tasks.sla_monitor import check_sla_breaches; print('SLA monitor task OK')"` succeeds.
    Run `python -c "from src.tasks.status_notify import send_status_notification; print('Status notify task OK')"` succeeds.
    Verify sla_monitor.py uses asyncio.run() wrapper for async code.
    Verify status_notify.py accepts only primitive types (no model instances).
    Run existing tests to confirm no regressions.
  </verify>
  <done>
    check_sla_breaches Celery task runs SLA breach detection every 5 minutes and auto-escalates overdue tickets. send_status_notification task sends trilingual WhatsApp updates asynchronously. Both tasks use retry logic with exponential backoff and handle async code in sync Celery context.
  </done>
</task>

</tasks>

<verification>
1. SLAService calculates deadlines and finds breached tickets (excluding GBV)
2. EscalationService uses PostgreSQL advisory locks for distributed coordination
3. NotificationService sends trilingual WhatsApp messages (EN/ZU/AF)
4. Celery SLA monitor task wraps async services correctly
5. Celery notification task accepts only primitive types (JSON-serializable)
6. All existing tests still pass
</verification>

<success_criteria>
- SLAService.calculate_deadlines returns correct response/resolution deadlines from SLAConfig
- SLAService.find_breached_tickets returns overdue tickets (excluding GBV)
- EscalationService.escalate_ticket uses advisory lock and sets ESCALATED status with team manager
- NotificationService sends WhatsApp in all 3 languages (EN/ZU/AF)
- Celery tasks importable and configured in celery_app beat schedule
- Zero test regressions
</success_criteria>

<output>
After completion, create `.planning/phases/04-ticket-management-routing/04-03-SUMMARY.md`
</output>
