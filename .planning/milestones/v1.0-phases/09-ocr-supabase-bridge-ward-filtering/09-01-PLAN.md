---
phase: 09-ocr-supabase-bridge-ward-filtering
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/api/v1/verification.py
  - frontend-public/src/pages/ProfilePage.tsx
  - tests/test_verification_api.py
autonomous: true
requirements:
  - PLAT-03
  - RPT-09

must_haves:
  truths:
    - "After OCR verification succeeds, Supabase user_metadata.residence_verified is set to true"
    - "After successful verification, the frontend session refreshes so the ReportIssuePage gate unlocks without manual reload"
    - "If Supabase admin client is not configured (local dev), verification still succeeds at DB level with a warning log"
    - "If Supabase admin update fails, the endpoint still returns success (DB is source of truth)"
  artifacts:
    - path: "src/api/v1/verification.py"
      provides: "OCR-to-Supabase bridge via admin.update_user_by_id()"
      contains: "update_user_by_id"
    - path: "frontend-public/src/pages/ProfilePage.tsx"
      provides: "Session refresh after verification success"
      contains: "refreshSession"
    - path: "tests/test_verification_api.py"
      provides: "Tests for Supabase metadata sync on verification"
      contains: "test_verify_proof_of_residence_syncs_supabase"
  key_links:
    - from: "src/api/v1/verification.py"
      to: "src/core/supabase.py"
      via: "get_supabase_admin() call after db.commit()"
      pattern: "get_supabase_admin.*update_user_by_id"
    - from: "frontend-public/src/pages/ProfilePage.tsx"
      to: "Supabase Auth session"
      via: "supabase.auth.refreshSession() after upload success"
      pattern: "refreshSession"
---

<objective>
Bridge the OCR verification result to Supabase user_metadata so the frontend residence gate unlocks.

Purpose: The OCR verification endpoint correctly verifies proof of residence and updates the local DB, but never syncs `residence_verified = true` to Supabase Auth. The frontend reads `user_metadata.residence_verified` from the Supabase session, so the ReportIssuePage gate stays locked forever. This plan closes that gap.

Output: verification.py calls `supabase_admin.auth.admin.update_user_by_id()` after successful verification. ProfilePage.tsx refreshes the session after upload success. Tests cover the bridge.
</objective>

<execution_context>
@C:/Users/Bantu/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Bantu/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-ocr-supabase-bridge-ward-filtering/09-RESEARCH.md
@src/api/v1/verification.py
@src/core/supabase.py
@frontend-public/src/pages/ProfilePage.tsx
@tests/test_verification_api.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Supabase user_metadata sync to verification endpoint</name>
  <files>src/api/v1/verification.py, tests/test_verification_api.py</files>
  <action>
In `src/api/v1/verification.py`, function `verify_proof_of_residence()`:

1. Add import at top of file:
   ```python
   from src.core.supabase import get_supabase_admin
   ```

2. After `await db.commit()` (line 218) and before `await db.refresh(current_user)` (line 219), add the Supabase metadata sync block:
   ```python
   # Sync residence_verified flag to Supabase user_metadata
   # This bridges the DB verification status to the frontend session gate
   if verification_result["status"] == "verified":
       supabase_admin = get_supabase_admin()
       if supabase_admin:
           try:
               supabase_admin.auth.admin.update_user_by_id(
                   str(current_user.id),
                   {
                       "user_metadata": {
                           "residence_verified": True,
                           "residence_verified_at": datetime.utcnow().isoformat(),
                       }
                   }
               )
               logger.info(
                   f"Synced residence_verified=True to Supabase for user {current_user.id}"
               )
           except Exception as e:
               logger.error(
                   f"Failed to sync residence_verified to Supabase for user {current_user.id}: {e}",
                   exc_info=True
               )
               # Do NOT raise — DB is already committed, user is verified locally
       else:
           logger.warning(
               f"Supabase admin client not configured. residence_verified not synced to Supabase "
               f"for user {current_user.id}. Frontend gate will not unlock until Supabase is configured."
           )
   ```

3. Add a `logger` import at the top if not already present:
   ```python
   import logging
   logger = logging.getLogger(__name__)
   ```

4. In `tests/test_verification_api.py`, add three new test cases:

   a. `test_verify_proof_of_residence_syncs_supabase_metadata` — Mock the full verification flow (mock OCR, mock storage, mock db). After the endpoint returns "verified", assert that `supabase_admin.auth.admin.update_user_by_id` was called with the user's ID and `{"user_metadata": {"residence_verified": True, "residence_verified_at": ANY}}`. Patch `src.api.v1.verification.get_supabase_admin` to return a MagicMock.

   b. `test_verify_proof_of_residence_supabase_failure_still_succeeds` — Same setup but make `update_user_by_id` raise an Exception. Assert the endpoint still returns 200 with status "verified". The Supabase failure must not break the response.

   c. `test_verify_proof_of_residence_no_supabase_client_logs_warning` — Patch `get_supabase_admin` to return None. Assert the endpoint still returns 200 with status "verified". Check that a warning was logged (use `caplog` or mock logger).

   Follow the existing test patterns in the file (AsyncMock for db, mock users with verification_status, etc.).
  </action>
  <verify>Run `pytest tests/test_verification_api.py -v` — all existing tests pass, three new tests pass. No import errors.</verify>
  <done>verification.py calls supabase_admin.auth.admin.update_user_by_id() when verification succeeds. Supabase failure is caught and logged without breaking the endpoint. Three new tests cover success, failure, and no-client scenarios.</done>
</task>

<task type="auto">
  <name>Task 2: Add session refresh in ProfilePage after verification upload</name>
  <files>frontend-public/src/pages/ProfilePage.tsx</files>
  <action>
In `frontend-public/src/pages/ProfilePage.tsx`, function `handleUpload()`:

1. After the existing `await supabase.auth.updateUser({ data: { residence_verified: false, ... } })` call succeeds (around line 142-148), add a comment explaining that the backend OCR endpoint will set `residence_verified: true` via admin API and the session needs to be refreshed to pick up the change.

2. After the `setSuccessMessage(...)` call at the end of the try block in `handleUpload`, add a session refresh:
   ```typescript
   // Refresh session to pick up updated user_metadata after backend verification
   // The backend OCR endpoint sets residence_verified=true via Supabase admin API
   // This refresh ensures the ReportIssuePage gate unlocks without manual page reload
   await supabase.auth.refreshSession();
   ```

3. IMPORTANT: The `handleUpload` function currently sets `residence_verified: false` when uploading the document. This is correct — the document is uploaded first, then OCR verifies it. The session refresh here ensures that IF the user already has a verified document and revisits, or IF the OCR endpoint runs fast enough during the same session, the gate unlocks.

4. Additionally, check if there's a separate flow where the user navigates to ProfilePage AFTER verification. If the `useEffect` on mount reads `user?.user_metadata?.residence_verified`, it will already have the correct value from the last session refresh. No additional mount-time refresh is needed.

Do NOT add a polling mechanism or timer. A single `refreshSession()` call at the end of upload is sufficient. If the OCR is asynchronous (takes time), the user will see the updated status on next page visit when the session naturally refreshes.
  </action>
  <verify>Run `cd frontend-public && npm run build:check` — TypeScript compilation succeeds with no errors. Verify `refreshSession` appears in the handleUpload function.</verify>
  <done>ProfilePage.tsx calls `supabase.auth.refreshSession()` after successful document upload. The frontend session will pick up backend-set residence_verified flag without manual page reload.</done>
</task>

</tasks>

<verification>
1. `pytest tests/test_verification_api.py -v` — all tests pass including 3 new ones
2. `cd frontend-public && npm run build:check` — TypeScript compilation clean
3. Grep verification: `grep -n "update_user_by_id" src/api/v1/verification.py` returns a match
4. Grep verification: `grep -n "refreshSession" frontend-public/src/pages/ProfilePage.tsx` returns a match
</verification>

<success_criteria>
- OCR verification endpoint syncs residence_verified=true to Supabase user_metadata after successful DB commit
- Supabase sync failure does not break the verification endpoint (returns 200 regardless)
- Missing Supabase admin client (dev mode) logs a warning but does not fail
- Frontend ProfilePage refreshes session after upload to pick up updated metadata
- All existing tests pass, 3 new tests added and passing
</success_criteria>

<output>
After completion, create `.planning/phases/09-ocr-supabase-bridge-ward-filtering/09-01-SUMMARY.md`
</output>
