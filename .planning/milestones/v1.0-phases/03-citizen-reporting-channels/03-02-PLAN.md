---
phase: 03-citizen-reporting-channels
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - src/api/v1/whatsapp.py
  - src/services/whatsapp_service.py
  - src/schemas/whatsapp.py
  - src/main.py
autonomous: true
user_setup:
  - service: twilio
    why: "WhatsApp Business API for citizen messaging"
    env_vars:
      - name: TWILIO_ACCOUNT_SID
        source: "Twilio Console -> Dashboard -> Account SID"
      - name: TWILIO_AUTH_TOKEN
        source: "Twilio Console -> Dashboard -> Auth Token"
      - name: TWILIO_WHATSAPP_NUMBER
        source: "Twilio Console -> Messaging -> WhatsApp Senders (format: whatsapp:+14155238886)"
    dashboard_config:
      - task: "Set WhatsApp webhook URL to https://<domain>/api/v1/whatsapp/webhook"
        location: "Twilio Console -> Messaging -> WhatsApp Sandbox -> Webhook URL"
      - task: "Enable WhatsApp Business Profile"
        location: "Twilio Console -> Messaging -> WhatsApp Senders"

must_haves:
  truths:
    - "Twilio webhook validates X-Twilio-Signature header to prevent request forgery"
    - "Incoming WhatsApp messages are processed through the existing intake pipeline (guardrails -> flow -> crew)"
    - "Media attachments from WhatsApp are downloaded from Twilio and uploaded to S3 within webhook handler"
    - "WhatsApp user is identified by phone number and mapped to existing user account"
    - "System sends WhatsApp reply with tracking number after ticket creation"
    - "Tenant context is resolved from user's municipality (not X-Tenant-ID header)"
  artifacts:
    - path: "src/api/v1/whatsapp.py"
      provides: "Twilio webhook endpoint with signature validation"
      contains: "validate_twilio_signature"
    - path: "src/services/whatsapp_service.py"
      provides: "WhatsApp message processing and Twilio client"
      contains: "class WhatsAppService"
    - path: "src/schemas/whatsapp.py"
      provides: "Webhook payload schemas"
      contains: "WhatsAppWebhookPayload"
  key_links:
    - from: "src/api/v1/whatsapp.py"
      to: "src/services/whatsapp_service.py"
      via: "WhatsAppService.process_incoming_message()"
      pattern: "whatsapp_service\\.process"
    - from: "src/services/whatsapp_service.py"
      to: "src/services/storage_service.py"
      via: "StorageService.download_and_upload_media()"
      pattern: "storage_service\\.download"
    - from: "src/services/whatsapp_service.py"
      to: "src/api/v1/messages.py"
      via: "Reuses IntakeFlow pipeline from Phase 2"
      pattern: "IntakeFlow"
---

<objective>
Implement Twilio WhatsApp Business API webhook integration so citizens can report issues and upload photos via WhatsApp.

Purpose: WhatsApp is the primary citizen channel (highest SA penetration). This connects Twilio webhooks to the existing AI intake pipeline built in Phase 2, adding media handling and phone-based user identification.

Output: WhatsApp webhook endpoint, WhatsAppService, phone-to-user mapping, media download/upload pipeline
</objective>

<execution_context>
@C:/Users/Bantu/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Bantu/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-citizen-reporting-channels/03-RESEARCH.md
@.planning/phases/03-citizen-reporting-channels/03-01-SUMMARY.md
@src/api/v1/messages.py
@src/agents/flows/intake_flow.py
@src/agents/flows/state.py
@src/core/config.py
@src/core/conversation.py
@src/guardrails/engine.py
@src/models/user.py
@src/models/media.py
@src/services/storage_service.py
@src/api/deps.py
@src/main.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: WhatsApp Webhook Endpoint with Twilio Signature Validation</name>
  <files>
    src/api/v1/whatsapp.py
    src/schemas/whatsapp.py
    src/main.py
  </files>
  <action>
1. Create `src/schemas/whatsapp.py`:
   - `WhatsAppWebhookPayload(BaseModel)`: Parsed from Twilio form data
     - `From_: str` (aliased from "From" — the sender WhatsApp number, format "whatsapp:+27...")
     - `Body: str | None = None` (text message content)
     - `NumMedia: int = 0` (number of media attachments)
     - `MessageSid: str` (unique Twilio message ID)
     - `AccountSid: str` (Twilio account SID)
     - Media fields: `MediaUrl0: str | None`, `MediaContentType0: str | None`, `MediaUrl1: str | None`, `MediaContentType1: str | None` (Twilio sends max 10 media per message, support at least 2)
   - `WhatsAppMediaItem(BaseModel)`: url (str), content_type (str)
   - `WhatsAppResponse(BaseModel)`: message_sid (str | None), status (str), error (str | None)

2. Create `src/api/v1/whatsapp.py`:
   - Import RequestValidator from twilio.request_validator
   - Import TwiML MessagingResponse from twilio.twiml.messaging_response

   **Signature validation dependency:**
   ```python
   async def validate_twilio_request(request: Request) -> dict:
       """Validate Twilio webhook signature and parse form data."""
       # Read form data
       form = await request.form()
       form_dict = dict(form)

       # Get signature header
       signature = request.headers.get("X-Twilio-Signature", "")

       # Skip validation in development/testing if no auth token configured
       if not settings.TWILIO_AUTH_TOKEN:
           return form_dict

       # Validate signature
       validator = RequestValidator(settings.TWILIO_AUTH_TOKEN)
       url = str(request.url)

       if not validator.validate(url, form_dict, signature):
           raise HTTPException(status_code=403, detail="Invalid Twilio signature")

       return form_dict
   ```

   **Webhook endpoint:**
   - `POST /api/v1/whatsapp/webhook` — receives incoming WhatsApp messages
   - Does NOT require JWT auth (Twilio cannot send JWT). Uses Twilio signature validation instead.
   - Parse form data into WhatsAppWebhookPayload
   - Extract phone number from "From" field (strip "whatsapp:" prefix)
   - Look up User by phone number in database (need synchronous DB query or use async)
   - If user not found: reply with "Please register at [web portal URL] first" via TwiML
   - If user found: set tenant context from user's tenant_id
   - Extract media URLs if NumMedia > 0
   - Call WhatsAppService.process_incoming_message() with parsed data
   - Return TwiML response (XML) with reply message
   - Content-Type response must be "application/xml" (Twilio expects TwiML)

   **Status callback endpoint (optional but useful):**
   - `POST /api/v1/whatsapp/status` — receives message delivery status updates
   - Log status (sent, delivered, read, failed) for debugging
   - Return 200 OK

   **Router registration:** Add to src/main.py — `app.include_router(whatsapp.router, prefix="/api/v1")`
   - IMPORTANT: WhatsApp webhook must be EXCLUDED from tenant middleware (it resolves tenant from user lookup, not header)
   - Add "/api/v1/whatsapp" to tenant middleware exempt paths
  </action>
  <verify>
    python -c "from src.api.v1.whatsapp import router; from src.main import app; routes = [str(r.path) for r in app.routes]; assert '/api/v1/whatsapp/webhook' in routes, f'Missing webhook route. Routes: {routes}'; print('WhatsApp routes registered OK')"
  </verify>
  <done>
    WhatsApp webhook endpoint registered at /api/v1/whatsapp/webhook. Twilio signature validation implemented. TwiML response format correct. Webhook exempt from tenant middleware. Status callback endpoint available.
  </done>
</task>

<task type="auto">
  <name>Task 2: WhatsApp Service with Media Handling and Phone-to-User Mapping</name>
  <files>
    src/services/whatsapp_service.py
  </files>
  <action>
1. Create `src/services/whatsapp_service.py` — WhatsAppService class:

   **Constructor:**
   - `__init__(self, redis_url, storage_service)`: Accept Redis URL for conversation management and StorageService instance for media handling. Create Twilio Client if TWILIO_ACCOUNT_SID is configured.

   **Phone-to-user lookup:**
   - `async lookup_user_by_phone(self, phone_number: str, db: AsyncSession) -> User | None`:
     - Normalize phone: strip "whatsapp:" prefix, handle +27 vs 0 prefix (South African numbers)
     - Query User table by phone field
     - Return User if found and is_active, None otherwise
     - NOTE: This query needs tenant context disabled (searching across tenants by phone). Use a raw query or bypass tenant filter. One approach: query with `select(User).where(User.phone == normalized_phone, User.is_active == True)` and disable the tenant filter for this specific query by using a separate session or raw SQL. Document this security decision — phone lookup is cross-tenant by necessity.

   **Process incoming message:**
   - `async process_incoming_message(self, user: User, message_body: str | None, media_items: list[dict], session_id: str | None) -> dict`:
     - If message_body is None and no media: return error response
     - Step 1: Handle media attachments — for each media item, call storage_service.download_and_upload_media() to fetch from Twilio and save to S3. Collect file_ids.
     - Step 2: Run through guardrails (process_input)
     - Step 3: Get or create conversation session via ConversationManager
     - Step 4: Create IntakeState and IntakeFlow, set message (use message_body or "Photo uploaded" if only media)
     - Step 5: Run flow.kickoff()
     - Step 6: If ticket created and media file_ids exist, create MediaAttachment records linking to ticket
     - Step 7: Sanitize output (process_output)
     - Step 8: Save conversation turns
     - Step 9: Return dict with response text, tracking_number, is_complete
     - IMPORTANT: This reuses the SAME pipeline as the messages.py endpoint (Phase 2). The flow logic is identical — only the transport layer differs (WhatsApp vs HTTP API).

   **Send reply message:**
   - `async send_whatsapp_message(self, to_number: str, message: str) -> str | None`:
     - Use Twilio client to send WhatsApp message
     - `client.messages.create(body=message, from_=settings.TWILIO_WHATSAPP_NUMBER, to=f"whatsapp:{to_number}")`
     - Return message_sid on success, None on failure
     - If Twilio client not configured, log warning and return None (dev mode)

   **Error handling:**
   - Wrap all Twilio API calls in try/except
   - Log errors but don't crash webhook (return graceful error message to user)
   - If media download fails, continue processing text message and log media error
  </action>
  <verify>
    python -c "from src.services.whatsapp_service import WhatsAppService; print('WhatsAppService importable OK')"
  </verify>
  <done>
    WhatsAppService processes incoming WhatsApp messages through Phase 2 intake pipeline. Phone-to-user lookup resolves tenant context. Media downloaded from Twilio and uploaded to S3. TwiML responses sent back. Graceful error handling for all Twilio operations.
  </done>
</task>

</tasks>

<verification>
- WhatsApp webhook endpoint accepts POST with form data
- Twilio signature validation rejects invalid signatures (returns 403)
- Valid webhook triggers message processing pipeline
- Media URLs downloaded and stored in S3
- User looked up by phone number
- TwiML response returned with agent reply
- Status callback logs delivery status
- No regression in existing message API tests
- `pytest tests/ -x` passes
</verification>

<success_criteria>
- Citizens can send WhatsApp messages that are processed through AI pipeline
- Photos sent via WhatsApp are saved to S3 and linked to tickets
- Unregistered users receive registration prompt
- Twilio signature validation prevents forgery
- Tracking number returned in WhatsApp reply
</success_criteria>

<output>
After completion, create `.planning/phases/03-citizen-reporting-channels/03-02-SUMMARY.md`
</output>
