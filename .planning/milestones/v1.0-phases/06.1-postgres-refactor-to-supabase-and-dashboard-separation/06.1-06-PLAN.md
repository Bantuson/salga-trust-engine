---
phase: 06.1-postgres-refactor-to-supabase-and-dashboard-separation
plan: 06
type: execute
wave: 4
depends_on: ["06.1-04"]
files_modified:
  - frontend-public/package.json
  - frontend-public/vite.config.ts
  - frontend-public/tsconfig.json
  - frontend-public/tsconfig.app.json
  - frontend-public/tsconfig.node.json
  - frontend-public/index.html
  - frontend-public/src/main.tsx
  - frontend-public/src/App.tsx
  - frontend-public/src/lib/supabase.ts
  - frontend-public/src/hooks/usePublicStats.ts
  - frontend-public/src/components/MunicipalitySelector.tsx
  - frontend-public/src/components/ResponseTimeChart.tsx
  - frontend-public/src/components/ResolutionRateChart.tsx
  - frontend-public/src/components/HeatmapViewer.tsx
  - frontend-public/src/pages/PublicDashboardPage.tsx
  - frontend-public/src/types/public.ts
autonomous: true

must_haves:
  truths:
    - "Public dashboard is an independent Vite app in frontend-public/"
    - "Public dashboard has its own package.json (not shared with municipal dashboard)"
    - "Public dashboard uses Supabase JS client with anon key (no authentication required)"
    - "Public dashboard queries Supabase PostgreSQL directly via RLS views (no FastAPI dependency)"
    - "Public dashboard shows response times, resolution rates, and geographic heatmap"
    - "GBV/sensitive data is NEVER visible on public dashboard (enforced by RLS views)"
    - "Public dashboard has municipality selector for filtering"
    - "Public dashboard is fully serverless on Vercel (zero backend dependency; Supabase hosting unavailable for static sites)"
  artifacts:
    - path: "frontend-public/package.json"
      provides: "Independent package manifest with Supabase JS client and Leaflet"
      contains: "@supabase/supabase-js"
    - path: "frontend-public/src/lib/supabase.ts"
      provides: "Supabase client with anon key, no auth persistence"
      contains: "persistSession: false"
    - path: "frontend-public/src/hooks/usePublicStats.ts"
      provides: "Data hooks querying Supabase views directly"
      contains: "supabase.from"
    - path: "frontend-public/src/pages/PublicDashboardPage.tsx"
      provides: "Main public dashboard with all visualizations"
      contains: "PublicDashboardPage"
  key_links:
    - from: "frontend-public/src/hooks/usePublicStats.ts"
      to: "frontend-public/src/lib/supabase.ts"
      via: "supabase.from('public_ticket_stats') for direct RLS queries"
      pattern: "supabase\\.from"
    - from: "frontend-public/src/components/HeatmapViewer.tsx"
      to: "frontend-public/src/hooks/usePublicStats.ts"
      via: "useHeatmapData hook for geographic visualization"
      pattern: "useHeatmapData"
---

<objective>
Create the public transparency dashboard as an independent Vite React app in frontend-public/. This dashboard queries Supabase PostgreSQL directly using the anon key via RLS-protected views - zero FastAPI dependency. Migrate public dashboard components from frontend/ and replace fetch() API calls with Supabase JS client queries.

Purpose: Per locked decision, the public dashboard is fully serverless: React + Supabase JS client + PostgreSQL via RLS. No FastAPI intermediary. This enables independent deployment and scaling. The anon key + RLS views ensure only aggregated, non-sensitive data is accessible.

**Hosting deviation:** The original decision specified "Supabase hosting" for the public dashboard, but research confirmed Supabase does NOT offer static site hosting. Both dashboards deploy to Vercel instead. The serverless data architecture is unchanged — only the hosting platform differs.

Output: Complete frontend-public/ app with municipality selector, response time charts, resolution rate charts, geographic heatmap, all powered by Supabase direct queries. Deployed to Vercel (not Supabase hosting).
</objective>

<execution_context>
@C:/Users/Bantu/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Bantu/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@.planning/phases/06.1-postgres-refactor-to-supabase-and-dashboard-separation/06.1-CONTEXT.md
@.planning/phases/06.1-postgres-refactor-to-supabase-and-dashboard-separation/06.1-RESEARCH.md
@.planning/phases/06.1-postgres-refactor-to-supabase-and-dashboard-separation/06.1-04-SUMMARY.md
@frontend/src/types/public.ts
@frontend/src/services/publicApi.ts
@frontend/src/components/public/MunicipalitySelector.tsx
@frontend/src/components/public/ResponseTimeChart.tsx
@frontend/src/components/public/ResolutionRateChart.tsx
@frontend/src/components/public/HeatmapViewer.tsx
@frontend/src/pages/PublicDashboardPage.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Scaffold frontend-public/ Vite app with Supabase anon client</name>
  <files>
    frontend-public/package.json
    frontend-public/vite.config.ts
    frontend-public/tsconfig.json
    frontend-public/tsconfig.app.json
    frontend-public/tsconfig.node.json
    frontend-public/index.html
    frontend-public/.env.example
    frontend-public/src/main.tsx
    frontend-public/src/App.tsx
    frontend-public/src/App.css
    frontend-public/src/lib/supabase.ts
    frontend-public/src/types/public.ts
    frontend-public/src/hooks/usePublicStats.ts
  </files>
  <action>
    **Step 1: Create frontend-public/ project structure**
    Initialize as a new Vite React TypeScript project:
    - Copy vite.config.ts, tsconfig files from frontend/ as starting point
    - Create package.json with:
      - name: "frontend-public"
      - Same React/Vite/TypeScript versions as frontend/
      - Add: @supabase/supabase-js (latest 2.x)
      - Keep: recharts (for charts), leaflet, react-leaflet, react-leaflet-heatmap-layer-v3, @types/leaflet, leaflet.heat
      - Remove: @tanstack/react-table, axios, react-dropzone, zustand, date-fns (not needed for public dashboard)
    - Create .env.example with VITE_SUPABASE_URL, VITE_SUPABASE_ANON_KEY only (no API URL — fully serverless)

    **Step 2: Create src/lib/supabase.ts (anon client)**
    ```typescript
    import { createClient } from '@supabase/supabase-js';

    export const supabase = createClient(
      import.meta.env.VITE_SUPABASE_URL,
      import.meta.env.VITE_SUPABASE_ANON_KEY,
      {
        auth: {
          persistSession: false,  // No auth needed for public dashboard
          autoRefreshToken: false,
        }
      }
    );
    ```
    CRITICAL: persistSession: false and autoRefreshToken: false — public dashboard has NO authentication.

    **Step 3: Create src/types/public.ts**
    Copy from frontend/src/types/public.ts and adapt:
    - Same types: MunicipalityInfo, ResponseTimeData, ResolutionRateData, HeatmapPoint
    - Add Supabase-specific return types if needed

    **Step 4: Create src/hooks/usePublicStats.ts**
    Replace the fetch()-based publicApi.ts with Supabase JS client queries:
    ```typescript
    import { supabase } from '../lib/supabase';

    export function useMunicipalities() {
      // Query public_municipalities view directly
      const fetchMunicipalities = async () => {
        const { data, error } = await supabase
          .from('public_municipalities')
          .select('*');
        if (error) throw error;
        return data;
      };
      // ... state management
    }

    export function useResponseTimes(municipalityId?: string) {
      const fetchResponseTimes = async () => {
        let query = supabase
          .from('public_ticket_stats')
          .select('municipality_id, municipality_name, response_hours')
          .not('response_hours', 'is', null);

        if (municipalityId) {
          query = query.eq('municipality_id', municipalityId);
        }

        const { data, error } = await query;
        if (error) throw error;

        // Aggregate in JS: group by municipality, calculate averages
        const grouped = groupByMunicipality(data);
        return Object.values(grouped).map(g => ({
          municipality_id: g.municipality_id,
          municipality_name: g.municipality_name,
          avg_response_hours: average(g.response_hours),
          ticket_count: g.count,
        }));
      };
    }

    export function useResolutionRates(municipalityId?: string, months = 6) {
      // Similar: query public_ticket_stats, calculate resolution rates client-side
    }

    export function useHeatmapData(municipalityId?: string) {
      const fetchHeatmap = async () => {
        let query = supabase
          .from('public_heatmap')
          .select('lat, lng, intensity');

        if (municipalityId) {
          query = query.eq('municipality_id', municipalityId);
        }

        const { data, error } = await query;
        if (error) throw error;
        return data || [];
      };
    }

    export function useSystemSummary() {
      // Aggregate from public_ticket_stats view
    }
    ```
    IMPORTANT: These hooks query Supabase views directly. The RLS views (public_ticket_stats, public_municipalities, public_heatmap) from Plan 04 enforce GBV exclusion at the database level. No additional filtering needed in the frontend.

    **Step 5: Create src/App.tsx**
    Simple single-page app (no routing needed):
    ```typescript
    function App() {
      return (
        <div className="App">
          <header>SALGA Trust Engine — Public Transparency Dashboard</header>
          <PublicDashboardPage />
        </div>
      );
    }
    ```
    No navigation, no login — this is a public-facing single page.
  </action>
  <verify>
    - `cd frontend-public && npm install` succeeds
    - `cd frontend-public && npx tsc --noEmit` succeeds
    - No reference to "axios" or "FastAPI" or "api.ts" in frontend-public/
    - supabase.ts has persistSession: false
  </verify>
  <done>
    frontend-public/ scaffolded with Supabase anon client, public stats hooks querying RLS views directly, TypeScript types, and app shell. Zero FastAPI dependency. Build compiles.
  </done>
</task>

<task type="auto">
  <name>Task 2: Migrate public dashboard components with Supabase data source</name>
  <files>
    frontend-public/src/pages/PublicDashboardPage.tsx
    frontend-public/src/components/MunicipalitySelector.tsx
    frontend-public/src/components/ResponseTimeChart.tsx
    frontend-public/src/components/ResolutionRateChart.tsx
    frontend-public/src/components/HeatmapViewer.tsx
    frontend-public/src/react-leaflet-heatmap-layer-v3.d.ts
  </files>
  <action>
    **Step 1: Copy and adapt public dashboard components from frontend/**
    Copy from frontend/src/components/public/ to frontend-public/src/components/:
    - MunicipalitySelector.tsx — adapt to use useMunicipalities() hook from usePublicStats
    - ResponseTimeChart.tsx — adapt to use useResponseTimes() hook
    - ResolutionRateChart.tsx — adapt to use useResolutionRates() hook
    - HeatmapViewer.tsx — adapt to use useHeatmapData() hook

    Key changes for each component:
    - Replace: `fetchPublicResponseTimes(municipalityId)` (fetch to FastAPI)
    - With: `useResponseTimes(municipalityId)` (Supabase JS direct query)
    - Keep: All Recharts visualizations (bar charts, pie charts)
    - Keep: Leaflet heatmap with OpenStreetMap tiles
    - Keep: Color-coded metric thresholds (green/amber/red)
    - Keep: Privacy notice footer about GBV exclusion

    **Step 2: Migrate PublicDashboardPage.tsx**
    Copy from frontend/src/pages/PublicDashboardPage.tsx:
    - Replace all publicApi.* calls with Supabase hooks
    - Keep municipality selector at top
    - Keep chart layout (response times, resolution rates, heatmap)
    - Keep system summary statistics
    - Add: "Powered by Supabase" footer note (optional)
    - Keep: Privacy notice: "GBV and sensitive reports are excluded from public statistics"

    **Step 3: Copy Leaflet type declarations**
    Copy frontend/src/react-leaflet-heatmap-layer-v3.d.ts to frontend-public/src/

    **Step 4: Copy CSS**
    Copy relevant CSS from frontend/src/App.css to frontend-public/src/App.css
    Strip out any dashboard-specific styles (nav, ticket table, etc.)
    Keep: public dashboard layout, chart containers, municipality selector, heatmap container

    **Step 5: Verify no FastAPI references**
    Grep entire frontend-public/ to ensure zero references to:
    - `localhost:8000` or any API URL
    - `axios`
    - `Authorization` header
    - `Bearer` token
    - `api.ts` (the FastAPI service file)
    The public dashboard must be fully independent of the backend.
  </action>
  <verify>
    - `cd frontend-public && npm run build` succeeds with no errors
    - `cd frontend-public && npx tsc --noEmit` succeeds
    - `grep -r "axios" frontend-public/src/` returns no matches
    - `grep -r "localhost:8000" frontend-public/src/` returns no matches
    - `grep -r "Bearer" frontend-public/src/` returns no matches
    - `grep -r "Authorization" frontend-public/src/` returns no matches
  </verify>
  <done>
    Public dashboard components migrated with Supabase JS data source. All visualizations work (response times, resolution rates, heatmap). Zero FastAPI dependency. GBV exclusion enforced by RLS views. Build succeeds.
  </done>
</task>

</tasks>

<verification>
1. `cd frontend-public && npm run build` succeeds
2. No axios, no API URL, no auth headers in frontend-public/
3. Supabase client uses anon key with persistSession: false
4. All hooks query Supabase views (public_ticket_stats, public_municipalities, public_heatmap)
5. Heatmap renders with Leaflet + OpenStreetMap tiles
6. Municipality selector filters all charts
7. Privacy notice about GBV exclusion visible
8. TypeScript compiles with zero errors
</verification>

<success_criteria>
- Independent Vite app in frontend-public/ with own package.json
- Supabase anon client (no authentication)
- All public pages ported: response times, resolution rates, heatmap, municipality selector
- Data from Supabase RLS views (not FastAPI)
- GBV data completely invisible (enforced at DB level)
- Zero backend dependency
- Build succeeds
</success_criteria>

<output>
After completion, create `.planning/phases/06.1-postgres-refactor-to-supabase-and-dashboard-separation/06.1-06-SUMMARY.md`
</output>
