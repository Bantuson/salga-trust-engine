# Phase 06.1: Postgres Refactor to Supabase and Dashboard Separation - Research

**Researched:** 2026-02-10
**Domain:** Supabase Cloud PostgreSQL migration, Multi-tenant SaaS architecture, React dashboard separation
**Confidence:** MEDIUM-HIGH

## Summary

Phase 06.1 migrates the SALGA Trust Engine from self-hosted PostgreSQL + custom JWT auth + AWS S3 + Redis Pub/Sub to Supabase Cloud — a managed PostgreSQL platform with integrated authentication, storage, and realtime capabilities. The migration maintains the existing FastAPI backend for the municipal dashboard while creating a serverless public dashboard that queries Supabase directly via RLS policies.

**Critical insight:** This is an infrastructure migration, not a rewrite. The existing multi-tenant architecture, RLS policies, and business logic remain — Supabase provides the database, auth, storage, and realtime infrastructure, while FastAPI continues to orchestrate complex operations (CrewAI agents, Celery tasks, WhatsApp webhooks).

**Primary recommendation:** Migrate incrementally — auth first (enables testing all other components with real users), then database (migrate schemas + RLS), then storage (S3→Supabase), then realtime (Redis→Supabase Realtime), finally dashboard separation (public serverless, municipal with FastAPI).

<user_constraints>
## User Constraints (from CONTEXT.md)

### Locked Decisions

**Supabase Auth Strategy:**
- Migrate fully to Supabase Auth — replace custom JWT + Argon2 system with Supabase's built-in auth
- Implement full OWASP-compliant authentication and authorization via Supabase Auth
- Citizen web portal supports BOTH phone OTP and email + password registration
- WhatsApp users identified by phone number automatically (existing Twilio integration links to Supabase Auth user)
- RBAC roles (CITIZEN, MANAGER, ADMIN, SAPS_LIAISON, WARD_COUNCILLOR, FIELD_WORKER) — Claude decides best pattern based on Supabase RBAC research (custom claims vs roles table)
- Municipal staff auth goes through same Supabase Auth system as citizens (unified auth, role-differentiated access)

**Supabase Feature Adoption:**
- Database: Supabase Cloud hosted PostgreSQL (includes PostGIS extension support)
- Auth: Full migration to Supabase Auth (replacing custom JWT + Argon2)
- Storage: Migrate from AWS S3 to Supabase Storage (media uploads, evidence photos, documents). Must maintain GBV encryption requirements.
- Realtime: Migrate from Redis Pub/Sub + SSE to Supabase Realtime for dashboard live updates (WebSocket-based)
- Background Jobs: Keep Celery + Redis for SLA monitoring, escalation, and WhatsApp notifications (NOT moving to Edge Functions)
- Hosting: Supabase Cloud (hosted) — not self-hosted

**Dashboard Deployment Model:**
- Two separate Vite apps — `frontend-public/` and `frontend-dashboard/` as independent projects with separate package.json
- Municipal dashboard deployed on Vercel (calls FastAPI backend for all data)
- Public dashboard deployed on Supabase hosting (uses Supabase JS client directly with anon key — no FastAPI dependency)
- Municipal dashboard data flow: React → FastAPI → Supabase PostgreSQL (backend controls all business logic)
- Public dashboard data flow: React → Supabase JS client → PostgreSQL via RLS (serverless, no backend needed)

### Claude's Discretion

- RBAC implementation pattern (Supabase custom claims vs separate roles table) — pick what's best for the 6-role model
- RLS policy migration approach (current SET LOCAL app.current_tenant → Supabase auth.uid() or auth.jwt() patterns)
- GBV firewall adaptation for Supabase Storage (bucket-level RLS for sensitive media)
- How to handle the public dashboard's GBV data exclusion via RLS policies alone (without FastAPI intermediary)
- Alembic migration strategy for Supabase-hosted PostgreSQL
- Supabase Realtime channel design for ticket status updates

### Specific Ideas

- User wants "better auth with full authentication, authorization, OWASP security" — Supabase Auth should be configured with security best practices (rate limiting, email verification, strong password policies)
- Public dashboard should be fully serverless (Supabase JS client + Supabase hosting) — zero backend dependency
- Municipal dashboard keeps FastAPI as the data layer — Supabase is infrastructure, not a replacement for business logic
- Celery stays because SLA monitoring and escalation have complex time-based logic that doesn't fit serverless patterns

### Deferred Ideas (OUT OF SCOPE)

None — discussion stayed within phase scope
</user_constraints>

## Standard Stack

### Core Database & Auth

| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| Supabase Cloud | Latest | Managed PostgreSQL + Auth + Storage + Realtime | Industry-standard BaaS, used by 1M+ developers, eliminates self-hosting complexity |
| supabase-py | 2.27.3+ | Python client for Supabase | Official Python SDK with async support (acreate_client) |
| psycopg[binary] | 3.2.3 (keep) | PostgreSQL async adapter | Remains for direct connection pooling in FastAPI |
| SQLAlchemy | 2.0.36 (keep) | ORM for backend logic | Maintains existing models, works seamlessly with Supabase-hosted PostgreSQL |
| Alembic | 1.14.0 (keep) | Schema migrations | Compatible with Supabase PostgreSQL, manages DDL changes |

**Key insight:** Supabase is PostgreSQL, not a proprietary database. Existing SQLAlchemy models, Alembic migrations, and psycopg connections work unchanged. Supabase adds auth, storage, and realtime as managed layers on top of standard Postgres.

### Frontend & Deployment

| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| @supabase/supabase-js | 2.x | Browser client for Supabase | Official TypeScript SDK, handles auth state + RLS-aware queries + realtime subscriptions |
| Vite | 7.3.1 (keep) | React build tool | Fast dev server, already in use |
| React | 19.2.0 (keep) | UI framework | Current version, no changes |
| Vercel | Latest | Municipal dashboard hosting | Zero-config React + FastAPI deployment, auto-HTTPS, edge network |
| Supabase Hosting | N/A | Public dashboard hosting | Simple static site hosting for public transparency dashboard |

**Note on Supabase Hosting:** As of 2026-02-10 research, Supabase does NOT offer native static site hosting. The public dashboard must be deployed to an alternative platform (Vercel, Netlify, or GitHub Pages). Decision: Deploy both dashboards to Vercel for consistency.

### Supporting Libraries

| Library | Version | Purpose | When to Use |
|---------|---------|---------|-------------|
| zod-validation-error | Latest | Supabase error parsing | Convert Supabase/Postgres errors to user-friendly messages |
| jose (or PyJWT) | Latest | JWT verification (backend) | Verify Supabase JWTs in FastAPI for custom auth middleware |
| cryptography | 42.0.0 (keep) | Field-level encryption | GBV data encryption (Fernet) for sensitive fields beyond Supabase's at-rest encryption |

### Alternatives Considered

| Instead of | Could Use | Tradeoff |
|------------|-----------|----------|
| Supabase Storage | Keep AWS S3 | S3 cheaper at scale (>1TB), but Supabase Storage integrates RLS policies directly, eliminating presigned URL logic |
| Supabase Realtime | Keep Redis Pub/Sub + SSE | Redis more flexible for general messaging, but Supabase Realtime ties updates to database changes automatically |
| Vercel (both dashboards) | Supabase Hosting (public only) | Not viable — Supabase hosting doesn't exist yet. Vercel offers unified platform for both React apps. |
| Celery | Supabase Edge Functions | Edge Functions can't handle 30+ minute SLA monitoring loops or Twilio webhook retries. Celery required for long-running jobs. |

**Installation:**

Backend Python dependencies:
```bash
pip install supabase==2.27.3 pyjwt==2.10.1 python-jose[cryptography]
```

Frontend JavaScript dependencies:
```bash
npm install @supabase/supabase-js zod-validation-error
```

## Architecture Patterns

### Recommended Project Structure

```
salga-trust-engine/
├── src/                          # FastAPI backend (unchanged)
│   ├── core/
│   │   ├── database.py           # ADD: Supabase connection pool
│   │   ├── supabase.py           # NEW: Supabase admin client
│   │   └── security.py           # MIGRATE: JWT verification to Supabase tokens
│   ├── models/                   # SQLAlchemy models (unchanged)
│   ├── api/v1/
│   │   └── auth.py               # MIGRATE: Supabase Auth integration
│   └── services/
│       └── storage_service.py    # MIGRATE: S3 → Supabase Storage
│
├── frontend-dashboard/           # NEW: Municipal operations dashboard
│   ├── src/
│   │   ├── lib/supabase.ts       # Supabase client (service_role for admin ops)
│   │   ├── hooks/useRealtimeTickets.ts  # Supabase Realtime subscription
│   │   └── api/dashboard.ts      # Calls FastAPI backend
│   └── package.json
│
├── frontend-public/              # NEW: Public transparency dashboard
│   ├── src/
│   │   ├── lib/supabase.ts       # Supabase client (anon key)
│   │   ├── hooks/usePublicStats.ts  # Direct RLS queries
│   │   └── components/HeatmapViewer.tsx
│   └── package.json
│
└── alembic/                      # Schema migrations (target Supabase DB)
```

### Pattern 1: Supabase Auth Integration with FastAPI

**What:** Replace custom JWT middleware with Supabase JWT verification. FastAPI becomes a thin layer for business logic, while Supabase Auth handles session management, token refresh, and OAuth flows.

**When to use:** All authenticated endpoints in FastAPI. Municipal dashboard calls FastAPI endpoints; public dashboard bypasses FastAPI entirely.

**Example:**
```python
# src/core/supabase.py
from supabase import create_client, Client
from src.core.config import settings

# Admin client (service_role key) - bypasses RLS
supabase_admin: Client = create_client(
    settings.SUPABASE_URL,
    settings.SUPABASE_SERVICE_ROLE_KEY
)

# src/api/deps.py (MIGRATED)
from jose import jwt, JWTError
from fastapi import Depends, HTTPException, status
from fastapi.security import HTTPBearer

security = HTTPBearer()

async def get_current_user(token: str = Depends(security)) -> User:
    """Verify Supabase JWT and extract user claims."""
    try:
        # Verify JWT using Supabase's public key
        payload = jwt.decode(
            token.credentials,
            settings.SUPABASE_JWT_SECRET,  # Get from Supabase dashboard
            algorithms=["HS256"],
            audience="authenticated",
        )
        user_id = payload.get("sub")
        role = payload.get("user_metadata", {}).get("role")
        tenant_id = payload.get("app_metadata", {}).get("tenant_id")

        # Fetch user from database
        db_user = await fetch_user(user_id)
        set_tenant_context(tenant_id)
        return db_user
    except JWTError:
        raise HTTPException(status_code=401, detail="Invalid token")
```

**Source:** [Supabase Auth with FastAPI example](https://github.com/J0/fastapi-supabase-auth)

### Pattern 2: Multi-Tenant RLS Migration (SET LOCAL → auth.jwt())

**What:** Convert existing RLS policies from `current_setting('app.current_tenant')` to Supabase's `auth.jwt() ->> 'tenant_id'` pattern. Maintain defense-in-depth with application-level tenant filtering.

**When to use:** All tenant-aware tables (users, tickets, reports, teams, etc.)

**Current pattern (to be replaced):**
```sql
-- Existing RLS policy
CREATE POLICY tenant_isolation_users ON users
  USING (tenant_id = current_setting('app.current_tenant', true));
```

**Supabase pattern (recommended):**
```sql
-- Migrated RLS policy using auth.jwt()
CREATE POLICY tenant_isolation_users ON users
  TO authenticated
  USING (
    tenant_id = (auth.jwt() -> 'app_metadata' ->> 'tenant_id')::uuid
  );
```

**Performance optimization:**
```sql
-- Wrap in SELECT for query plan caching (94.97% faster)
CREATE POLICY tenant_isolation_users ON users
  TO authenticated
  USING (
    tenant_id = (SELECT (auth.jwt() -> 'app_metadata' ->> 'tenant_id')::uuid)
  );
```

**Critical:** Index all columns used in RLS policies. Missing indexes are the #1 performance killer.
```sql
CREATE INDEX idx_users_tenant_id ON users(tenant_id);
```

**Sources:**
- [Supabase RLS Performance Best Practices](https://supabase.com/docs/guides/troubleshooting/rls-performance-and-best-practices-Z5Jjwv)
- [Row Level Security Guide](https://supabase.com/docs/guides/database/postgres/row-level-security)

### Pattern 3: RBAC with Custom Claims (6-Role Model)

**What:** Store user roles in `app_metadata` (immutable, server-controlled) and inject into JWT via Custom Access Token Auth Hook. RLS policies query `auth.jwt()` for role-based access.

**Recommended approach:** Hybrid — custom claims for simple checks, roles table for complex permissions.

**Schema:**
```sql
-- User roles enum
CREATE TYPE user_role AS ENUM (
  'CITIZEN', 'MANAGER', 'ADMIN',
  'SAPS_LIAISON', 'WARD_COUNCILLOR', 'FIELD_WORKER'
);

-- Users table (migrated from existing)
ALTER TABLE users ADD COLUMN role user_role NOT NULL DEFAULT 'CITIZEN';

-- Custom Access Token Hook (PL/pgSQL function)
CREATE OR REPLACE FUNCTION public.custom_access_token_hook(event jsonb)
RETURNS jsonb AS $$
DECLARE
  user_role text;
  tenant_id uuid;
BEGIN
  -- Fetch user role and tenant_id
  SELECT role, users.tenant_id INTO user_role, tenant_id
  FROM public.users
  WHERE id = (event->>'user_id')::uuid;

  -- Inject into JWT app_metadata
  event := jsonb_set(event, '{app_metadata,role}', to_jsonb(user_role));
  event := jsonb_set(event, '{app_metadata,tenant_id}', to_jsonb(tenant_id));

  RETURN event;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;
```

**RLS policy using role:**
```sql
CREATE POLICY managers_see_all_tickets ON tickets
  TO authenticated
  USING (
    tenant_id = (auth.jwt() -> 'app_metadata' ->> 'tenant_id')::uuid
    AND (auth.jwt() -> 'app_metadata' ->> 'role') IN ('MANAGER', 'ADMIN')
  );
```

**Ward councillor filtering:**
```sql
CREATE POLICY ward_councillor_own_ward ON tickets
  TO authenticated
  USING (
    tenant_id = (auth.jwt() -> 'app_metadata' ->> 'tenant_id')::uuid
    AND (
      (auth.jwt() -> 'app_metadata' ->> 'role') IN ('MANAGER', 'ADMIN')
      OR (
        (auth.jwt() -> 'app_metadata' ->> 'role') = 'WARD_COUNCILLOR'
        AND ward_id = (auth.jwt() -> 'app_metadata' ->> 'ward_id')::uuid
      )
    )
  );
```

**Sources:**
- [Custom Claims & RBAC Guide](https://supabase.com/docs/guides/database/postgres/custom-claims-and-role-based-access-control-rbac)
- [Custom Access Token Hook](https://supabase.com/docs/guides/auth/auth-hooks/custom-access-token-hook)

### Pattern 4: GBV Data Firewall with Storage RLS

**What:** Separate GBV evidence into private buckets with strict RLS policies. Maintain field-level encryption for sensitive text fields (victim details, incident descriptions).

**Supabase Storage RLS:**
```sql
-- GBV evidence bucket - SAPS liaisons only
CREATE POLICY "SAPS liaisons access GBV evidence"
ON storage.objects
FOR SELECT
TO authenticated
USING (
  bucket_id = 'gbv-evidence'
  AND (auth.jwt() -> 'app_metadata' ->> 'role') = 'SAPS_LIAISON'
  AND (
    -- Check if user has access to this municipality
    (SELECT tenant_id FROM public.users WHERE id = auth.uid())
    = (SELECT tenant_id FROM public.tickets WHERE id = (storage.foldername(name))[1]::uuid)
  )
);

-- Upload policy - only agents/managers can upload GBV evidence
CREATE POLICY "Authorized staff upload GBV evidence"
ON storage.objects
FOR INSERT
TO authenticated
WITH CHECK (
  bucket_id = 'gbv-evidence'
  AND (auth.jwt() -> 'app_metadata' ->> 'role') IN ('MANAGER', 'ADMIN', 'SAPS_LIAISON')
);
```

**Field-level encryption (keep existing Fernet system):**
```python
# src/models/ticket.py (unchanged)
from src.core.encryption import EncryptedString

class Ticket(TenantAwareModel):
    # ... other fields
    description = mapped_column(EncryptedString(2000), nullable=True)  # GBV incidents
    victim_details = mapped_column(EncryptedString(2000), nullable=True)  # PII
```

**Critical:** Supabase Storage encrypts at rest (AES-256), but field-level encryption provides defense-in-depth for GBV text data. Both layers required.

**Sources:**
- [Storage Access Control](https://supabase.com/docs/guides/storage/security/access-control)
- [Sensitive Data Encryption with Supabase](https://medium.com/@yogeshmulecraft/sensitive-data-encryption-with-supabase-77737d0871e8)

### Pattern 5: Supabase Realtime Migration (Redis Pub/Sub → WebSocket Channels)

**What:** Replace Redis Pub/Sub + SSE with Supabase Realtime channels. Frontend subscribes via WebSocket; backend publishes via PostgreSQL triggers or Supabase API.

**Backend publishing (two approaches):**

**Option A: PostgreSQL triggers (recommended for db-driven events)**
```sql
-- Trigger function to broadcast ticket updates
CREATE OR REPLACE FUNCTION notify_ticket_update()
RETURNS TRIGGER AS $$
BEGIN
  PERFORM pg_notify(
    'ticket_updates',
    json_build_object(
      'type', TG_OP,
      'ticket_id', NEW.id,
      'status', NEW.status,
      'municipality_id', NEW.tenant_id
    )::text
  );
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER ticket_update_notify
AFTER INSERT OR UPDATE ON tickets
FOR EACH ROW EXECUTE FUNCTION notify_ticket_update();
```

**Option B: Supabase Python client (for application-driven events)**
```python
# src/services/event_broadcaster.py (MIGRATED)
from supabase import create_client

async def publish_ticket_update(ticket_id: str, status: str):
    """Publish via Supabase Realtime (Broadcast channel)."""
    supabase_admin.realtime.channel(f"municipality:{municipality_id}").send({
        "type": "broadcast",
        "event": "ticket_updated",
        "payload": {
            "ticket_id": ticket_id,
            "status": status
        }
    })
```

**Frontend subscription (React):**
```typescript
// frontend-dashboard/src/hooks/useRealtimeTickets.ts
import { useEffect } from 'react';
import { supabase } from '../lib/supabase';

export function useRealtimeTickets(municipalityId: string, onUpdate: (ticket: Ticket) => void) {
  useEffect(() => {
    const channel = supabase
      .channel(`municipality:${municipalityId}`)
      .on('broadcast', { event: 'ticket_updated' }, (payload) => {
        onUpdate(payload.payload as Ticket);
      })
      .subscribe();

    return () => {
      supabase.removeChannel(channel);
    };
  }, [municipalityId]);
}
```

**Performance note:** Supabase Realtime uses Phoenix Channels (Elixir/Erlang), which scales to millions of concurrent connections via lightweight processes. No Redis connection pooling needed.

**Sources:**
- [Supabase Realtime Architecture](https://supabase.com/docs/guides/realtime/architecture)
- [Broadcast Feature](https://supabase.com/docs/guides/realtime/broadcast)

### Pattern 6: Public Dashboard with Anon Key + RLS

**What:** Public dashboard queries Supabase directly using the publishable (anon) key. RLS policies enforce GBV data exclusion and aggregated-only access.

**Security model:**
- Publishable key is safe to expose in browser (requires RLS enabled on all tables)
- No user authentication required for public stats
- RLS policies deny access to sensitive fields/rows

**RLS policy for public stats:**
```sql
-- Public access to aggregated ticket counts (no PII)
CREATE POLICY "Public dashboard aggregates"
ON tickets
FOR SELECT
TO anon
USING (
  -- Exclude GBV categories entirely
  category NOT IN ('GBV', 'ABUSE', 'DOMESTIC_VIOLENCE')
  -- Only municipality-level aggregates via views
);

-- Create view for public dashboard (aggregated data only)
CREATE VIEW public.municipality_stats AS
SELECT
  tenant_id as municipality_id,
  COUNT(*) as total_tickets,
  COUNT(*) FILTER (WHERE status = 'RESOLVED') as resolved_count,
  AVG(EXTRACT(EPOCH FROM (resolved_at - created_at))) as avg_resolution_time
FROM tickets
WHERE category NOT IN ('GBV', 'ABUSE', 'DOMESTIC_VIOLENCE')
GROUP BY tenant_id;

-- Grant anon access to view only
GRANT SELECT ON public.municipality_stats TO anon;
```

**Frontend query (no backend needed):**
```typescript
// frontend-public/src/hooks/usePublicStats.ts
import { supabase } from '../lib/supabase';  // Uses anon key

export function usePublicStats(municipalityId: string) {
  return useQuery(['public-stats', municipalityId], async () => {
    const { data, error } = await supabase
      .from('municipality_stats')
      .select('*')
      .eq('municipality_id', municipalityId)
      .single();

    if (error) throw error;
    return data;
  });
}
```

**Critical:** Never expose raw ticket data to anon role. Use views that aggregate data and exclude sensitive categories.

**Sources:**
- [Securing Your Data](https://supabase.com/docs/guides/database/secure-data)
- [Understanding API Keys](https://supabase.com/docs/guides/api/api-keys)

### Anti-Patterns to Avoid

- **Using service_role key in frontend:** Service role bypasses RLS. Only use in backend code. Frontend must use publishable/anon key.
- **No RLS policies on new tables:** Supabase exposes all tables via REST API by default. Always enable RLS and create explicit policies.
- **Calling auth.uid() without SELECT wrapper:** Causes per-row function calls. Always use `(SELECT auth.uid())` for performance.
- **Not indexing RLS policy columns:** Missing indexes on `tenant_id`, `user_id`, etc. cause full table scans. Index all policy columns.
- **Storing secrets in app_metadata:** Use `app_metadata` for roles/tenant_id only. Secrets belong in backend environment variables.
- **Mixing anon and authenticated policies:** Explicitly use `TO authenticated` or `TO anon` in policies to avoid policy collisions.

## Don't Hand-Roll

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| JWT token refresh | Custom refresh token rotation with Redis | Supabase Auth automatic refresh | Handles token expiry, secure httpOnly cookies, PKCE flow for SPAs |
| Phone OTP delivery | Twilio OTP + custom verification logic | Supabase Auth Phone Login | Built-in rate limiting, OTP expiry (60s throttle, 1hr expiry), SMS templates |
| Email verification | Custom token generation + email queue | Supabase Auth Email Verification | SMTP integration, magic links, configurable templates |
| OAuth providers | Custom OAuth2 flows (Google, GitHub) | Supabase Auth Social Login | Pre-configured providers, automatic user creation, token management |
| Password reset flow | Custom token + email + expiry | Supabase Auth Password Reset | Secure token generation, email templates, auto-expiry |
| File upload presigning | Custom S3 presigned URL logic | Supabase Storage SDK | Direct browser uploads, RLS integration, no backend presigning needed |
| Realtime connection pooling | Redis connection pool + Pub/Sub channels | Supabase Realtime | Phoenix Channels handle connection pooling automatically |

**Key insight:** Supabase Auth handles the entire authentication lifecycle (signup, login, token refresh, MFA, OAuth, password reset) with security best practices baked in. Don't reimplement these patterns.

## Common Pitfalls

### Pitfall 1: Forgetting to Enable RLS on New Tables

**What goes wrong:** Supabase exposes all tables via auto-generated REST API. Without RLS enabled, any table is publicly readable/writable using the anon key.

**Why it happens:** Developers focus on creating tables via Alembic migrations but forget PostgreSQL security isn't enabled by default in Supabase.

**How to avoid:**
```sql
-- In every Alembic migration creating tenant-aware tables
def upgrade():
    op.create_table('new_table', ...)

    # ALWAYS enable RLS immediately
    op.execute("ALTER TABLE new_table ENABLE ROW LEVEL SECURITY;")
    op.execute("ALTER TABLE new_table FORCE ROW LEVEL SECURITY;")

    # Create default deny policy
    op.execute("""
        CREATE POLICY tenant_isolation_new_table ON new_table
        TO authenticated
        USING (tenant_id = (auth.jwt() -> 'app_metadata' ->> 'tenant_id')::uuid)
    """)
```

**Warning signs:** Anon key queries return data they shouldn't. Check Supabase dashboard RLS status indicator (shows "No policies" warning).

### Pitfall 2: app_metadata Not Syncing to JWT

**What goes wrong:** Update `users.role` in database, but JWT still contains old role. User retains old permissions until they log out and back in.

**Why it happens:** Supabase Auth caches JWT claims in the access token. Changes to `app_metadata` don't propagate until token refresh (typically 1 hour).

**How to avoid:**
```python
# When changing user role, force token refresh
from supabase import create_client

async def update_user_role(user_id: str, new_role: str):
    # Update database
    await db.execute("UPDATE users SET role = :role WHERE id = :user_id",
                     {"role": new_role, "user_id": user_id})

    # Update Supabase Auth metadata (triggers new JWT on next refresh)
    supabase_admin.auth.admin.update_user_by_id(
        user_id,
        {"app_metadata": {"role": new_role}}
    )

    # Force sign-out to invalidate old tokens
    supabase_admin.auth.admin.sign_out(user_id)
```

**Warning signs:** Users report permissions not updating immediately. Check JWT payload in browser DevTools (Application > Storage > Session).

### Pitfall 3: Missing Indexes on RLS Policy Columns

**What goes wrong:** RLS policies cause full table scans. Queries that should return in 50ms take 5+ seconds with 10K+ rows.

**Why it happens:** Developers migrate RLS policies but forget to create indexes on foreign keys, tenant_id, user_id used in policies.

**How to avoid:**
```sql
-- Every RLS policy column MUST be indexed
CREATE INDEX idx_tickets_tenant_id ON tickets(tenant_id);
CREATE INDEX idx_tickets_user_id ON tickets(created_by);
CREATE INDEX idx_tickets_ward_id ON tickets(ward_id);  -- For ward councillor filtering

-- Composite indexes for multi-column policies
CREATE INDEX idx_tickets_tenant_category ON tickets(tenant_id, category);
```

**Warning signs:** Slow dashboard loads (5+ seconds). Check Supabase Dashboard > Query Performance Insights. Use `EXPLAIN ANALYZE` on slow queries.

**Source:** [RLS Performance Best Practices](https://supabase.com/docs/guides/troubleshooting/rls-performance-and-best-practices-Z5Jjwv)

### Pitfall 4: Supabase Storage Bucket Not Configured for Encryption

**What goes wrong:** GBV evidence photos uploaded without additional encryption. Supabase Storage encrypts at rest (AES-256), but field-level encryption is lost for media files.

**Why it happens:** Developers migrate from S3 (which used `ServerSideEncryption='AES256'`) but don't realize Supabase Storage requires bucket-level configuration.

**How to avoid:**
```sql
-- Create private bucket with strict RLS
INSERT INTO storage.buckets (id, name, public)
VALUES ('gbv-evidence', 'gbv-evidence', false);

-- RLS policy allows only SAPS liaisons
CREATE POLICY "SAPS only GBV access"
ON storage.objects
FOR SELECT TO authenticated
USING (
  bucket_id = 'gbv-evidence'
  AND (auth.jwt() -> 'app_metadata' ->> 'role') = 'SAPS_LIAISON'
);
```

**For client-side encryption (optional):**
```typescript
// Encrypt files before upload using Web Crypto API
async function uploadEncryptedFile(file: File, key: CryptoKey) {
  const arrayBuffer = await file.arrayBuffer();
  const encrypted = await crypto.subtle.encrypt(
    { name: "AES-GCM", iv: crypto.getRandomValues(new Uint8Array(12)) },
    key,
    arrayBuffer
  );

  await supabase.storage.from('gbv-evidence').upload(path, encrypted);
}
```

**Warning signs:** Compliance audit flags missing encryption. Media files accessible via presigned URLs without role check.

### Pitfall 5: Public Dashboard Accidentally Exposes PII

**What goes wrong:** Public dashboard queries ticket details directly using anon key. RLS policy bug exposes victim names, addresses, or GBV incident descriptions.

**Why it happens:** Developers test with authenticated user, then switch to anon key without verifying policy logic. Edge cases in RLS policies allow data leakage.

**How to avoid:**
```sql
-- NEVER grant anon direct access to tickets table
REVOKE SELECT ON tickets FROM anon;

-- Create aggregation view with no PII
CREATE VIEW public.public_ticket_stats AS
SELECT
  tenant_id,
  category,  -- Exclude GBV categories via WHERE
  ward_id,
  status,
  created_at::date as report_date,
  CASE
    WHEN resolved_at IS NOT NULL
    THEN EXTRACT(EPOCH FROM (resolved_at - created_at))
  END as resolution_time_seconds
FROM tickets
WHERE category NOT IN ('GBV', 'ABUSE', 'DOMESTIC_VIOLENCE')
  AND status NOT IN ('DRAFT');  -- Hide incomplete reports

-- Grant anon access to view only
GRANT SELECT ON public.public_ticket_stats TO anon;
```

**Testing:**
```bash
# Test with anon key in browser console
const { data, error } = await supabase
  .from('tickets')  // Should fail with RLS error
  .select('*');

const { data: stats } = await supabase
  .from('public_ticket_stats')  // Should succeed with aggregates only
  .select('*');
```

**Warning signs:** Browser DevTools Network tab shows ticket data in response. Use `psql` to test policies: `SET ROLE anon; SELECT * FROM tickets;` should return zero rows.

## Code Examples

Verified patterns from official sources:

### Example 1: Supabase Client Setup (Backend)

```python
# src/core/supabase.py
import os
from supabase import create_client, Client
from src.core.config import settings

# Admin client (service_role) - bypasses RLS, use for backend operations only
supabase_admin: Client = create_client(
    settings.SUPABASE_URL,
    settings.SUPABASE_SERVICE_ROLE_KEY
)

# Anon client (for testing public access)
supabase_anon: Client = create_client(
    settings.SUPABASE_URL,
    settings.SUPABASE_ANON_KEY
)
```

**Source:** [Python API Reference](https://supabase.com/docs/reference/python/initializing)

### Example 2: Supabase Client Setup (Frontend)

```typescript
// frontend-dashboard/src/lib/supabase.ts (Municipal dashboard)
import { createClient } from '@supabase/supabase-js';

export const supabase = createClient(
  import.meta.env.VITE_SUPABASE_URL,
  import.meta.env.VITE_SUPABASE_ANON_KEY,  // Uses anon key, relies on RLS
  {
    auth: {
      persistSession: true,
      autoRefreshToken: true,
    }
  }
);
```

```typescript
// frontend-public/src/lib/supabase.ts (Public dashboard)
import { createClient } from '@supabase/supabase-js';

export const supabase = createClient(
  import.meta.env.VITE_SUPABASE_URL,
  import.meta.env.VITE_SUPABASE_ANON_KEY,
  {
    auth: {
      persistSession: false,  // No auth needed for public dashboard
    }
  }
);
```

**Source:** [Supabase with React Guide](https://supabase.com/docs/guides/getting-started/quickstarts/reactjs)

### Example 3: Phone OTP Authentication (Citizen Portal)

```typescript
// frontend-dashboard/src/hooks/useAuth.ts
import { supabase } from '../lib/supabase';

export function useAuth() {
  async function signInWithPhone(phone: string) {
    // Send OTP via SMS
    const { data, error } = await supabase.auth.signInWithOtp({
      phone: phone,  // Format: +27123456789
      options: {
        channel: 'sms',  // Or 'whatsapp' if configured
      }
    });

    if (error) throw error;
    return data;
  }

  async function verifyOtp(phone: string, token: string) {
    const { data, error } = await supabase.auth.verifyOtp({
      phone: phone,
      token: token,
      type: 'sms'
    });

    if (error) throw error;
    return data.user;
  }

  async function signInWithPassword(email: string, password: string) {
    const { data, error } = await supabase.auth.signInWithPassword({
      email,
      password,
    });

    if (error) throw error;
    return data.user;
  }

  return { signInWithPhone, verifyOtp, signInWithPassword };
}
```

**Source:** [Phone Login Guide](https://supabase.com/docs/guides/auth/phone-login)

### Example 4: Supabase Storage Upload (GBV Evidence)

```python
# src/services/storage_service.py (MIGRATED)
from supabase import create_client
from src.core.supabase import supabase_admin

async def upload_gbv_evidence(
    ticket_id: str,
    municipality_id: str,
    file_content: bytes,
    filename: str,
    content_type: str
) -> dict:
    """Upload GBV evidence to Supabase Storage with encryption."""

    # Generate storage path: gbv-evidence/{municipality_id}/{ticket_id}/{filename}
    storage_path = f"{municipality_id}/{ticket_id}/{filename}"

    # Upload to private bucket (RLS enforced)
    result = supabase_admin.storage.from_('gbv-evidence').upload(
        storage_path,
        file_content,
        file_options={
            "content-type": content_type,
            "upsert": False,  # Prevent overwrites
        }
    )

    if result.error:
        raise StorageServiceError(f"Upload failed: {result.error.message}")

    return {
        "bucket": "gbv-evidence",
        "path": storage_path,
        "public_url": None,  # Private bucket, no public access
    }
```

### Example 5: Alembic Migration with Supabase RLS

```python
# alembic/versions/xxxx_migrate_to_supabase_rls.py
"""migrate_to_supabase_rls

Revision ID: xxxx
Revises: yyyy
Create Date: 2026-02-10
"""
from alembic import op

def upgrade():
    # Enable RLS on all tenant-aware tables
    tenant_tables = [
        'users', 'tickets', 'reports', 'teams', 'assignments',
        'consent_records', 'media', 'sla_configs'
    ]

    for table in tenant_tables:
        # Enable RLS
        op.execute(f"ALTER TABLE {table} ENABLE ROW LEVEL SECURITY;")
        op.execute(f"ALTER TABLE {table} FORCE ROW LEVEL SECURITY;")

        # Create tenant isolation policy
        op.execute(f"""
            CREATE POLICY tenant_isolation_{table} ON {table}
            TO authenticated
            USING (
                tenant_id = (SELECT (auth.jwt() -> 'app_metadata' ->> 'tenant_id')::uuid)
            )
        """)

        # Index tenant_id for performance
        op.execute(f"CREATE INDEX IF NOT EXISTS idx_{table}_tenant_id ON {table}(tenant_id);")

    # GBV firewall - separate policy for SAPS liaisons
    op.execute("""
        CREATE POLICY saps_access_gbv_tickets ON tickets
        TO authenticated
        USING (
            category IN ('GBV', 'ABUSE', 'DOMESTIC_VIOLENCE')
            AND (auth.jwt() -> 'app_metadata' ->> 'role') = 'SAPS_LIAISON'
            AND tenant_id = (SELECT (auth.jwt() -> 'app_metadata' ->> 'tenant_id')::uuid)
        )
    """)

def downgrade():
    # Disable RLS (for rollback)
    tenant_tables = ['users', 'tickets', 'reports', 'teams', 'assignments']
    for table in tenant_tables:
        op.execute(f"DROP POLICY IF EXISTS tenant_isolation_{table} ON {table};")
        op.execute(f"ALTER TABLE {table} DISABLE ROW LEVEL SECURITY;")
```

**Source:** [Database Migrations Guide](https://supabase.com/docs/guides/deployment/database-migrations)

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| Custom JWT + Argon2 | Supabase Auth (JWT + bcrypt/scrypt) | 2024+ | Automatic token refresh, MFA, OAuth out-of-box |
| AWS S3 presigned URLs | Supabase Storage SDK | 2024+ | Direct browser uploads, RLS integration, no backend presigning |
| Redis Pub/Sub + SSE | Supabase Realtime (Phoenix Channels) | 2024+ | Database-aware subscriptions, automatic RLS filtering |
| Manual RLS with SET LOCAL | Supabase Auth JWT claims | 2024+ | Automatic tenant context from JWT, no middleware needed |
| Self-hosted PostgreSQL | Supabase Cloud PostgreSQL | 2023+ | Automatic backups, point-in-time recovery, PostGIS included |

**Deprecated/outdated:**
- **anon and service_role keys:** Supabase is transitioning to `sb_publishable_...` and `sb_secret_...` keys (as of 2024-09-13). New projects use the new format. Migration guide available in dashboard.
- **supabase-py sync client:** Async support added in v2.2.0 (2024). Use `acreate_client()` for FastAPI async endpoints.
- **Realtime v1 (WALRUS):** Deprecated in favor of Realtime v2 (Broadcast, Presence, Postgres Changes). Migration required for older projects.

**Source:** [Upcoming Changes to Supabase API Keys](https://github.com/orgs/supabase/discussions/29260)

## Open Questions

### 1. Does Supabase support PostGIS for geospatial queries?

**What we know:** Official documentation confirms PostGIS is available as an extension. Enable via dashboard: `CREATE EXTENSION postgis;`. Supports Point, Polygon, LineString types. Nearest-neighbor queries use `<->` operator.

**What's unclear:** Performance of PostGIS RLS policies with spatial predicates (e.g., `ST_DWithin(location, user_location, 5000)`). Need to test with 10K+ tickets.

**Recommendation:** Enable PostGIS in Phase 06.1 migration. Keep existing GeoAlchemy2 models unchanged. Test heatmap query performance with RLS enabled.

**Source:** [PostGIS Guide](https://supabase.com/docs/guides/database/extensions/postgis)

### 2. Can Alembic manage schema changes on Supabase-hosted PostgreSQL?

**What we know:** Supabase PostgreSQL is standard Postgres 15+. Alembic connects via standard connection string. No restrictions on DDL operations.

**What's unclear:** Does Supabase dashboard schema editor conflict with Alembic migrations? Do migrations need to be replicated across Supabase branching environments?

**Recommendation:** Use Alembic as source of truth. Avoid Supabase dashboard schema editor. Test migration rollback (`alembic downgrade -1`) before production deployment.

**Source:** [Local Development with Schema Migrations](https://supabase.com/docs/guides/local-development/overview)

### 3. How does Supabase handle Celery background job database connections?

**What we know:** Celery workers connect to PostgreSQL using standard asyncpg/psycopg. Supabase provides both direct connection (persistent) and transaction pooler (serverless).

**What's unclear:** Should Celery use direct connection string or pooler? Impact on connection limits (60 connections on free tier)?

**Recommendation:** Use transaction pooler for Celery workers (short-lived tasks). Direct connection reserved for FastAPI (long-lived connections). Monitor connection usage in Supabase dashboard.

**Source:** [Connect to your database](https://supabase.com/docs/guides/database/connecting-to-postgres)

### 4. Does Supabase Hosting support static site deployment?

**What we know:** Research shows Supabase does NOT offer static site hosting as of 2026-02-10. Community discussions request this feature, but it's not on the roadmap.

**What's unclear:** N/A — feature doesn't exist.

**Recommendation:** Deploy both dashboards to Vercel for consistency. Use Vercel's preview deployments for testing. Supabase Hosting is not an option.

**Source:** [Static Site Hosting Discussion](https://github.com/orgs/supabase/discussions/991)

### 5. How do we link WhatsApp phone numbers to Supabase Auth users?

**What we know:** Supabase Auth supports phone authentication. Users can sign up via phone OTP. Phone stored in `auth.users.phone` field.

**What's unclear:** When a WhatsApp message arrives (Twilio webhook), how do we map `From` phone number to Supabase user without requiring OTP every time?

**Recommendation:** Create `whatsapp_sessions` table linking phone number to Supabase user ID. On first interaction, user completes OTP. Subsequent messages use cached mapping. Session expires after 24 hours (require re-auth).

```sql
CREATE TABLE whatsapp_sessions (
  phone_number text PRIMARY KEY,
  user_id uuid REFERENCES auth.users(id),
  tenant_id uuid NOT NULL,
  expires_at timestamptz NOT NULL,
  created_at timestamptz DEFAULT now()
);
```

## Sources

### Primary (HIGH confidence)

**Official Supabase Documentation:**
- [Row Level Security](https://supabase.com/docs/guides/database/postgres/row-level-security) - RLS patterns, auth.uid() usage
- [Custom Claims & RBAC](https://supabase.com/docs/guides/database/postgres/custom-claims-and-role-based-access-control-rbac) - JWT custom claims, RBAC implementation
- [Storage Access Control](https://supabase.com/docs/guides/storage/security/access-control) - Bucket RLS policies
- [Realtime Architecture](https://supabase.com/docs/guides/realtime/architecture) - Phoenix Channels, WebSocket implementation
- [Phone Login](https://supabase.com/docs/guides/auth/phone-login) - OTP authentication
- [PostGIS Extension](https://supabase.com/docs/guides/database/extensions/postgis) - Spatial queries
- [Python Client](https://supabase.com/docs/reference/python/initializing) - supabase-py SDK

**GitHub Official Repositories:**
- [supabase/supabase-py](https://github.com/supabase/supabase-py) - Official Python client
- [supabase/realtime](https://github.com/supabase/realtime) - Realtime server (Elixir)

**PyPI Packages:**
- [supabase 2.27.3](https://pypi.org/project/supabase/) - Latest Python SDK

### Secondary (MEDIUM confidence)

**Technical Guides:**
- [Supabase RLS: Complete Guide (2026)](https://designrevision.com/blog/supabase-row-level-security) - RLS best practices
- [FastAPI with Supabase](https://medium.com/@abhik12295/building-a-supabase-and-fastapi-project-a-modern-backend-stack-52030ca54ddf) - Integration patterns
- [Multi-Tenant Applications with RLS](https://www.antstack.com/blog/multi-tenant-applications-with-rls-on-supabase-postgress/) - Multi-tenancy patterns
- [Sensitive Data Encryption with Supabase](https://medium.com/@yogeshmulecraft/sensitive-data-encryption-with-supabase-77737d0871e8) - Field-level encryption

**Deployment Guides:**
- [FastAPI on Vercel](https://vercel.com/docs/frameworks/backend/fastapi) - Vercel deployment patterns
- [Building with FastAPI and Supabase](https://blog.theinfosecguy.xyz/building-a-crud-api-with-fastapi-and-supabase-a-step-by-step-guide) - CRUD patterns

### Tertiary (LOW confidence - flagged for validation)

**Community Discussions:**
- [Multi-tenant RLS Discussion](https://github.com/orgs/supabase/discussions/1615) - Community patterns for multi-tenancy
- [Static Site Hosting Request](https://github.com/orgs/supabase/discussions/991) - Hosting limitations
- [Background Jobs with Edge Functions](https://www.jigz.dev/blogs/how-i-solved-background-jobs-using-supabase-tables-and-edge-functions) - Alternative to Celery (not recommended for this project)

## Metadata

**Confidence breakdown:**
- **Database migration (PostgreSQL → Supabase PostgreSQL):** HIGH — Supabase is standard Postgres, SQLAlchemy/Alembic work unchanged
- **Auth migration (Custom JWT → Supabase Auth):** HIGH — Official docs + verified examples for FastAPI integration
- **Storage migration (S3 → Supabase Storage):** MEDIUM-HIGH — RLS patterns verified, but GBV encryption needs custom testing
- **Realtime migration (Redis → Supabase Realtime):** MEDIUM — Architecture understood, but performance at scale (5K+ concurrent users) unverified
- **Dashboard separation:** HIGH — Vercel deployment well-documented, RLS patterns for public dashboard verified
- **RBAC implementation:** HIGH — Custom claims pattern verified in official docs, 6-role model straightforward

**Research date:** 2026-02-10
**Valid until:** 2026-03-12 (30 days — stable infrastructure, unlikely to change rapidly)

**Key uncertainties:**
- Supabase Storage encryption performance with large files (100MB+ videos)
- Realtime channel capacity for 50+ concurrent dashboard users per municipality
- WhatsApp phone-to-Supabase user linking pattern (requires custom implementation)
- RLS policy performance with 100K+ tickets (PostGIS spatial queries + tenant filtering)

**Next steps:**
- Prototype auth migration in isolated branch (test phone OTP + custom claims)
- Benchmark RLS query performance with production-sized dataset (seed 100K tickets)
- Test Supabase Storage RLS policies with GBV bucket (verify SAPS-only access)
- Load test Supabase Realtime with 100+ concurrent WebSocket connections
