---
phase: 06.1-postgres-refactor-to-supabase-and-dashboard-separation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/core/config.py
  - src/core/supabase.py
  - src/core/database.py
  - alembic/env.py
  - alembic.ini
  - requirements.txt
  - pyproject.toml
autonomous: false
user_setup:
  - service: supabase
    why: "Supabase Cloud project required for database, auth, storage, and realtime"
    env_vars:
      - name: SUPABASE_URL
        source: "Supabase Dashboard -> Settings -> API -> Project URL"
      - name: SUPABASE_ANON_KEY
        source: "Supabase Dashboard -> Settings -> API -> anon public key"
      - name: SUPABASE_SERVICE_ROLE_KEY
        source: "Supabase Dashboard -> Settings -> API -> service_role secret key"
      - name: SUPABASE_JWT_SECRET
        source: "Supabase Dashboard -> Settings -> API -> JWT Secret"
      - name: SUPABASE_DB_URL
        source: "Supabase Dashboard -> Settings -> Database -> Connection string (Transaction pooler for Celery, Direct for FastAPI)"
    dashboard_config:
      - task: "Create a Supabase project"
        location: "https://supabase.com/dashboard -> New Project"
      - task: "Enable PostGIS extension"
        location: "Supabase Dashboard -> Database -> Extensions -> Search 'postgis' -> Enable"
      - task: "Copy connection strings and API keys to .env"
        location: "Supabase Dashboard -> Settings -> API and Settings -> Database"

must_haves:
  truths:
    - "FastAPI connects to Supabase Cloud PostgreSQL using SQLAlchemy (not local PostgreSQL)"
    - "Supabase admin client (service_role) is available for backend operations"
    - "Supabase anon client is available for testing public access patterns"
    - "Alembic migrations target Supabase-hosted PostgreSQL"
    - "Celery uses transaction pooler connection string"
    - "Custom access token hook injects role and tenant_id into JWT app_metadata"
    - "Python supabase SDK is installed and importable"
  artifacts:
    - path: "src/core/supabase.py"
      provides: "Supabase admin and anon client singletons"
      contains: "supabase_admin"
    - path: "src/core/config.py"
      provides: "Supabase configuration fields (URL, keys, JWT secret)"
      contains: "SUPABASE_URL"
    - path: "src/core/database.py"
      provides: "Database engine using Supabase connection string"
      contains: "SUPABASE_DB_URL"
  key_links:
    - from: "src/core/supabase.py"
      to: "src/core/config.py"
      via: "settings.SUPABASE_URL and settings.SUPABASE_SERVICE_ROLE_KEY"
      pattern: "settings\\.SUPABASE"
    - from: "src/core/database.py"
      to: "src/core/config.py"
      via: "settings.SUPABASE_DB_URL for engine creation"
      pattern: "SUPABASE_DB_URL"
---

<objective>
Set up Supabase Cloud infrastructure: install Python SDK, create Supabase client module, migrate database connection from local PostgreSQL to Supabase-hosted PostgreSQL, update Alembic config, and create the custom access token hook SQL for RBAC.

Purpose: This is the foundation for ALL subsequent Phase 06.1 plans. Every migration (auth, storage, realtime, RLS) depends on the Supabase client being configured and the database connection pointing to Supabase Cloud PostgreSQL.

Output: Working Supabase connection from FastAPI, updated config, Alembic targeting Supabase DB, RBAC custom claims hook ready.
</objective>

<execution_context>
@C:/Users/Bantu/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Bantu/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06.1-postgres-refactor-to-supabase-and-dashboard-separation/06.1-CONTEXT.md
@.planning/phases/06.1-postgres-refactor-to-supabase-and-dashboard-separation/06.1-RESEARCH.md
@src/core/config.py
@src/core/database.py
@alembic.ini
@pyproject.toml
</context>

<tasks>

<task type="checkpoint:human-action" gate="blocking">
  <name>Task 1: Create Supabase Cloud project and configure environment</name>
  <action>
    User must create a Supabase Cloud project and provide credentials:
    1. Go to https://supabase.com/dashboard and create a new project (name: "salga-trust-engine", region: closest to South Africa)
    2. Enable PostGIS extension: Dashboard -> Database -> Extensions -> Search "postgis" -> Enable
    3. Copy the following to .env file:
       - SUPABASE_URL (Project URL from Settings -> API)
       - SUPABASE_ANON_KEY (anon public key from Settings -> API)
       - SUPABASE_SERVICE_ROLE_KEY (service_role secret from Settings -> API)
       - SUPABASE_JWT_SECRET (JWT Secret from Settings -> API)
       - SUPABASE_DB_URL (Direct connection string from Settings -> Database -> Connection string -> URI, with password filled in)
       - SUPABASE_DB_URL_POOLER (Transaction pooler connection string from Settings -> Database -> Connection Pooling -> URI)
  </action>
  <verify>User confirms .env has all 6 SUPABASE_* values populated</verify>
  <done>Supabase project exists with PostGIS enabled and all credentials in .env</done>
</task>

<task type="auto">
  <name>Task 2: Install Supabase SDK, create client module, and update config</name>
  <files>
    src/core/config.py
    src/core/supabase.py
    src/core/database.py
    alembic/env.py
    alembic.ini
    pyproject.toml
  </files>
  <action>
    **Step 1: Install Python dependencies**
    Add to pyproject.toml dependencies: `supabase>=2.27.3`. Run `pip install supabase`.

    **Step 2: Update src/core/config.py**
    Add Supabase configuration fields to Settings class:
    - SUPABASE_URL: str = Field(default="", description="Supabase project URL")
    - SUPABASE_ANON_KEY: str = Field(default="", description="Supabase anon/public key")
    - SUPABASE_SERVICE_ROLE_KEY: str = Field(default="", description="Supabase service role key (server-side only)")
    - SUPABASE_JWT_SECRET: str = Field(default="", description="Supabase JWT secret for token verification")
    - SUPABASE_DB_URL: str = Field(default="", description="Supabase direct PostgreSQL connection string")
    - SUPABASE_DB_URL_POOLER: str = Field(default="", description="Supabase transaction pooler connection string (for Celery)")
    Keep existing DATABASE_URL as fallback for development/testing.
    Keep all existing AWS/Twilio/Redis fields (they stay for now, removed in later plans).

    **Step 3: Create src/core/supabase.py**
    Create new module with:
    - Import create_client from supabase
    - supabase_admin: initialized with SUPABASE_URL + SUPABASE_SERVICE_ROLE_KEY (bypasses RLS)
    - supabase_anon: initialized with SUPABASE_URL + SUPABASE_ANON_KEY (for testing public access)
    - Guard both with `if settings.SUPABASE_URL:` to gracefully degrade in test environments
    - Add get_supabase_admin() and get_supabase_anon() factory functions that lazy-initialize

    **Step 4: Update src/core/database.py**
    - Change engine creation to use settings.SUPABASE_DB_URL if set, otherwise fall back to settings.DATABASE_URL
    - This ensures backward compatibility: tests can still use local PostgreSQL or SQLite
    - Keep the existing get_db() function and SET LOCAL pattern (will be migrated in Plan 03)
    - Update pool settings: pool_size=5, max_overflow=10 for Supabase connection limits (60 on free tier)

    **Step 5: Update alembic/env.py and alembic.ini**
    - In alembic/env.py, read SUPABASE_DB_URL from environment, falling back to DATABASE_URL
    - Convert async URL format if needed (postgresql+asyncpg:// to postgresql://)
    - In alembic.ini, update sqlalchemy.url comment to note Supabase connection

    **Step 6: Create Alembic migration for custom access token hook**
    Create a new Alembic migration that adds the PL/pgSQL function for RBAC custom claims:
    ```sql
    CREATE OR REPLACE FUNCTION public.custom_access_token_hook(event jsonb)
    RETURNS jsonb AS $$
    DECLARE
      user_role text;
      user_tenant_id uuid;
    BEGIN
      SELECT role, tenant_id INTO user_role, user_tenant_id
      FROM public.users
      WHERE id = (event->>'user_id')::uuid;

      IF user_role IS NOT NULL THEN
        event := jsonb_set(event, '{claims,app_metadata,role}', to_jsonb(user_role));
        event := jsonb_set(event, '{claims,app_metadata,tenant_id}', to_jsonb(user_tenant_id::text));
      END IF;

      RETURN event;
    END;
    $$ LANGUAGE plpgsql SECURITY DEFINER;
    ```
    Note: The user will need to enable this hook in Supabase Dashboard -> Auth -> Hooks -> Custom Access Token after migration runs.
  </action>
  <verify>
    - `python -c "from src.core.supabase import get_supabase_admin; print('OK')"` succeeds
    - `python -c "from src.core.config import settings; print(settings.SUPABASE_URL)"` shows Supabase URL
    - `python -c "from src.core.database import engine; print(engine.url)"` shows Supabase connection
    - `alembic heads` shows the new migration
  </verify>
  <done>
    Supabase Python SDK installed, supabase.py module exports admin/anon clients, config.py has all SUPABASE_* fields, database.py uses Supabase connection string, Alembic targets Supabase DB, custom access token hook migration created
  </done>
</task>

</tasks>

<verification>
1. `python -c "import supabase; print(supabase.__version__)"` shows >= 2.27.3
2. `python -c "from src.core.supabase import get_supabase_admin"` imports cleanly
3. `python -c "from src.core.config import settings; assert settings.SUPABASE_URL"` passes
4. `alembic upgrade head` runs without errors against Supabase DB (after user setup)
5. Existing tests still pass: `pytest tests/ -x --ignore=tests/integration` (unit tests)
</verification>

<success_criteria>
- Supabase SDK installed and importable
- Config has all 6 SUPABASE_* fields
- Supabase admin and anon clients instantiatable
- Database engine uses Supabase connection string
- Alembic migration for custom access token hook exists
- No regression in existing unit tests (they still use local DB)
</success_criteria>

<output>
After completion, create `.planning/phases/06.1-postgres-refactor-to-supabase-and-dashboard-separation/06.1-01-SUMMARY.md`
</output>
