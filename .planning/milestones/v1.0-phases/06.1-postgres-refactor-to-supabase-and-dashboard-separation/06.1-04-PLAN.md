---
phase: 06.1-postgres-refactor-to-supabase-and-dashboard-separation
plan: 04
type: execute
wave: 3
depends_on: ["06.1-02"]
files_modified:
  - src/models/base.py
  - src/core/database.py
  - src/middleware/tenant_middleware.py
autonomous: true

must_haves:
  truths:
    - "RLS policies use auth.jwt() -> 'app_metadata' ->> 'tenant_id' (not SET LOCAL app.current_tenant)"
    - "All tenant-aware tables have RLS enabled with FORCE ROW LEVEL SECURITY"
    - "RLS policies use (SELECT ...) wrapper for performance optimization"
    - "All RLS policy columns are indexed (tenant_id, user_id, ward_id)"
    - "Application-level tenant filter still works as defense-in-depth"
    - "Public dashboard uses anon role with aggregated views (no raw ticket access)"
    - "GBV tickets excluded from anon role via RLS (category filter)"
    - "Non-tenant tables (Municipality, AuditLog, SLAConfig) have separate RLS policies"
  artifacts:
    - path: "src/models/base.py"
      provides: "Updated application-level tenant filter compatible with Supabase JWT"
      contains: "tenant_id"
    - path: "src/core/database.py"
      provides: "Database session without SET LOCAL (RLS via JWT claims)"
      contains: "get_db"
  key_links:
    - from: "src/core/database.py"
      to: "src/api/deps.py"
      via: "get_db provides session, deps.py sets tenant context from JWT"
      pattern: "get_db"
    - from: "src/models/base.py"
      to: "src/core/tenant.py"
      via: "add_tenant_filter reads tenant context for defense-in-depth"
      pattern: "get_tenant_context"
---

<objective>
Migrate Row Level Security policies from SET LOCAL app.current_tenant pattern to Supabase auth.jwt() pattern. Create comprehensive RLS policies for all tenant-aware tables, public dashboard views for anon role, and update the application-level tenant filter.

Purpose: Supabase Auth injects tenant_id and role into JWT claims via the custom access token hook (from Plan 01). RLS policies must now read these claims instead of the app.current_tenant session variable. This is the critical security migration — every database query must be tenant-isolated.

Output: All RLS policies use auth.jwt(), public views created for anon role, GBV firewall enforced at database level.
</objective>

<execution_context>
@C:/Users/Bantu/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Bantu/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@.planning/phases/06.1-postgres-refactor-to-supabase-and-dashboard-separation/06.1-CONTEXT.md
@.planning/phases/06.1-postgres-refactor-to-supabase-and-dashboard-separation/06.1-RESEARCH.md
@.planning/phases/06.1-postgres-refactor-to-supabase-and-dashboard-separation/06.1-01-SUMMARY.md
@.planning/phases/06.1-postgres-refactor-to-supabase-and-dashboard-separation/06.1-02-SUMMARY.md
@src/models/base.py
@src/core/database.py
@src/middleware/tenant_middleware.py
@src/core/tenant.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create comprehensive RLS migration with auth.jwt() policies</name>
  <files>
    src/core/database.py
  </files>
  <action>
    **Step 1: Create Alembic migration for RLS policy migration**
    Create a new Alembic migration `migrate_rls_to_supabase_auth` that:

    a) Drop existing RLS policies (the SET LOCAL ones from Phase 1):
    ```sql
    -- Drop old policies that used current_setting('app.current_tenant')
    DROP POLICY IF EXISTS tenant_isolation_users ON users;
    DROP POLICY IF EXISTS tenant_isolation_tickets ON tickets;
    -- ... for all tenant-aware tables
    ```

    b) Create new RLS policies using auth.jwt() for ALL tenant-aware tables:
    Tables: users, tickets, consent_records, media_attachments, teams, ticket_assignments, whatsapp_sessions

    For each tenant-aware table, create standard CRUD policies:
    ```sql
    -- SELECT policy (SELECT wrapper for performance per research)
    CREATE POLICY "tenant_select_{table}" ON {table}
    FOR SELECT TO authenticated
    USING (
      tenant_id = (SELECT (auth.jwt() -> 'app_metadata' ->> 'tenant_id'))
    );

    -- INSERT policy
    CREATE POLICY "tenant_insert_{table}" ON {table}
    FOR INSERT TO authenticated
    WITH CHECK (
      tenant_id = (SELECT (auth.jwt() -> 'app_metadata' ->> 'tenant_id'))
    );

    -- UPDATE policy
    CREATE POLICY "tenant_update_{table}" ON {table}
    FOR UPDATE TO authenticated
    USING (
      tenant_id = (SELECT (auth.jwt() -> 'app_metadata' ->> 'tenant_id'))
    );

    -- DELETE policy
    CREATE POLICY "tenant_delete_{table}" ON {table}
    FOR DELETE TO authenticated
    USING (
      tenant_id = (SELECT (auth.jwt() -> 'app_metadata' ->> 'tenant_id'))
    );
    ```

    c) Create role-specific policies for tickets table:
    ```sql
    -- Managers and admins see all tickets in their tenant
    CREATE POLICY "managers_all_tickets" ON tickets
    FOR SELECT TO authenticated
    USING (
      tenant_id = (SELECT (auth.jwt() -> 'app_metadata' ->> 'tenant_id'))
      AND (SELECT (auth.jwt() -> 'app_metadata' ->> 'role')) IN ('manager', 'admin')
    );

    -- Ward councillors see only their ward's tickets
    CREATE POLICY "ward_councillor_tickets" ON tickets
    FOR SELECT TO authenticated
    USING (
      tenant_id = (SELECT (auth.jwt() -> 'app_metadata' ->> 'tenant_id'))
      AND (SELECT (auth.jwt() -> 'app_metadata' ->> 'role')) = 'ward_councillor'
      -- ward_id filtering will be added when ward_id is in JWT claims
    );

    -- Citizens see only their own tickets
    CREATE POLICY "citizen_own_tickets" ON tickets
    FOR SELECT TO authenticated
    USING (
      tenant_id = (SELECT (auth.jwt() -> 'app_metadata' ->> 'tenant_id'))
      AND (SELECT (auth.jwt() -> 'app_metadata' ->> 'role')) = 'citizen'
      AND created_by = (SELECT auth.uid()::text)
    );

    -- GBV tickets: SAPS_LIAISON only (SEC-05 firewall at DB level)
    CREATE POLICY "saps_gbv_tickets" ON tickets
    FOR SELECT TO authenticated
    USING (
      is_sensitive = true
      AND tenant_id = (SELECT (auth.jwt() -> 'app_metadata' ->> 'tenant_id'))
      AND (SELECT (auth.jwt() -> 'app_metadata' ->> 'role')) IN ('saps_liaison', 'admin')
    );
    ```

    d) Create anon policies for public dashboard:
    ```sql
    -- REVOKE direct access to tickets from anon (defense-in-depth)
    REVOKE SELECT ON tickets FROM anon;

    -- Create public aggregation view (no PII, no GBV)
    CREATE OR REPLACE VIEW public.public_ticket_stats AS
    SELECT
      t.tenant_id as municipality_id,
      m.name as municipality_name,
      t.category,
      t.status,
      t.created_at::date as report_date,
      CASE WHEN t.first_responded_at IS NOT NULL
        THEN EXTRACT(EPOCH FROM (t.first_responded_at - t.created_at)) / 3600
      END as response_hours,
      CASE WHEN t.resolved_at IS NOT NULL
        THEN EXTRACT(EPOCH FROM (t.resolved_at - t.created_at)) / 3600
      END as resolution_hours
    FROM tickets t
    JOIN municipalities m ON t.tenant_id = m.id::text
    WHERE t.is_sensitive = false
      AND m.is_active = true;

    -- Grant anon read access to view only
    GRANT SELECT ON public.public_ticket_stats TO anon;

    -- Municipality list view for public dashboard
    CREATE OR REPLACE VIEW public.public_municipalities AS
    SELECT id, name, code, province
    FROM municipalities
    WHERE is_active = true;

    GRANT SELECT ON public.public_municipalities TO anon;

    -- Heatmap view (aggregated, k-anonymity)
    CREATE OR REPLACE VIEW public.public_heatmap AS
    SELECT
      ST_Y(ST_SnapToGrid(t.location, 0.01, 0.01)) as lat,
      ST_X(ST_SnapToGrid(t.location, 0.01, 0.01)) as lng,
      COUNT(*) as intensity,
      t.tenant_id as municipality_id
    FROM tickets t
    JOIN municipalities m ON t.tenant_id = m.id::text
    WHERE t.is_sensitive = false
      AND m.is_active = true
      AND t.location IS NOT NULL
    GROUP BY ST_SnapToGrid(t.location, 0.01, 0.01), t.tenant_id
    HAVING COUNT(*) >= 3;

    GRANT SELECT ON public.public_heatmap TO anon;
    ```

    e) Ensure ALL RLS policy columns are indexed:
    ```sql
    CREATE INDEX IF NOT EXISTS idx_tickets_tenant_id ON tickets(tenant_id);
    CREATE INDEX IF NOT EXISTS idx_tickets_is_sensitive ON tickets(is_sensitive);
    CREATE INDEX IF NOT EXISTS idx_tickets_created_by ON tickets(created_by);
    CREATE INDEX IF NOT EXISTS idx_tickets_status ON tickets(status);
    CREATE INDEX IF NOT EXISTS idx_users_tenant_id ON users(tenant_id);
    CREATE INDEX IF NOT EXISTS idx_teams_tenant_id ON teams(tenant_id);
    CREATE INDEX IF NOT EXISTS idx_consent_records_tenant_id ON consent_records(tenant_id);
    CREATE INDEX IF NOT EXISTS idx_media_attachments_tenant_id ON media_attachments(tenant_id);
    CREATE INDEX IF NOT EXISTS idx_ticket_assignments_tenant_id ON ticket_assignments(tenant_id);
    ```

    **Step 2: Update src/core/database.py get_db()**
    Remove the SET LOCAL app.current_tenant pattern:
    - The `if tenant_id:` block that calls `SET LOCAL app.current_tenant` is no longer needed
    - Supabase RLS reads tenant_id from the JWT automatically
    - Keep get_db() as a session provider but remove the tenant context injection
    - For the FastAPI backend (which uses service_role key and bypasses RLS), tenant filtering happens at the application level (base.py add_tenant_filter)
    - IMPORTANT: When FastAPI backend uses the admin connection (service_role), RLS is bypassed. The application-level filter in base.py is the defense-in-depth layer.
  </action>
  <verify>
    - `alembic heads` shows new RLS migration
    - `python -c "from src.core.database import get_db; print('OK')"` succeeds
    - No "SET LOCAL" in database.py: `grep -c "SET LOCAL" src/core/database.py` returns 0
  </verify>
  <done>
    All RLS policies migrated from SET LOCAL to auth.jwt() pattern. Public views created for anon role. GBV firewall enforced at database level. All policy columns indexed. SET LOCAL removed from database.py.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update application-level tenant filter and tenant middleware</name>
  <files>
    src/models/base.py
    src/middleware/tenant_middleware.py
  </files>
  <action>
    **Step 1: Update src/models/base.py add_tenant_filter**
    The application-level tenant filter remains as defense-in-depth. Update it to:
    - Keep the same logic: intercept ORM SELECT queries, check for tenant_id on model, filter by tenant context
    - The tenant context is now set by get_current_user in deps.py (from JWT app_metadata), not from X-Tenant-ID header
    - Update the SecurityError message to reference JWT claims instead of X-Tenant-ID header:
      ```
      "Tenant context not set for tenant-aware query - potential data leakage. "
      "Ensure tenant_id is present in JWT app_metadata claims."
      ```
    - Add an escape hatch for public endpoints: if the query comes from a public endpoint (no auth required), skip the tenant filter
    - This can be done by checking if tenant_id is None AND the query is against a non-tenant model or a public view

    **Step 2: Update src/middleware/tenant_middleware.py**
    The tenant middleware currently reads X-Tenant-ID header and sets tenant context.
    With Supabase Auth, tenant_id comes from the JWT, not a header:
    - Remove X-Tenant-ID header extraction for authenticated routes
    - Keep the middleware but simplify: it should only handle:
      1. Public endpoints (no tenant context needed, skip)
      2. WhatsApp webhook (uses phone-to-session lookup, not JWT)
      3. All other endpoints: tenant context set by get_current_user in deps.py
    - The middleware becomes a pass-through for most routes, with tenant context set in the auth dependency
    - Update TENANT_EXEMPT_PATHS to include all public endpoints
    - Remove the UUID validation on X-Tenant-ID (no longer needed — comes from trusted JWT)
  </action>
  <verify>
    - `python -c "from src.models.base import TenantAwareModel; print('OK')"` succeeds
    - `python -c "from src.middleware.tenant_middleware import TenantContextMiddleware; print('OK')"` succeeds
    - No reference to "X-Tenant-ID" header setting in tenant middleware (header may still be read for backward compat but not required)
  </verify>
  <done>
    Application-level tenant filter updated for Supabase JWT pattern. Tenant middleware simplified — tenant context flows from JWT, not from X-Tenant-ID header. Defense-in-depth maintained: RLS + application filter.
  </done>
</task>

</tasks>

<verification>
1. RLS migration creates policies for all tenant-aware tables
2. Public views exist for anon role (public_ticket_stats, public_municipalities, public_heatmap)
3. GBV exclusion via is_sensitive filter in all public views
4. SET LOCAL removed from database.py
5. Application-level tenant filter still operational
6. All indexes on RLS policy columns created
7. No regression in module imports
</verification>

<success_criteria>
- All tenant-aware tables have auth.jwt()-based RLS policies for CRUD
- Role-specific ticket policies (manager, ward_councillor, citizen, saps_liaison)
- Public views for anon role with GBV exclusion
- SET LOCAL app.current_tenant completely removed
- Application-level filter references JWT claims
- Tenant middleware simplified
- k-anonymity threshold on heatmap view (>= 3)
</success_criteria>

<output>
After completion, create `.planning/phases/06.1-postgres-refactor-to-supabase-and-dashboard-separation/06.1-04-SUMMARY.md`
</output>
