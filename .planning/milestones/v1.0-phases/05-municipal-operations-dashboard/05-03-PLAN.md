---
phase: 05-municipal-operations-dashboard
plan: 03
type: execute
wave: 2
depends_on: ["05-01", "05-02"]
files_modified:
  - frontend/package.json
  - frontend/src/types/dashboard.ts
  - frontend/src/services/api.ts
  - frontend/src/services/sse.ts
  - frontend/src/stores/dashboardStore.ts
  - frontend/src/hooks/useSSE.ts
  - frontend/src/hooks/useTicketFilters.ts
  - frontend/src/components/dashboard/FilterBar.tsx
  - frontend/src/components/dashboard/TicketTable.tsx
  - frontend/src/components/dashboard/ExportButton.tsx
  - frontend/src/components/dashboard/Pagination.tsx
  - frontend/src/pages/TicketListPage.tsx
autonomous: true

must_haves:
  truths:
    - "Municipal manager can view paginated ticket list with server-side filtering"
    - "Manager can filter tickets by status, category, and free-text search"
    - "Manager can sort ticket table by any column"
    - "Manager can export filtered tickets to CSV or Excel"
    - "Ticket table shows tracking number, category, status, severity, created date, SLA deadline"
  artifacts:
    - path: "frontend/src/pages/TicketListPage.tsx"
      provides: "Main ticket list page with filters and table"
      contains: "TicketListPage"
    - path: "frontend/src/components/dashboard/TicketTable.tsx"
      provides: "TanStack Table for ticket display"
      contains: "useReactTable"
    - path: "frontend/src/components/dashboard/FilterBar.tsx"
      provides: "Filter inputs for status, category, search"
      contains: "FilterBar"
    - path: "frontend/src/components/dashboard/ExportButton.tsx"
      provides: "CSV/Excel export buttons"
      contains: "ExportButton"
    - path: "frontend/src/stores/dashboardStore.ts"
      provides: "Zustand store for dashboard state"
      contains: "create"
  key_links:
    - from: "frontend/src/pages/TicketListPage.tsx"
      to: "frontend/src/components/dashboard/TicketTable.tsx"
      via: "Component composition"
      pattern: "TicketTable"
    - from: "frontend/src/components/dashboard/TicketTable.tsx"
      to: "frontend/src/services/api.ts"
      via: "fetchTickets API call"
      pattern: "fetchTickets"
    - from: "frontend/src/components/dashboard/ExportButton.tsx"
      to: "/api/v1/export/tickets"
      via: "Download link"
      pattern: "export/tickets"
---

<objective>
Build the frontend ticket list page with TanStack Table, server-side filtering, sorting, pagination, and CSV/Excel export buttons.

Purpose: OPS-01 (view, filter, search, assign tickets), OPS-02 (export to Excel/CSV). This is the primary working surface for municipal managers.
Output: TicketListPage with TicketTable, FilterBar, ExportButton, Pagination components
</objective>

<execution_context>
@C:/Users/Bantu/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Bantu/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-municipal-operations-dashboard/05-RESEARCH.md
@.planning/phases/05-municipal-operations-dashboard/05-01-SUMMARY.md
@frontend/package.json
@frontend/src/App.tsx
@frontend/src/services/api.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install dependencies and create shared frontend infrastructure</name>
  <files>frontend/package.json, frontend/src/types/dashboard.ts, frontend/src/services/api.ts, frontend/src/services/sse.ts, frontend/src/stores/dashboardStore.ts, frontend/src/hooks/useSSE.ts, frontend/src/hooks/useTicketFilters.ts</files>
  <action>
    1. Install frontend dependencies:
       ```bash
       cd frontend && npm install @tanstack/react-table@8 recharts@2 zustand@5 date-fns@4
       ```
       Note: Do NOT install react-csv or xlsx -- we use server-side export via download links instead (simpler, no client-side memory issues, per research recommendation for >5K rows).

    2. Create `frontend/src/types/dashboard.ts` with TypeScript interfaces:
       ```typescript
       export interface Ticket {
         id: string;
         tracking_number: string;
         category: string;
         description: string;
         status: string;
         severity: string;
         language: string;
         address: string | null;
         user_id: string;
         is_sensitive: boolean;
         created_at: string;
         assigned_team_id: string | null;
         assigned_to: string | null;
         escalated_at: string | null;
         first_responded_at: string | null;
         sla_response_deadline: string | null;
         sla_resolution_deadline: string | null;
       }

       export interface PaginatedTicketResponse {
         tickets: Ticket[];
         total: number;
         page: number;
         page_size: number;
         page_count: number;
       }

       export interface TicketFilters {
         status?: string;
         category?: string;
         search?: string;
         ward_id?: string;
         sort_by?: string;
         sort_order?: 'asc' | 'desc';
         page?: number;
         page_size?: number;
       }

       export interface DashboardMetrics {
         total_open: number;
         total_resolved: number;
         sla_compliance_percent: number;
         avg_response_hours: number;
         sla_breaches: number;
       }

       export interface CategoryVolume {
         category: string;
         open: number;
         resolved: number;
       }

       export interface SLACompliance {
         response_compliance_percent: number;
         resolution_compliance_percent: number;
         total_with_sla: number;
         response_breaches: number;
         resolution_breaches: number;
       }

       export interface TeamWorkload {
         team_id: string;
         team_name: string;
         open_count: number;
         total_count: number;
       }

       export interface DashboardEvent {
         type: string;
         data: Record<string, unknown>;
         ward_id?: string;
       }
       ```

    3. Extend `frontend/src/services/api.ts` -- add these NEW functions (do not remove existing ones):
       ```typescript
       /**
        * Fetch paginated tickets with filters (for dashboard).
        */
       export async function fetchTickets(filters: TicketFilters): Promise<PaginatedTicketResponse> {
         const params = new URLSearchParams();
         if (filters.status) params.set('status', filters.status);
         if (filters.category) params.set('category', filters.category);
         if (filters.search) params.set('search', filters.search);
         if (filters.ward_id) params.set('ward_id', filters.ward_id);
         if (filters.sort_by) params.set('sort_by', filters.sort_by);
         if (filters.sort_order) params.set('sort_order', filters.sort_order);
         params.set('page', String(filters.page ?? 0));
         params.set('page_size', String(filters.page_size ?? 50));

         const response = await axios.get(`${API_BASE_URL}/tickets?${params}`, {
           headers: getAuthHeaders(),
         });
         return response.data;
       }

       /**
        * Fetch dashboard metrics.
        */
       export async function fetchDashboardMetrics(wardId?: string): Promise<DashboardMetrics> {
         const params = wardId ? `?ward_id=${wardId}` : '';
         const response = await axios.get(`${API_BASE_URL}/dashboard/metrics${params}`, {
           headers: getAuthHeaders(),
         });
         return response.data;
       }

       /**
        * Fetch ticket volume by category.
        */
       export async function fetchVolumeByCategory(wardId?: string): Promise<CategoryVolume[]> {
         const params = wardId ? `?ward_id=${wardId}` : '';
         const response = await axios.get(`${API_BASE_URL}/dashboard/volume${params}`, {
           headers: getAuthHeaders(),
         });
         return response.data;
       }

       /**
        * Fetch SLA compliance data.
        */
       export async function fetchSLACompliance(wardId?: string): Promise<SLACompliance> {
         const params = wardId ? `?ward_id=${wardId}` : '';
         const response = await axios.get(`${API_BASE_URL}/dashboard/sla${params}`, {
           headers: getAuthHeaders(),
         });
         return response.data;
       }

       /**
        * Fetch team workload data.
        */
       export async function fetchTeamWorkload(wardId?: string): Promise<TeamWorkload[]> {
         const params = wardId ? `?ward_id=${wardId}` : '';
         const response = await axios.get(`${API_BASE_URL}/dashboard/workload${params}`, {
           headers: getAuthHeaders(),
         });
         return response.data;
       }

       /**
        * Get export download URL for tickets.
        */
       export function getExportUrl(format: 'csv' | 'excel', filters: TicketFilters): string {
         const params = new URLSearchParams();
         if (filters.status) params.set('status', filters.status);
         if (filters.category) params.set('category', filters.category);
         if (filters.search) params.set('search', filters.search);
         if (filters.ward_id) params.set('ward_id', filters.ward_id);
         return `${API_BASE_URL}/export/tickets/${format}?${params}`;
       }
       ```

       Add imports at the top of api.ts:
       ```typescript
       import type { TicketFilters, PaginatedTicketResponse, DashboardMetrics, CategoryVolume, SLACompliance, TeamWorkload } from '../types/dashboard';
       ```

    4. Create `frontend/src/services/sse.ts`:
       ```typescript
       /**
        * SSE connection manager for dashboard real-time updates.
        */
       const API_BASE_URL = import.meta.env.VITE_API_BASE_URL || 'http://localhost:8000/api/v1';

       export function createDashboardSSE(
         wardId?: string,
         onMessage?: (event: MessageEvent) => void,
         onError?: (error: Event) => void,
       ): EventSource {
         const token = localStorage.getItem('access_token');
         const params = new URLSearchParams();
         if (wardId) params.set('ward_id', wardId);
         if (token) params.set('token', token);

         // Note: EventSource doesn't support custom headers.
         // Token passed as query param (backend must accept both header and query param auth).
         // For production, use cookie-based auth or a polyfill that supports headers.
         const url = `${API_BASE_URL}/dashboard/events?${params}`;

         const eventSource = new EventSource(url);

         if (onMessage) {
           eventSource.addEventListener('ticket_updated', onMessage);
           eventSource.addEventListener('ticket_created', onMessage);
           eventSource.addEventListener('sla_breach', onMessage);
           eventSource.addEventListener('assignment_changed', onMessage);
         }

         if (onError) {
           eventSource.onerror = onError;
         }

         return eventSource;
       }
       ```

    5. Create `frontend/src/hooks/useSSE.ts`:
       ```typescript
       import { useEffect, useState, useCallback, useRef } from 'react';
       import { createDashboardSSE } from '../services/sse';

       interface UseSSEOptions {
         wardId?: string;
         enabled?: boolean;
         onEvent?: (type: string, data: Record<string, unknown>) => void;
       }

       export function useSSE({ wardId, enabled = true, onEvent }: UseSSEOptions) {
         const [isConnected, setIsConnected] = useState(false);
         const [error, setError] = useState<string | null>(null);
         const eventSourceRef = useRef<EventSource | null>(null);

         const handleMessage = useCallback((event: MessageEvent) => {
           try {
             const data = JSON.parse(event.data);
             onEvent?.(event.type, data);
           } catch (e) {
             console.error('[SSE] Failed to parse event:', e);
           }
         }, [onEvent]);

         const handleError = useCallback(() => {
           setIsConnected(false);
           setError('Connection lost, reconnecting...');
         }, []);

         useEffect(() => {
           if (!enabled) {
             eventSourceRef.current?.close();
             eventSourceRef.current = null;
             setIsConnected(false);
             return;
           }

           const es = createDashboardSSE(wardId, handleMessage, handleError);
           eventSourceRef.current = es;

           es.addEventListener('connected', () => {
             setIsConnected(true);
             setError(null);
           });

           return () => {
             es.close();
             eventSourceRef.current = null;
           };
         }, [wardId, enabled, handleMessage, handleError]);

         return { isConnected, error };
       }
       ```

    6. Create `frontend/src/hooks/useTicketFilters.ts`:
       ```typescript
       import { useState, useCallback } from 'react';
       import type { TicketFilters } from '../types/dashboard';

       const DEFAULT_FILTERS: TicketFilters = {
         page: 0,
         page_size: 50,
         sort_by: 'created_at',
         sort_order: 'desc',
       };

       export function useTicketFilters(initialWardId?: string) {
         const [filters, setFilters] = useState<TicketFilters>({
           ...DEFAULT_FILTERS,
           ward_id: initialWardId,
         });

         const updateFilter = useCallback((key: keyof TicketFilters, value: string | number | undefined) => {
           setFilters(prev => ({
             ...prev,
             [key]: value || undefined,
             // Reset to page 0 when filters change (not when page changes)
             ...(key !== 'page' ? { page: 0 } : {}),
           }));
         }, []);

         const resetFilters = useCallback(() => {
           setFilters({ ...DEFAULT_FILTERS, ward_id: initialWardId });
         }, [initialWardId]);

         return { filters, updateFilter, resetFilters, setFilters };
       }
       ```

    7. Create `frontend/src/stores/dashboardStore.ts` (Zustand store):
       ```typescript
       import { create } from 'zustand';
       import type { DashboardMetrics, CategoryVolume, SLACompliance, TeamWorkload } from '../types/dashboard';

       interface DashboardState {
         // User context
         userRole: string | null;
         wardId: string | null;

         // Metrics data
         metrics: DashboardMetrics | null;
         volumeData: CategoryVolume[];
         slaData: SLACompliance | null;
         workloadData: TeamWorkload[];

         // UI state
         isLoading: boolean;
         lastUpdated: Date | null;

         // Actions
         setUserContext: (role: string, wardId?: string) => void;
         setMetrics: (metrics: DashboardMetrics) => void;
         setVolumeData: (data: CategoryVolume[]) => void;
         setSlaData: (data: SLACompliance) => void;
         setWorkloadData: (data: TeamWorkload[]) => void;
         setLoading: (loading: boolean) => void;
         setLastUpdated: (date: Date) => void;
       }

       export const useDashboardStore = create<DashboardState>((set) => ({
         userRole: null,
         wardId: null,
         metrics: null,
         volumeData: [],
         slaData: null,
         workloadData: [],
         isLoading: false,
         lastUpdated: null,

         setUserContext: (role, wardId) => set({ userRole: role, wardId: wardId ?? null }),
         setMetrics: (metrics) => set({ metrics }),
         setVolumeData: (data) => set({ volumeData: data }),
         setSlaData: (data) => set({ slaData: data }),
         setWorkloadData: (data) => set({ workloadData: data }),
         setLoading: (loading) => set({ isLoading: loading }),
         setLastUpdated: (date) => set({ lastUpdated: date }),
       }));
       ```

    Create the `frontend/src/types/`, `frontend/src/stores/`, and `frontend/src/pages/` directories as needed.
  </action>
  <verify>
    - `cd frontend && npm ls @tanstack/react-table recharts zustand date-fns` shows all installed
    - `cd frontend && npx tsc --noEmit --pretty 2>&1 | head -20` shows no TypeScript errors in new files (or only pre-existing errors)
    - Files exist: types/dashboard.ts, services/sse.ts, stores/dashboardStore.ts, hooks/useSSE.ts, hooks/useTicketFilters.ts
  </verify>
  <done>
    - All frontend dependencies installed
    - TypeScript interfaces defined for all dashboard data types
    - API service extended with dashboard/ticket/export functions
    - SSE service and hook created for real-time updates
    - Zustand store created for dashboard state
    - Filter hook created for ticket list filtering
  </done>
</task>

<task type="auto">
  <name>Task 2: Create ticket list page with table, filters, export, and pagination</name>
  <files>frontend/src/components/dashboard/FilterBar.tsx, frontend/src/components/dashboard/TicketTable.tsx, frontend/src/components/dashboard/ExportButton.tsx, frontend/src/components/dashboard/Pagination.tsx, frontend/src/pages/TicketListPage.tsx</files>
  <action>
    1. Create `frontend/src/components/dashboard/` directory.

    2. Create `frontend/src/components/dashboard/FilterBar.tsx`:
       - Props: `filters: TicketFilters`, `onFilterChange: (key: string, value: string) => void`, `onReset: () => void`
       - Renders: status dropdown (options: All, Open, In Progress, Escalated, Resolved, Closed), category dropdown (options: All, Water, Roads, Electricity, Waste, Sanitation, Other), search input (debounced 300ms with setTimeout), Reset button
       - Styled with basic inline styles or className (no CSS framework -- use simple clean HTML)
       - Status values map to TicketStatus enum: open, in_progress, escalated, resolved, closed
       - Category values map to TicketCategory enum: water, roads, electricity, waste, sanitation, other (exclude gbv per SEC-05)

    3. Create `frontend/src/components/dashboard/TicketTable.tsx`:
       - Uses `@tanstack/react-table` with `useReactTable`, `getCoreRowModel`
       - Props: `tickets: Ticket[]`, `pageCount: number`, `pagination: { pageIndex: number; pageSize: number }`, `sorting: SortingState`, `onPaginationChange`, `onSortingChange`, `isLoading: boolean`
       - Columns: Tracking # (no sort), Category, Status (with color-coded badge), Severity, Created (formatted with date-fns `format`), SLA Deadline (with warning color if near), Address
       - `manualPagination: true`, `manualSorting: true` (server-side)
       - Render standard HTML table with `<thead>`, `<tbody>` (no CSS framework, clean semantic HTML)
       - Sortable headers show arrow indicator (up/down unicode characters, not emoji)
       - Loading state: show "Loading..." in tbody
       - Empty state: show "No tickets found" in tbody

    4. Create `frontend/src/components/dashboard/Pagination.tsx`:
       - Props: `page: number`, `pageCount: number`, `onPageChange: (page: number) => void`
       - Renders: Previous/Next buttons, page number display "Page X of Y", disabled states
       - Simple functional component

    5. Create `frontend/src/components/dashboard/ExportButton.tsx`:
       - Props: `filters: TicketFilters`
       - Uses `getExportUrl` from api.ts to build download links
       - Renders two buttons/links: "Export CSV" and "Export Excel"
       - Uses `<a href={url} download>` for direct download (server handles auth via token query param or requires separate auth approach)
       - Note: For auth, include the Bearer token by opening the URL with fetch and creating a blob URL. Pattern:
         ```typescript
         async function downloadExport(format: 'csv' | 'excel', filters: TicketFilters) {
           const url = getExportUrl(format, filters);
           const token = localStorage.getItem('access_token');
           const response = await fetch(url, {
             headers: { 'Authorization': `Bearer ${token}` },
           });
           const blob = await response.blob();
           const blobUrl = URL.createObjectURL(blob);
           const a = document.createElement('a');
           a.href = blobUrl;
           a.download = `tickets_export.${format === 'excel' ? 'xlsx' : 'csv'}`;
           a.click();
           URL.revokeObjectURL(blobUrl);
         }
         ```

    6. Create `frontend/src/pages/TicketListPage.tsx`:
       - Composes: FilterBar, TicketTable, Pagination, ExportButton
       - Uses `useTicketFilters` hook for filter state
       - Uses `useState` for ticket data, loading, pagination (no React Query -- keep it simple with useEffect)
       - Fetches tickets via `fetchTickets(filters)` on filter/page/sort change
       - Debounce search input (already in FilterBar)
       - Layout: header with title "Ticket Management" + ExportButton, then FilterBar, then TicketTable, then Pagination
       - Handle errors with try/catch and display error message
  </action>
  <verify>
    - `cd frontend && npx tsc --noEmit --pretty 2>&1 | head -30` shows no new TypeScript errors
    - Files exist: components/dashboard/FilterBar.tsx, TicketTable.tsx, ExportButton.tsx, Pagination.tsx, pages/TicketListPage.tsx
    - `cd frontend && npm run build 2>&1 | tail -5` builds successfully (or shows only pre-existing warnings)
  </verify>
  <done>
    - TicketListPage renders ticket table with server-side filtering, sorting, pagination
    - FilterBar provides status, category, and search filters
    - ExportButton triggers CSV/Excel download via authenticated fetch
    - Pagination controls navigate through pages
    - TanStack Table handles column definitions and sort state
  </done>
</task>

</tasks>

<verification>
- `cd frontend && npm run build` completes successfully
- `cd frontend && npx tsc --noEmit` passes type checking
- All components exist and export correctly
- FilterBar renders status/category dropdowns and search input
- TicketTable uses TanStack Table with manual pagination/sorting
</verification>

<success_criteria>
- Municipal manager can view ticket list with filtering, sorting, and pagination
- Search works across tracking number and description
- Export buttons download CSV/Excel files
- Table shows all relevant ticket columns with proper formatting
- Frontend builds without errors
</success_criteria>

<output>
After completion, create `.planning/phases/05-municipal-operations-dashboard/05-03-SUMMARY.md`
</output>
