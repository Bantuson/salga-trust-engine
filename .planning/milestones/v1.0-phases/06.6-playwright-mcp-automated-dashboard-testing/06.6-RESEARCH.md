# Phase 06.6: Playwright MCP Automated Dashboard Testing - Research

**Researched:** 2026-02-14
**Domain:** E2E browser testing, AI-powered test automation, multi-tenant security testing
**Confidence:** MEDIUM-HIGH

## Summary

Playwright MCP (Model Context Protocol) is an AI-integrated testing architecture that connects Playwright browser automation with Model Context Protocol, enabling intelligent test generation, debugging, and self-healing through AI agents. Unlike traditional screenshot-based automation, Playwright MCP uses accessibility trees for fast, LLM-friendly, deterministic test execution.

For SALGA Trust Engine Phase 6.6, we need to implement E2E testing across two separate React applications (frontend-public and frontend-dashboard) with 10 role-specific test profiles covering citizen and municipal user journeys. Testing must verify multi-tenant isolation using mock municipalities ("Jozi Municipal Test" + a second municipality), validate RBAC enforcement across 6 roles (citizen, field_worker, manager, admin, saps_liaison, ward_councillor), test GBV privacy firewalls, and perform OWASP-level security testing.

**Primary recommendation:** Use Microsoft's @playwright/mcp server with persistent browser contexts for authenticated sessions, implement test fixtures for each role profile, integrate OWASP ZAP for security scanning, and use Playwright Test Agents (Planner, Generator, Healer) for initial test generation with human review before production use.

## Standard Stack

### Core
| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| @playwright/test | latest (2026) | E2E test framework | Official Playwright test runner with fixtures, parallelization, auto-wait |
| @playwright/mcp | latest | MCP server for AI integration | Official Microsoft MCP server for AI-driven test automation |
| playwright | latest | Browser automation | Industry standard cross-browser automation (Chromium, Firefox, WebKit) |

### Supporting
| Library | Version | Purpose | When to Use |
|---------|---------|---------|-------------|
| @faker-js/faker | ^9.x | Test data generation | Generate realistic mock data (names, emails, addresses) |
| dotenv | ^16.x | Environment variables | Load test credentials securely from .env.test |
| playwright-zap | latest | OWASP ZAP integration | Security vulnerability scanning during E2E tests |

### Alternatives Considered
| Instead of | Could Use | Tradeoff |
|------------|-----------|----------|
| @playwright/mcp | executeautomation/mcp-playwright | More features (API testing, multi-session) but less official support |
| playwright-zap | Manual ZAP proxy | Full control but requires separate ZAP setup/management |
| @faker-js/faker | Custom mock data | Simpler but misses edge cases in data generation |

**Installation:**
```bash
# Project root (test infrastructure separate from frontend apps)
npm init -y
npm install --save-dev @playwright/test playwright @playwright/mcp
npm install --save-dev @faker-js/faker dotenv playwright-zap
npx playwright install chromium firefox webkit
```

## Architecture Patterns

### Recommended Project Structure
```
e2e-tests/                           # Root test directory (project root level)
├── .github/                          # Playwright Test Agent definitions
│   ├── agents/
│   │   ├── planner.mcp.json         # Test plan generation agent
│   │   ├── generator.mcp.json       # Code generation agent
│   │   └── healer.mcp.json          # Test healing agent
├── fixtures/                         # Test fixtures and utilities
│   ├── auth.ts                       # Authentication fixtures per role
│   ├── test-data.ts                  # Mock data generators (municipalities, users)
│   ├── db-setup.ts                   # Database seeding for test tenants
│   └── page-objects/                 # Page Object Model (POM)
│       ├── public/                   # Public dashboard pages
│       │   ├── LoginPage.ts
│       │   ├── RegisterPage.ts
│       │   ├── ReportIssuePage.ts
│       │   └── ProfilePage.ts
│       └── dashboard/                # Municipal dashboard pages
│           ├── LoginPage.ts
│           ├── RequestAccessPage.ts
│           ├── OnboardingWizardPage.ts
│           └── DashboardPage.ts
├── profiles/                         # Role-specific test profiles
│   ├── public/                       # 5 public dashboard profiles
│   │   ├── citizen-new.profile.ts
│   │   ├── citizen-returning.profile.ts
│   │   ├── citizen-gbv.profile.ts
│   │   ├── citizen-multireport.profile.ts
│   │   └── citizen-tracking.profile.ts
│   └── municipal/                    # 5 municipal dashboard profiles
│       ├── admin.profile.ts
│       ├── manager.profile.ts
│       ├── field-worker.profile.ts
│       ├── saps-liaison.profile.ts
│       └── ward-councillor.profile.ts
├── specs/                            # Test plan markdown files (for Test Agents)
│   ├── public-user-journeys.md
│   ├── municipal-user-journeys.md
│   └── security-tests.md
├── tests/                            # Actual test files
│   ├── seed.spec.ts                  # Bootstrap test for Test Agents
│   ├── public/                       # Public dashboard E2E tests
│   │   ├── auth.spec.ts
│   │   ├── report-submission.spec.ts
│   │   ├── gbv-privacy.spec.ts
│   │   └── profile-management.spec.ts
│   ├── municipal/                    # Municipal dashboard E2E tests
│   │   ├── access-request.spec.ts
│   │   ├── onboarding.spec.ts
│   │   ├── dashboard-rbac.spec.ts
│   │   └── ticket-routing.spec.ts
│   ├── security/                     # OWASP security tests
│   │   ├── authentication.spec.ts
│   │   ├── authorization.spec.ts
│   │   ├── tenant-isolation.spec.ts
│   │   └── rate-limiting.spec.ts
│   └── integration/                  # Cross-dashboard integration tests
│       └── report-to-resolution.spec.ts
├── utils/                            # Shared utilities
│   ├── supabase-test-client.ts      # Test Supabase client
│   ├── api-helpers.ts                # Backend API test helpers
│   └── security-scanner.ts           # OWASP ZAP wrapper
├── playwright.config.ts              # Main Playwright configuration
├── .env.test                         # Test environment variables
└── package.json
```

### Pattern 1: Role-Based Test Fixtures with Persistent Contexts
**What:** Create reusable fixtures that provide authenticated browser contexts for each RBAC role, persisting session state across tests.
**When to use:** For all tests requiring authentication (majority of tests)
**Example:**
```typescript
// fixtures/auth.ts
import { test as base, expect } from '@playwright/test';
import { supabase } from './supabase-test-client';
import type { Page, BrowserContext } from '@playwright/test';

type RoleType = 'citizen' | 'field_worker' | 'manager' | 'admin' | 'saps_liaison' | 'ward_councillor';

interface AuthFixtures {
  authenticatedPage: (role: RoleType, tenantId?: string) => Promise<Page>;
  citizenPage: Page;
  managerPage: Page;
  adminPage: Page;
  sapsLiaisonPage: Page;
}

export const test = base.extend<AuthFixtures>({
  authenticatedPage: async ({ browser }, use, testInfo) => {
    const getAuthPage = async (role: RoleType, tenantId: string = 'test-jozi-001') => {
      // Check for cached auth state
      const storageStatePath = `.auth/${role}-${tenantId}.json`;

      let context: BrowserContext;
      try {
        // Try loading cached session
        context = await browser.newContext({ storageState: storageStatePath });
      } catch {
        // Create new session
        context = await browser.newContext();
        const page = await context.newPage();

        // Perform login based on role
        const credentials = getCredentialsForRole(role, tenantId);
        await page.goto('http://localhost:5173/login'); // Adjust URL per dashboard
        await page.fill('[id="email"]', credentials.email);
        await page.fill('[id="password"]', credentials.password);
        await page.click('button[type="submit"]');
        await page.waitForURL(/dashboard|profile/);

        // Save session state
        await context.storageState({ path: storageStatePath });
        await page.close();

        // Reload context with saved state
        await context.close();
        context = await browser.newContext({ storageState: storageStatePath });
      }

      return await context.newPage();
    };

    await use(getAuthPage);
  },

  citizenPage: async ({ authenticatedPage }, use) => {
    const page = await authenticatedPage('citizen', 'test-jozi-001');
    await use(page);
    await page.close();
  },

  managerPage: async ({ authenticatedPage }, use) => {
    const page = await authenticatedPage('manager', 'test-jozi-001');
    await use(page);
    await page.close();
  },

  // ... other role fixtures
});

function getCredentialsForRole(role: RoleType, tenantId: string) {
  // Load from .env.test or test database
  return {
    email: `${role}@${tenantId}.test`,
    password: process.env[`TEST_PASSWORD_${role.toUpperCase()}`] || 'Test123!@#',
  };
}
```

### Pattern 2: Multi-Tenant Isolation Testing
**What:** Use two mock municipalities to verify complete tenant isolation at database, API, and UI levels.
**When to use:** For all tests that access multi-tenant data (tickets, users, municipality configs)
**Example:**
```typescript
// tests/security/tenant-isolation.spec.ts
import { test, expect } from '../fixtures/auth';

test.describe('Multi-tenant isolation', () => {
  test('Manager from Jozi cannot see Pretoria tickets', async ({ browser }) => {
    // Create two authenticated contexts for different tenants
    const joziContext = await browser.newContext({
      storageState: '.auth/manager-test-jozi-001.json'
    });
    const pretoriaContext = await browser.newContext({
      storageState: '.auth/manager-test-pretoria-001.json'
    });

    const joziPage = await joziContext.newPage();
    const pretoriaPage = await pretoriaContext.newPage();

    // Pretoria manager creates a ticket
    await pretoriaPage.goto('http://localhost:5174/dashboard');
    const pretoriaTicketId = await createTicket(pretoriaPage, {
      category: 'Pothole',
      description: 'Pretoria-specific pothole',
    });

    // Jozi manager tries to access Pretoria ticket via URL manipulation
    await joziPage.goto(`http://localhost:5174/tickets/${pretoriaTicketId}`);

    // Should see 403 Forbidden or redirect to dashboard
    await expect(joziPage.locator('text=Access Denied')).toBeVisible();
    // OR
    await expect(joziPage).toHaveURL(/\/dashboard/);

    await joziContext.close();
    await pretoriaContext.close();
  });
});
```

### Pattern 3: GBV Privacy Firewall Testing
**What:** Verify GBV data is invisible to unauthorized roles at all layers (UI, API, database).
**When to use:** For all GBV-related security tests
**Example:**
```typescript
// tests/public/gbv-privacy.spec.ts
import { test, expect } from '../fixtures/auth';

test.describe('GBV privacy firewall', () => {
  let gbvReportId: string;

  test.beforeAll(async ({ browser }) => {
    // Citizen submits GBV report
    const citizenContext = await browser.newContext({ storageState: '.auth/citizen-test-jozi-001.json' });
    const page = await citizenContext.newPage();
    await page.goto('http://localhost:5173/report');

    // Select GBV category (triggers consent dialog)
    await page.selectOption('select#category', 'GBV/Abuse');
    await page.click('button:has-text("I Understand and Consent")');

    // Fill form
    await page.fill('textarea#description', 'GBV incident requiring SAPS intervention');
    await page.fill('input#manual-address', '123 Test Street, Johannesburg');

    // Submit and capture tracking number
    await page.click('button[type="submit"]');
    await page.waitForSelector('[data-testid="receipt-tracking-number"]');
    gbvReportId = await page.locator('[data-testid="receipt-tracking-number"]').textContent();

    await citizenContext.close();
  });

  test('Manager cannot see GBV report in ticket list', async ({ managerPage }) => {
    await managerPage.goto('http://localhost:5174/tickets');

    // Search for GBV tracking number
    await managerPage.fill('input[placeholder*="Search"]', gbvReportId);
    await managerPage.press('input[placeholder*="Search"]', 'Enter');

    // Should return empty results
    await expect(managerPage.locator('text=No tickets found')).toBeVisible();
    await expect(managerPage.locator(`text=${gbvReportId}`)).not.toBeVisible();
  });

  test('Manager cannot access GBV report via direct URL', async ({ managerPage }) => {
    await managerPage.goto(`http://localhost:5174/tickets/${gbvReportId}`);

    // Should see 403 or redirect
    await expect(managerPage.locator('text=Access Denied')).toBeVisible();
  });

  test('SAPS liaison CAN see GBV report', async ({ sapsLiaisonPage }) => {
    await sapsLiaisonPage.goto('http://localhost:5174/tickets');

    // Filter to GBV reports (should have GBV-specific filter)
    await sapsLiaisonPage.click('button:has-text("GBV Reports")');

    // Should see the report
    await expect(sapsLiaisonPage.locator(`text=${gbvReportId}`)).toBeVisible();
  });

  test('Admin CAN see GBV report', async ({ adminPage }) => {
    await adminPage.goto('http://localhost:5174/tickets');
    await adminPage.fill('input[placeholder*="Search"]', gbvReportId);

    // Admin has full access
    await expect(adminPage.locator(`text=${gbvReportId}`)).toBeVisible();
  });
});
```

### Pattern 4: OWASP Security Testing with ZAP Integration
**What:** Run automated security scans during E2E test execution to detect OWASP Top 10 vulnerabilities.
**When to use:** For all authentication, authorization, and data submission flows
**Example:**
```typescript
// tests/security/authentication.spec.ts
import { test, expect } from '@playwright/test';
import { ZapClient } from '../utils/security-scanner';

test.describe('OWASP authentication security', () => {
  let zapClient: ZapClient;

  test.beforeAll(async () => {
    zapClient = new ZapClient('http://localhost:8080'); // ZAP proxy
    await zapClient.newSession('salga-auth-tests');
  });

  test.afterAll(async () => {
    const report = await zapClient.generateReport();
    // Fail if high-severity vulnerabilities found
    expect(report.highAlerts.length).toBe(0);
  });

  test('Login form is protected against SQL injection', async ({ page }) => {
    await page.goto('http://localhost:5173/login');

    // Attempt SQL injection in email field
    const sqlPayloads = [
      "' OR '1'='1",
      "admin'--",
      "' OR 1=1--",
      "'; DROP TABLE users--",
    ];

    for (const payload of sqlPayloads) {
      await page.fill('[id="email"]', payload);
      await page.fill('[id="password"]', 'anything');
      await page.click('button[type="submit"]');

      // Should see login error, not server error
      await expect(page.locator('text=Invalid credentials')).toBeVisible();
      await expect(page.locator('text=500')).not.toBeVisible();
    }
  });

  test('Session tokens are HttpOnly and Secure', async ({ page, context }) => {
    await page.goto('http://localhost:5173/login');
    await page.fill('[id="email"]', 'citizen@test-jozi-001.test');
    await page.fill('[id="password"]', process.env.TEST_PASSWORD_CITIZEN!);
    await page.click('button[type="submit"]');
    await page.waitForURL(/profile|dashboard/);

    // Check Supabase auth cookies
    const cookies = await context.cookies();
    const authCookie = cookies.find(c => c.name.includes('auth-token') || c.name.includes('sb-'));

    expect(authCookie?.httpOnly).toBeTruthy();
    expect(authCookie?.secure).toBeTruthy();
    expect(authCookie?.sameSite).toBe('Lax');
  });

  test('Rate limiting prevents brute force attacks', async ({ page }) => {
    await page.goto('http://localhost:5173/login');

    // Attempt 20 failed logins
    for (let i = 0; i < 20; i++) {
      await page.fill('[id="email"]', 'test@example.com');
      await page.fill('[id="password"]', `wrong-password-${i}`);
      await page.click('button[type="submit"]');
      await page.waitForTimeout(100);
    }

    // Should see rate limit error
    await expect(page.locator('text=/too many|rate limit|slow down/i')).toBeVisible();
  });
});
```

### Pattern 5: Test Data Generation with Faker
**What:** Generate realistic, unique test data for each test run to avoid data collisions.
**When to use:** For all tests creating users, reports, or municipalities
**Example:**
```typescript
// fixtures/test-data.ts
import { faker } from '@faker-js/faker';

export function generateCitizenData(tenantId: string = 'test-jozi-001') {
  return {
    email: faker.internet.email().toLowerCase(),
    password: 'Test123!@#', // Standard test password
    phone: '+27' + faker.string.numeric(9),
    firstName: faker.person.firstName(),
    lastName: faker.person.lastName(),
    address: `${faker.location.streetAddress()}, Johannesburg, 2000`,
    tenantId,
  };
}

export function generateReportData(category: string = 'Pothole') {
  return {
    category,
    description: faker.lorem.sentences(2),
    address: `${faker.location.streetAddress()}, ${faker.location.city()}, ${faker.location.zipCode()}`,
    latitude: parseFloat(faker.location.latitude({ min: -26.3, max: -26.1 })), // Johannesburg bounds
    longitude: parseFloat(faker.location.longitude({ min: 27.9, max: 28.1 })),
  };
}

export function generateMunicipalityData() {
  return {
    municipalityName: `Test Municipality ${faker.string.alphanumeric(6)}`,
    province: faker.helpers.arrayElement([
      'Gauteng', 'Western Cape', 'KwaZulu-Natal'
    ]),
    municipalityCode: 'MUN' + faker.string.numeric(4),
    contactName: faker.person.fullName(),
    contactEmail: faker.internet.email().toLowerCase(),
    contactPhone: '+27' + faker.string.numeric(9),
  };
}

// Usage in tests:
test('Citizen can submit report', async ({ citizenPage }) => {
  const reportData = generateReportData('Water Leak');

  await citizenPage.goto('http://localhost:5173/report');
  await citizenPage.selectOption('select#category', reportData.category);
  await citizenPage.fill('textarea#description', reportData.description);
  await citizenPage.fill('input#manual-address', reportData.address);
  await citizenPage.click('button[type="submit"]');

  await expect(citizenPage.locator('[data-testid="receipt-tracking-number"]')).toBeVisible();
});
```

### Anti-Patterns to Avoid
- **Hard-coded credentials in test files:** Always use environment variables or test fixtures
- **Shared test data across tests:** Each test should generate unique data to avoid race conditions
- **Testing in production:** Use dedicated test tenants/municipalities (Jozi Municipal Test, Pretoria Test)
- **Ignoring async operations:** Always use Playwright's auto-wait or explicit waits, never setTimeout
- **Screenshot-based assertions:** Use accessibility tree and DOM assertions, not pixel matching
- **Skipping cleanup:** Always clean up test data, even on failure (use afterEach/afterAll hooks)

## Don't Hand-Roll

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Browser automation | Custom Selenium wrapper | Playwright with @playwright/test | Auto-wait, modern selectors, parallel execution, better debugging |
| Test data generation | Random string generators | @faker-js/faker | Realistic data, localization support, edge cases covered |
| Authentication state | Manual cookie management | Playwright storageState API | Handles Supabase session tokens, localStorage, cookies automatically |
| Security scanning | Custom vulnerability checks | playwright-zap + OWASP ZAP | OWASP Top 10 coverage, passive + active scanning, industry standard |
| Test parallelization | Custom worker pool | Playwright Test built-in workers | Optimal performance, test isolation, shard support for CI |
| Visual regression | Custom screenshot diff | @playwright/test screenshots + Percy/Argos | Baseline management, CI integration, diff highlighting |
| Page interactions | Direct DOM manipulation | Playwright Page Object Model | Maintainability, reusability, type safety |
| Test reporting | Custom HTML generator | Playwright HTML Reporter | Built-in trace viewer, screenshot on failure, video recording |

**Key insight:** Browser automation has complex edge cases (race conditions, dynamic content, network timing, cross-browser differences). Playwright solves these with auto-wait, smart retries, and accessibility-first selectors. Custom solutions miss these subtleties and break under real-world conditions.

## Common Pitfalls

### Pitfall 1: Flaky Tests Due to Race Conditions
**What goes wrong:** Tests randomly fail when page elements aren't ready, network requests are slow, or animations haven't completed.
**Why it happens:** Manual waits (`setTimeout`) or incorrect assumption that page is ready after navigation.
**How to avoid:** Use Playwright's auto-wait and explicit state assertions.
**Warning signs:** Tests pass locally but fail in CI, intermittent failures, "Element not found" errors.
**Example:**
```typescript
// BAD: Manual wait
await page.click('button#submit');
await page.waitForTimeout(2000); // Fragile!
await expect(page.locator('.success-message')).toBeVisible();

// GOOD: Explicit assertion with auto-wait
await page.click('button#submit');
await expect(page.locator('.success-message')).toBeVisible(); // Auto-waits up to 5s
```

### Pitfall 2: Test Data Pollution Across Tests
**What goes wrong:** Tests fail when run in parallel or in different order because they share data (same email, same tracking number).
**Why it happens:** Hard-coded test data or reusing data without cleanup.
**How to avoid:** Generate unique data per test, use `test.beforeEach` for setup and `test.afterEach` for cleanup.
**Warning signs:** Tests pass individually but fail when run in suite, "User already exists" errors, data conflicts.
**Example:**
```typescript
// BAD: Shared data
const TEST_EMAIL = 'test@example.com'; // Collision in parallel tests!

// GOOD: Unique data per test
test('User can register', async ({ page }) => {
  const email = `test-${Date.now()}@example.com`;
  // Or use faker:
  const email = faker.internet.email();

  await page.goto('http://localhost:5173/register');
  await page.fill('[id="email"]', email);
  // ...
});
```

### Pitfall 3: Insufficient Multi-Tenant Isolation Testing
**What goes wrong:** Tests verify functionality works but don't verify tenant boundaries are enforced, leading to data leakage in production.
**Why it happens:** Tests focus on happy path, not security edge cases.
**How to avoid:** Explicitly test cross-tenant access attempts, use negative assertions (expect NOT to see data).
**Warning signs:** Tenant isolation bugs found in production, no tests explicitly verify 403 errors, tests only use single tenant.
**Example:**
```typescript
// BAD: Only tests single tenant
test('Manager can view tickets', async ({ managerPage }) => {
  await managerPage.goto('http://localhost:5174/tickets');
  await expect(managerPage.locator('.ticket-row')).toHaveCount(5);
});

// GOOD: Tests cross-tenant isolation
test('Jozi manager cannot see Pretoria tickets', async ({ browser }) => {
  const joziManager = await getAuthenticatedPage(browser, 'manager', 'test-jozi-001');
  const pretoriaManager = await getAuthenticatedPage(browser, 'manager', 'test-pretoria-001');

  // Pretoria creates ticket
  await pretoriaManager.goto('http://localhost:5174/tickets/new');
  const ticketId = await createTicket(pretoriaManager);

  // Jozi tries to access it
  await joziManager.goto(`http://localhost:5174/tickets/${ticketId}`);
  await expect(joziManager.locator('text=Access Denied')).toBeVisible();
});
```

### Pitfall 4: Missing GBV Privacy Verification
**What goes wrong:** GBV reports leak to unauthorized roles because tests don't verify firewall at all layers (UI, API, database).
**Why it happens:** Tests assume backend enforcement works without verification, UI-only assertions miss API bypass attacks.
**How to avoid:** Test GBV visibility at UI, API (direct fetch), and URL manipulation levels for each role.
**Warning signs:** GBV tests only verify SAPS liaison can see data, no tests for manager/field_worker CANNOT see data.
**Example:**
```typescript
// BAD: Only positive test
test('SAPS liaison can see GBV reports', async ({ sapsLiaisonPage }) => {
  await sapsLiaisonPage.goto('http://localhost:5174/gbv-reports');
  await expect(sapsLiaisonPage.locator('.gbv-report')).toBeVisible();
});

// GOOD: Negative tests for all unauthorized roles
test.describe('GBV privacy firewall', () => {
  test('Manager CANNOT see GBV in UI', async ({ managerPage }) => {
    await managerPage.goto('http://localhost:5174/tickets');
    await expect(managerPage.locator('text=GBV/Abuse')).not.toBeVisible();
  });

  test('Manager CANNOT fetch GBV via API', async ({ managerPage }) => {
    const response = await managerPage.request.get('http://localhost:8000/api/v1/tickets?category=GBV');
    expect(response.status()).toBe(403);
  });

  test('Field worker CANNOT access GBV via URL manipulation', async ({ page }) => {
    // Assume we know a GBV ticket ID
    await page.goto(`http://localhost:5174/tickets/${gbvTicketId}`);
    await expect(page.locator('text=Access Denied')).toBeVisible();
  });
});
```

### Pitfall 5: Skipping OWASP Security Tests
**What goes wrong:** Application vulnerable to common attacks (XSS, CSRF, SQL injection) because functional tests don't cover security.
**Why it happens:** Security testing treated as separate phase, not integrated into E2E suite.
**How to avoid:** Integrate OWASP ZAP scanning in CI pipeline, add specific security test cases for auth/authz/input validation.
**Warning signs:** No security tests in suite, ZAP never runs, tests don't verify 403/401 responses.
**Example:**
```typescript
// Add to test suite:
test.describe('OWASP security tests', () => {
  test('XSS protection on report description', async ({ page }) => {
    await page.goto('http://localhost:5173/report');
    await page.fill('textarea#description', '<script>alert("XSS")</script>');
    await page.click('button[type="submit"]');

    // Should be escaped in receipt
    await expect(page.locator('text=<script>')).toBeVisible(); // Literal text, not executed
    await page.waitForTimeout(1000);
    await expect(page.locator('dialog')).not.toBeVisible(); // No alert dialog
  });

  test('CSRF protection on sensitive actions', async ({ page, context }) => {
    // Get CSRF token from login
    await page.goto('http://localhost:5173/login');
    // ... login ...

    // Try direct POST without CSRF token
    const response = await context.request.post('http://localhost:8000/api/v1/tickets', {
      data: { category: 'Pothole', description: 'Test' },
      headers: { 'Authorization': 'Bearer fake-token' }
    });

    expect(response.status()).toBe(403); // Should reject
  });
});
```

### Pitfall 6: Not Testing Onboarding Wizard State Persistence
**What goes wrong:** Users lose progress when refreshing page during onboarding, leading to frustration and abandoned setups.
**Why it happens:** Tests only verify happy path (complete wizard without interruption).
**How to avoid:** Test page refresh/navigation at each wizard step, verify data persists to backend and localStorage.
**Warning signs:** Onboarding tests only go start-to-finish, no tests for partial completion, no refresh/back button tests.
**Example:**
```typescript
test('Onboarding progress persists after page refresh', async ({ adminPage }) => {
  await adminPage.goto('http://localhost:5174/onboarding');

  // Complete step 1 (profile)
  await adminPage.fill('[name="municipalityName"]', 'Test Municipality');
  await adminPage.fill('[name="contactEmail"]', 'admin@test.com');
  await adminPage.click('button:has-text("Next")');

  // Refresh page
  await adminPage.reload();

  // Should resume at step 2 (team), with step 1 data preserved
  await expect(adminPage.locator('text=Invite Team Members')).toBeVisible();
  await adminPage.click('button:has-text("Back")');

  // Step 1 data should be pre-filled
  await expect(adminPage.locator('[name="municipalityName"]')).toHaveValue('Test Municipality');
});
```

## Code Examples

Verified patterns from official sources:

### Authentication with Storage State
```typescript
// fixtures/auth.ts
// Source: https://playwright.dev/docs/auth
import { test as base } from '@playwright/test';
import { supabase } from './supabase-test-client';

export const test = base.extend({
  storageState: async ({ browser }, use) => {
    const context = await browser.newContext();
    const page = await context.newPage();

    // Perform authentication
    await page.goto('http://localhost:5173/login');
    await page.fill('[id="email"]', 'test@example.com');
    await page.fill('[id="password"]', process.env.TEST_PASSWORD!);
    await page.click('button[type="submit"]');
    await page.waitForURL(/profile|dashboard/);

    // Save signed-in state
    const storageState = await context.storageState({ path: '.auth/user.json' });
    await context.close();

    await use(storageState);
  },
});
```

### Multi-Browser Testing with Parallel Workers
```typescript
// playwright.config.ts
// Source: https://playwright.dev/docs/api/class-fixtures
import { defineConfig, devices } from '@playwright/test';

export default defineConfig({
  testDir: './tests',
  fullyParallel: true,
  workers: process.env.CI ? 2 : 4,
  retries: process.env.CI ? 2 : 0,

  use: {
    baseURL: process.env.BASE_URL || 'http://localhost:5173',
    trace: 'on-first-retry',
    screenshot: 'only-on-failure',
    video: 'retain-on-failure',
  },

  projects: [
    // Setup project for authentication
    { name: 'setup', testMatch: /.*\.setup\.ts/ },

    // Public dashboard tests
    {
      name: 'public-chromium',
      use: { ...devices['Desktop Chrome'], baseURL: 'http://localhost:5173' },
      dependencies: ['setup'],
    },
    {
      name: 'public-firefox',
      use: { ...devices['Desktop Firefox'], baseURL: 'http://localhost:5173' },
      dependencies: ['setup'],
    },

    // Municipal dashboard tests
    {
      name: 'dashboard-chromium',
      use: { ...devices['Desktop Chrome'], baseURL: 'http://localhost:5174' },
      dependencies: ['setup'],
    },

    // Mobile tests (citizen portal)
    {
      name: 'mobile-chrome',
      use: { ...devices['Pixel 5'], baseURL: 'http://localhost:5173' },
      dependencies: ['setup'],
    },
  ],

  webServer: [
    {
      command: 'cd frontend-public && npm run dev',
      port: 5173,
      reuseExistingServer: !process.env.CI,
    },
    {
      command: 'cd frontend-dashboard && npm run dev',
      port: 5174,
      reuseExistingServer: !process.env.CI,
    },
  ],
});
```

### Page Object Model Pattern
```typescript
// fixtures/page-objects/public/LoginPage.ts
// Source: Playwright best practices (https://www.browserstack.com/guide/playwright-best-practices)
import { Page, Locator } from '@playwright/test';

export class LoginPage {
  readonly page: Page;
  readonly emailInput: Locator;
  readonly passwordInput: Locator;
  readonly submitButton: Locator;
  readonly errorMessage: Locator;
  readonly phoneTab: Locator;
  readonly phoneInput: Locator;
  readonly otpInput: Locator;

  constructor(page: Page) {
    this.page = page;
    this.emailInput = page.locator('[id="email"]');
    this.passwordInput = page.locator('[id="password"]');
    this.submitButton = page.locator('button[type="submit"]');
    this.errorMessage = page.locator('[role="alert"]');
    this.phoneTab = page.locator('button:has-text("Sign in with Phone OTP")');
    this.phoneInput = page.locator('[id="phone"]');
    this.otpInput = page.locator('[id="otp"]');
  }

  async goto() {
    await this.page.goto('/login');
  }

  async loginWithEmail(email: string, password: string) {
    await this.emailInput.fill(email);
    await this.passwordInput.fill(password);
    await this.submitButton.click();
    await this.page.waitForURL(/profile|dashboard/);
  }

  async loginWithPhone(phone: string, otp: string) {
    await this.phoneTab.click();
    await this.phoneInput.fill(phone);
    await this.submitButton.click();
    await this.otpInput.waitFor();
    await this.otpInput.fill(otp);
    await this.submitButton.click();
    await this.page.waitForURL(/profile|dashboard/);
  }

  async getErrorMessage() {
    return await this.errorMessage.textContent();
  }
}
```

### OWASP ZAP Integration
```typescript
// utils/security-scanner.ts
// Source: https://medium.com/@sirigirivijay123/fortify-your-tests-automated-security-testing-with-playwright-owasp-zap-ef45342efd63
import { ZapClient as ZapClientBase } from 'playwright-zap';

export class ZapClient {
  private client: ZapClientBase;

  constructor(zapUrl: string = 'http://localhost:8080') {
    this.client = new ZapClientBase(zapUrl);
  }

  async newSession(name: string) {
    await this.client.core.newSession({ name });
  }

  async setContext(contextName: string, urls: string[]) {
    await this.client.context.newContext({ contextname: contextName });
    for (const url of urls) {
      await this.client.context.includeInContext({
        contextname: contextName,
        regex: url
      });
    }
  }

  async runActiveScan(url: string) {
    const { scan } = await this.client.ascan.scan({ url });

    // Poll until scan complete
    let status = 0;
    while (status < 100) {
      await new Promise(resolve => setTimeout(resolve, 5000));
      const { status: currentStatus } = await this.client.ascan.status({ scanid: scan });
      status = parseInt(currentStatus);
    }
  }

  async generateReport() {
    const alerts = await this.client.core.alerts();

    const highAlerts = alerts.filter((a: any) => a.risk === 'High');
    const mediumAlerts = alerts.filter((a: any) => a.risk === 'Medium');
    const lowAlerts = alerts.filter((a: any) => a.risk === 'Low');

    return {
      highAlerts,
      mediumAlerts,
      lowAlerts,
      totalAlerts: alerts.length,
    };
  }
}

// Usage in test:
test.describe('Security scan', () => {
  let zapClient: ZapClient;

  test.beforeAll(async () => {
    zapClient = new ZapClient();
    await zapClient.newSession('salga-security-scan');
    await zapClient.setContext('salga', [
      'http://localhost:5173/.*',
      'http://localhost:5174/.*',
    ]);
  });

  test('Run full security scan', async ({ page }) => {
    // Navigate through app to build sitemap
    await page.goto('http://localhost:5173');
    await page.goto('http://localhost:5173/login');
    await page.goto('http://localhost:5173/register');

    // Run active scan
    await zapClient.runActiveScan('http://localhost:5173');

    // Get report
    const report = await zapClient.generateReport();

    // Assert no high-severity vulnerabilities
    expect(report.highAlerts.length).toBe(0);
  });
});
```

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| Selenium WebDriver | Playwright | 2020-2024 | Auto-wait, modern selectors, faster execution, better debugging |
| Manual test writing | AI-powered test generation (Playwright Test Agents) | 2025-2026 | 60-80% faster test creation, but requires human review |
| Screenshot-based automation | Accessibility tree automation (Playwright MCP) | 2025-2026 | 10x faster, LLM-friendly, no vision models needed |
| Separate security testing | Integrated OWASP ZAP in E2E pipeline | 2024-2026 | Security issues caught earlier, DevSecOps alignment |
| Re-authenticate per test | Storage state reuse | 2021-present | 60-80% faster test execution |
| Single browser testing | Multi-browser parallel execution | 2020-present | Cross-browser coverage with same test code |
| Hard-coded test data | Faker.js + dynamic generation | 2023-present | No data collisions, parallel-safe tests |

**Deprecated/outdated:**
- **Selenium WebDriver (pre-2020):** Replaced by Playwright for modern web apps (slower, less reliable auto-wait)
- **Puppeteer-only testing:** Chromium-only; Playwright supports Chromium, Firefox, WebKit
- **Cypress for multi-domain testing:** Cannot test across domains (citizen portal → municipal dashboard); Playwright can
- **Manual ZAP proxy setup:** playwright-zap library automates integration
- **Test Cafe:** Slower than Playwright, less active development as of 2024

## Open Questions

1. **Database Seeding Strategy for Test Municipalities**
   - What we know: Tests need two mock municipalities ("Jozi Municipal Test", "Pretoria Test") with complete data isolation
   - What's unclear: Should we seed via SQL scripts, Supabase Admin API, or backend API endpoints? How to ensure clean state per test run?
   - Recommendation: Use Supabase Admin API in `global-setup.ts` to create test tenants, then truncate test data in `global-teardown.ts`. Document seeding in fixtures/db-setup.ts.

2. **Playwright MCP Server Configuration**
   - What we know: @playwright/mcp provides browser automation via MCP protocol for AI agents
   - What's unclear: Do we run MCP server locally during tests, or only for test generation phase? What's the best integration with Playwright Test?
   - Recommendation: Use MCP server only for initial test generation with Playwright Test Agents (Planner, Generator, Healer), then maintain generated tests manually. Not needed for test execution.

3. **Phone OTP Testing Without Real SMS**
   - What we know: Supabase Auth supports phone OTP, tests need to verify phone login flow
   - What's unclear: How to test OTP flow without sending real SMS (Twilio test mode, Supabase test OTP codes)?
   - Recommendation: Use Supabase test OTP codes in development mode (Supabase allows fixed OTP codes for testing). Document in .env.test with TEST_OTP_CODE=123456.

4. **CI/CD Pipeline Integration**
   - What we know: Tests should run on every PR, detect regressions before merge
   - What's unclear: Should we run full suite (10 profiles × all journeys) or subset? How to handle test parallelization in GitHub Actions?
   - Recommendation: Run smoke tests (critical paths only) on every commit, full suite nightly. Use Playwright sharding for parallel execution across 4 workers.

5. **Handling Animations in Tests**
   - What we know: Both dashboards use GSAP animations extensively (stagger entrances, page transitions)
   - What's unclear: Do animations cause flakiness? Should we disable them in tests?
   - Recommendation: Add `data-testid` attributes to key elements, use `expect(locator).toBeVisible()` which auto-waits for element stability. If flaky, add global CSS in test mode to disable animations: `* { animation-duration: 0s !important; transition-duration: 0s !important; }`.

6. **GBV Report Test Data**
   - What we know: GBV reports require special consent flow and have enhanced privacy
   - What's unclear: Should test GBV reports be flagged differently to avoid confusion with real data? How to ensure test GBV reports are cleaned up?
   - Recommendation: Use test-specific municipality codes (test-jozi-001) and add `is_test_data` flag to database. Clean up via `global-teardown.ts` that deletes all records with test tenant IDs.

7. **Accessibility Testing**
   - What we know: Playwright can run accessibility audits via axe-core integration
   - What's unclear: Should accessibility tests be part of this phase or separate?
   - Recommendation: Include basic accessibility smoke tests (no critical violations on key pages), defer comprehensive accessibility testing to separate phase. Use @axe-core/playwright for integration.

## Sources

### Primary (HIGH confidence)
- [Playwright Authentication Documentation](https://playwright.dev/docs/auth) - Official storage state patterns
- [Playwright Test Agents](https://playwright.dev/docs/test-agents) - Official AI-powered test generation
- [Microsoft Playwright MCP GitHub](https://github.com/microsoft/playwright-mcp) - Official MCP server implementation
- [Playwright Fixtures Documentation](https://playwright.dev/docs/api/class-fixtures) - Official fixtures API

### Secondary (MEDIUM confidence)
- [Playwright MCP: A Modern Guide to Test Automation](https://testomat.io/blog/playwright-mcp-modern-test-automation-from-zero-to-hero/) - 2026 patterns and best practices
- [Playwright MCP Explained: AI-Powered Test Automation 2026](https://www.testleaf.com/blog/playwright-mcp-ai-test-automation-2026/) - MCP architecture overview
- [6 most popular Playwright MCP servers for AI testing in 2026](https://bug0.com/blog/playwright-mcp-servers-ai-testing) - MCP server comparison
- [Playwright Auth Security Testing: Complete How To Guide](https://software-testing-tutorials-automation.com/2025/12/playwright-auth-security-testing.html) - Authentication security patterns
- [Fortify Your Tests: Automated Security Testing with Playwright & OWASP ZAP](https://medium.com/@sirigirivijay123/fortify-your-tests-automated-security-testing-with-playwright-owasp-zap-ef45342efd63) - OWASP ZAP integration
- [Using Playwright's storageState](https://www.browserstack.com/guide/playwright-storage-state) - Session persistence patterns
- [15 Best Practices for Playwright testing in 2026](https://www.browserstack.com/guide/playwright-best-practices) - Current best practices
- [Test Data Strategies for E2E Tests](https://www.playwright-user-event.org/playwright-tips/test-data-strategies-for-e2e-tests) - Test data generation patterns
- [Securing the App with Playwright: Integrating Security into Functional Tests](https://medium.com/@athy1988/securing-the-app-with-playwright-integrating-security-into-functional-tests-067757726c4c) - Security testing patterns

### Tertiary (LOW confidence - verify before use)
- [Playwright MCP Changes the Build vs. Buy Equation for AI Testing in 2026](https://bug0.com/blog/playwright-mcp-changes-ai-testing-2026) - Market analysis
- [The Ultimate Guide to Playwright MCP](https://testdino.com/blog/playwright-mcp/) - Tutorial guide
- [Generative Automation Testing with Playwright MCP Server](https://adequatica.medium.com/generative-automation-testing-with-playwright-mcp-server-45e9b8f6f92a) - AI test generation approach

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH - Official Playwright packages, well-documented patterns
- Architecture: MEDIUM-HIGH - Patterns verified from official docs and 2026 sources, but project-specific structure is proposed
- Pitfalls: HIGH - Common issues documented in official Playwright guides and community best practices
- GBV testing patterns: MEDIUM - No direct precedent found, adapted from general security/privacy testing patterns
- OWASP integration: MEDIUM - ZAP integration documented but not as mature as functional testing patterns
- MCP server usage: MEDIUM - New technology (2025-2026), patterns still emerging

**Research date:** 2026-02-14
**Valid until:** 30 days (stable technology, but MCP patterns evolving rapidly in 2026)
