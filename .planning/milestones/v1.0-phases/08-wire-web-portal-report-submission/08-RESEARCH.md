# Phase 08: Wire Web Portal Report Submission - Research

**Researched:** 2026-02-22
**Domain:** Frontend-to-backend API wiring, PostGIS GPS integration, GBV encryption flow
**Confidence:** HIGH (all findings based on direct codebase inspection)

---

<phase_requirements>
## Phase Requirements

| ID | Description | Research Support |
|----|-------------|-----------------|
| RPT-02 | Citizen can report service issues via web portal | Wire `handleSubmit()` in `ReportIssuePage.tsx` to `POST /api/v1/reports/submit` with Supabase auth token |
| RPT-03 | Citizen can upload photos with report for visual evidence | File IDs from Supabase Storage uploads must be passed in `media_file_ids` array at submit time; backend links them to the created ticket |
| RPT-04 | System captures GPS geolocation automatically (with manual address fallback) | GPS coords are already captured by the frontend; backend must receive them as `LocationData` and store as PostGIS WKT point |
| RPT-05 | Citizen receives unique tracking number for each report | Tracking number is generated by `generate_tracking_number()` in reports.py and returned in `ReportSubmitResponse`; receipt must display the real number |
| RPT-06 | Citizen can report GBV/domestic violence/abuse as a dedicated category | `is_gbv` flag + category override already wired in backend; frontend must pass `is_gbv: true` in request body |
| RPT-08 | GBV report data stored with enhanced encryption and access controls | `EncryptedString` column type on `encrypted_description` already handles this; activated when a real ticket is created with `is_gbv=True` |
</phase_requirements>

---

## Summary

This phase closes the most critical gap in the v1.0 milestone: the web portal report submission path has never been connected end-to-end. The backend (`POST /api/v1/reports/submit`) is fully implemented and correct. The frontend (`ReportIssuePage.tsx`) has a `TODO` mock that generates a fake tracking number client-side — the real API is never called. All downstream requirements (RPT-03 through RPT-08) are blocked by this single wiring gap.

There are two additional bugs that must be fixed alongside the wiring: (1) `reports.py` passes `latitude=` and `longitude=` kwargs to the `Ticket()` constructor, but those are read-only `@property` members — the model has no columns by those names. GPS coordinates must be written as a WKT point string to the `location` column. (2) The frontend category display values (`"Water & Sanitation"`, `"Roads & Potholes"`, etc.) do not match the backend enum values (`"water"`, `"roads"`, etc.) — the mapping must be normalised at submit time in the frontend.

The test suite in `tests/test_reports_api.py` also references stale `IntakeFlow` mocks and outdated patterns; it needs to be updated to mock `ManagerCrew` instead.

**Primary recommendation:** Wire `ReportIssuePage.tsx` to call `POST /api/v1/reports/submit` using the Supabase session token, fix the PostGIS location bug in `reports.py`, map frontend category strings to backend enum values, and update the test file.

---

## Standard Stack

### Core (already in project — no new installs needed)

| Component | Location | Purpose | Status |
|-----------|----------|---------|--------|
| `supabase` JS client | `frontend-public/src/lib/supabase.ts` | Auth session + Storage uploads | Already imported in ReportIssuePage |
| `useAuth` hook | `frontend-public/src/hooks/useAuth.ts` → `AuthContext.tsx` | Exposes `session` with `access_token` | Available, provides `session.access_token` |
| `VITE_API_URL` env var | Used in `useCitizenReports.ts` | Backend URL | Pattern: `import.meta.env.VITE_API_URL \|\| 'http://localhost:8000'` |
| `EncryptedString` | `src/core/encryption.py` | Fernet symmetric encryption for GBV fields | Transparent via SQLAlchemy type |
| `generate_tracking_number()` | `src/models/ticket.py:66` | Creates `TKT-YYYYMMDD-{6hex}` format | Already called in reports.py submit handler |
| `ManagerCrew` | `src/agents/crews/manager_crew.py` | AI category classification when no category provided | Already imported and used in reports.py |
| `guardrails_engine` | `src/guardrails/engine.py` | Input sanitisation before ticket creation | Already wired in reports.py |

### Supporting

| Component | Location | Purpose | When to Use |
|-----------|----------|---------|-------------|
| `geoalchemy2.shape.from_shape` | optional import in routing_service | Build PostGIS Geometry from shapely Point | Use for setting `ticket.location` from lat/lng |
| `shapely.geometry.Point` | via geoalchemy2 dependency | Create point geometry | Used with `from_shape()` to write PostGIS location |
| `WKBElement` (geoalchemy2) | from_shape return type | Written to `ticket.location` | Alternative: use `text(f"ST_SetSRID(ST_MakePoint({lng}, {lat}), 4326)")` |

---

## Architecture Patterns

### Pattern 1: Frontend → Backend API Call with Supabase Auth Token

The established pattern in this codebase (from `useCitizenReports.ts`):

```typescript
// Source: frontend-public/src/hooks/useCitizenReports.ts:116-130
const { data: { session } } = await supabase.auth.getSession();
const token = session.access_token;
const apiUrl = import.meta.env.VITE_API_URL || 'http://localhost:8000';

const response = await fetch(`${apiUrl}/api/v1/reports/submit`, {
  method: 'POST',
  headers: {
    'Authorization': `Bearer ${token}`,
    'Content-Type': 'application/json',
  },
  body: JSON.stringify(payload),
});
```

**Key detail:** `useAuth()` exposes `session` directly, so `ReportIssuePage` already has access via `const { user, session } = useAuth()` — no need to call `supabase.auth.getSession()` again.

### Pattern 2: Request Body Shape (ReportSubmitRequest schema)

The backend Pydantic schema (`src/schemas/report.py`):

```python
class LocationData(BaseModel):
    latitude: float    # -90 to 90
    longitude: float   # -180 to 180
    accuracy: float    # GPS accuracy in meters (required!)
    source: str        # "gps" or "manual"

class ReportSubmitRequest(BaseModel):
    description: str           # min 10, max 5000 chars
    category: str | None       # None = AI classifies; "water"/"roads"/"electricity"/"waste"/"sanitation"/"gbv"/"other"
    location: LocationData | None
    manual_address: str | None  # max 500 chars
    media_file_ids: list[str]  # list of file_id UUIDs (not S3 paths)
    language: str              # "en"/"zu"/"af"
    is_gbv: bool               # True triggers GBV routing + encryption
    # CONSTRAINT: location OR manual_address required (model_validator)
```

**Important mismatches to fix in frontend:**
1. `location` needs `accuracy` field — use `position.coords.accuracy` from the Geolocation API
2. Frontend category display values must be mapped to backend enum values before sending:
   - `"Water & Sanitation"` → `"water"`
   - `"Roads & Potholes"` → `"roads"`
   - `"Electricity"` → `"electricity"`
   - `"Waste Management"` → `"waste"`
   - `"Public Safety"` → `"other"` (no direct mapping — closest is "other")
   - `"Housing"` → `"other"`
   - `"GBV/Abuse"` → `"gbv"` (or use `is_gbv: true` + omit category)
   - `"Other"` → `"other"`

### Pattern 3: PostGIS Location Bug Fix in reports.py

**The bug:** `reports.py` lines 149-150 pass `latitude=latitude, longitude=longitude` to `Ticket()`. These are `@property` members (read-only), not database columns. SQLAlchemy will raise an error or silently ignore them depending on strictness mode.

**The fix:** Use `from_shape` + `Point` to build the PostGIS WKBElement, or use raw SQL expression. The pattern from the migrations:

```python
# Option A: geoalchemy2 shape (same pattern as routing_service.py uses for reads)
from shapely.geometry import Point
from geoalchemy2.shape import from_shape

location_value = None
if latitude is not None and longitude is not None:
    location_value = from_shape(Point(longitude, latitude), srid=4326)
    # Note: PostGIS convention is Point(longitude, latitude) — x=lon, y=lat

ticket = Ticket(
    # ...
    location=location_value,   # <-- PostGIS WKBElement
    address=address,
    # ...
)
```

```python
# Option B: SQLAlchemy text expression (simpler, no shapely needed for writes)
from sqlalchemy import text

location_expr = None
if latitude is not None and longitude is not None:
    location_expr = text(f"ST_SetSRID(ST_MakePoint({longitude}, {latitude}), 4326)")
```

Option A is cleaner and consistent with geoalchemy2 usage already in the codebase. The `USE_POSTGIS` guard (from `os.getenv("USE_SQLITE_TESTS")`) must wrap this import exactly as done in `routing_service.py`.

### Pattern 4: GBV Encryption Flow (already correct, just needs activation)

```python
# From src/api/v1/reports.py:135-143 (already correct)
if category == "gbv" or report.is_gbv:
    encrypted_description = sanitized_description  # written to EncryptedString column
    ticket_description = "GBV incident report"     # public placeholder

ticket = Ticket(
    description=ticket_description,           # "GBV incident report" for GBV
    encrypted_description=encrypted_description,  # actual details encrypted via Fernet
    is_sensitive=True,
    ...
)
```

The `EncryptedString` TypeDecorator transparently encrypts on write and decrypts on read via `ENCRYPTION_KEY_CURRENT` env var. In dev mode (no key configured), it stores plaintext. No changes needed here — it just needs a real ticket to be created.

### Pattern 5: File ID Lifecycle (Upload-first, link-on-submit)

The frontend currently uploads files and stores `{ id: fileId, name, url }`. The `fileId` is a `crypto.randomUUID()` used as the storage path prefix. However, **the backend `media_file_ids` expects `file_id` values that match `MediaAttachment.file_id` records in the database** — not raw Supabase Storage paths.

The current upload handler creates a Supabase Storage file but does NOT create a `MediaAttachment` database record. The backend `submit_report` handler queries `MediaAttachment.file_id` to link media to the ticket.

**This is a gap within the gap.** Two approaches:
1. Create `MediaAttachment` records at upload time via `POST /api/v1/uploads` (if this endpoint exists)
2. Send `media_file_ids: []` in the submit request for now (skip media linking) and fix upload flow separately

Check upload endpoint:

```bash
grep -n "upload\|MediaAttachment" src/api/v1/uploads.py
```

### Pattern 6: Test Updates (IntakeFlow → ManagerCrew)

`tests/test_reports_api.py` line 121 patches `src.api.v1.reports.IntakeFlow` — but reports.py no longer imports `IntakeFlow`; it imports `ManagerCrew`. Tests that mock AI classification need to patch `src.api.v1.reports.ManagerCrew` instead:

```python
# OLD (stale - IntakeFlow no longer used)
with patch('src.api.v1.reports.IntakeFlow') as mock_flow_class:
    ...

# NEW - patch ManagerCrew.kickoff as AsyncMock
with patch('src.api.v1.reports.ManagerCrew') as mock_crew_class:
    mock_crew = MagicMock()
    mock_crew.kickoff = AsyncMock(return_value={"routing_phase": "municipal"})
    mock_crew_class.return_value = mock_crew
    ...
```

---

## Detailed Gap Analysis

### Gap 1: Frontend Mock Submit (CRITICAL — RPT-02, RPT-03, RPT-04, RPT-05, RPT-06)

**File:** `frontend-public/src/pages/ReportIssuePage.tsx:260-286`

```typescript
// Current (MOCK — never calls backend):
await new Promise((resolve) => setTimeout(resolve, 1500));
const trackingNumber = `TKT-${...mock...}`;
setReceiptData({ trackingNumber, category, description, ... });
```

**Fix:** Replace with real `fetch()` call to `POST /api/v1/reports/submit`.

The frontend has all the data it needs:
- `session.access_token` from `useAuth()` (add `session` to destructuring)
- `description` state (text description)
- `category` state (needs mapping to backend enum)
- `location` state (already has lat/lng, needs `accuracy` added)
- `manualAddress` state
- `uploadedFiles[].id` (but see Gap 3 below)
- `isGbv` state

### Gap 2: PostGIS Location Not Written (MEDIUM — RPT-04)

**File:** `src/api/v1/reports.py:144-160`

`Ticket(latitude=latitude, longitude=longitude, ...)` passes read-only properties. GPS coordinates are captured but never persisted to the PostGIS `location` column.

**Fix:** Build `from_shape(Point(longitude, latitude), srid=4326)` and assign to `location=` in Ticket constructor, with `USE_POSTGIS` guard matching the pattern in `routing_service.py`.

### Gap 3: Media Attachment Record Missing (MEDIUM — RPT-03)

**File:** `frontend-public/src/pages/ReportIssuePage.tsx:173-208` (photo upload handler)

Photos upload to Supabase Storage but no `MediaAttachment` DB record is created. Backend `submit_report` queries `MediaAttachment.file_id` — if no records exist, `media_file_ids` will result in a 404 error.

**Fix options:**
- **Option A:** Call `POST /api/v1/uploads/presign-or-register` (check if upload endpoint creates MediaAttachment records) during photo upload, get back a `file_id` to send at submit time
- **Option B:** For Phase 8, pass `media_file_ids: []` (skip linking) and note that photo linking requires upload endpoint to also create MediaAttachment records. Photos are already in storage, they just won't be linked to the ticket.

Check `src/api/v1/uploads.py` for the `POST /api/v1/uploads` endpoint to understand if it creates `MediaAttachment` records.

### Gap 4: Category String Mismatch (MEDIUM — RPT-02)

Frontend uses display strings (`"Water & Sanitation"`, `"Roads & Potholes"`); backend enum is lowercase short (`"water"`, `"roads"`). Backend validates and will return 400 if unrecognised value passed.

**Fix:** Frontend category mapping function before submit:
```typescript
const CATEGORY_MAP: Record<string, string> = {
  'Water & Sanitation': 'water',
  'Electricity': 'electricity',
  'Roads & Potholes': 'roads',
  'Waste Management': 'waste',
  'Public Safety': 'other',
  'Housing': 'other',
  'GBV/Abuse': 'gbv',
  'Other': 'other',
};
const backendCategory = CATEGORY_MAP[category] ?? 'other';
```

### Gap 5: GPS Accuracy Field Missing (LOW — RPT-04)

`LocationData` schema requires `accuracy: float` (validated as `gt=0`). Frontend `navigator.geolocation` provides `position.coords.accuracy`. The frontend does not currently store accuracy.

**Fix:** Add `accuracy` to `LocationData` interface and `captureLocation()` callback.

### Gap 6: Test Stale Mocks (LOW — test quality)

`tests/test_reports_api.py` lines 121, 154 patch `IntakeFlow` which no longer exists in `reports.py`. Tests that test the "no category" path will fail when run with real imports.

---

## Don't Hand-Roll

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| PostGIS point construction | Manual WKT string formatting | `from_shape(Point(lon, lat), srid=4326)` from geoalchemy2 | Handles coordinate ordering, SRID, binary format correctly |
| Auth token retrieval | localStorage token parsing | `session.access_token` from `useAuth()` | Supabase manages refresh automatically |
| File UUID generation | Custom ID generation | `crypto.randomUUID()` already used in upload handler | Already present in codebase |
| Encryption | Custom cipher | `EncryptedString` TypeDecorator already on model | Already configured with MultiFernet |

---

## Common Pitfalls

### Pitfall 1: PostGIS Coordinate Order
**What goes wrong:** `Point(latitude, longitude)` instead of `Point(longitude, latitude)`
**Why it happens:** Shapely uses `(x, y)` which maps to `(longitude, latitude)` in geographic coordinates
**How to avoid:** Always use `Point(longitude, latitude)` — longitude is x (east-west), latitude is y (north-south)
**Warning sign:** Tickets appear in ocean when viewed on map; routing service finds no nearby teams

### Pitfall 2: Missing accuracy in LocationData
**What goes wrong:** Backend returns 422 validation error because `accuracy` is required with `gt=0` constraint
**Why it happens:** `LocationData.accuracy` has no default and `gt=0` validation
**How to avoid:** Extract `position.coords.accuracy` in `captureLocation()` and include in state
**Warning sign:** 422 Unprocessable Entity response with `accuracy` in detail

### Pitfall 3: media_file_ids Lookup Fails with 404
**What goes wrong:** Passing Supabase Storage path UUIDs that have no `MediaAttachment` DB record
**Why it happens:** Upload creates storage file only; `submit_report` queries `MediaAttachment` table
**How to avoid:** Either call an upload registration endpoint before submit, or pass `[]` for now
**Warning sign:** 404 error with "Media files not found" in detail when submitting with photos

### Pitfall 4: Frontend Category Strings Rejected
**What goes wrong:** Backend returns 400 "Invalid category" because frontend sends `"Water & Sanitation"` not `"water"`
**Why it happens:** No normalisation layer between UI display strings and API enum values
**How to avoid:** Apply CATEGORY_MAP before building request body
**Warning sign:** 400 error with "Invalid category" in detail

### Pitfall 5: USE_POSTGIS Guard Missing in reports.py
**What goes wrong:** `from shapely.geometry import Point` and `from geoalchemy2.shape import from_shape` fail in SQLite test mode
**Why it happens:** geoalchemy2 not available when `USE_SQLITE_TESTS=1`
**How to avoid:** Wrap the location assignment in `if USE_POSTGIS:` exactly as done in `routing_service.py`
**Warning sign:** `ImportError: No module named 'geoalchemy2'` in unit tests

### Pitfall 6: Ticket Constructor with Removed lat/lng kwargs
**What goes wrong:** SQLAlchemy may raise `InvalidRequestError` or silently ignore `latitude=`, `longitude=` kwargs on the Ticket model (they are `@property` not `Mapped` columns)
**Why it happens:** reports.py was written before Phase 4 migrated to PostGIS
**How to avoid:** Remove `latitude=`, `longitude=` from Ticket() call; add `location=location_value`

### Pitfall 7: /api/v1/reports/my Route Order Conflict
**What goes wrong:** FastAPI route `/reports/my` may conflict with `/reports/{tracking_number}` if ordering is wrong
**Why it happens:** FastAPI matches routes in order; `{tracking_number}` is a path param that could capture "my"
**How to avoid:** The current `reports.py` already defines `/my` AFTER `/{tracking_number}` — but the `/my` endpoint should be moved BEFORE `/{tracking_number}`. Check current order.
**Warning sign:** GET /api/v1/reports/my returns "Report my not found" (404)

---

## Code Examples

### Complete handleSubmit Replacement (frontend-public/src/pages/ReportIssuePage.tsx)

```typescript
// Source: pattern from useCitizenReports.ts + ReportSubmitRequest schema
const handleSubmit = async (e: React.FormEvent) => {
  e.preventDefault();
  setError(null);

  // Validation (same as current)
  if (!category) { setError('Please select a category'); return; }
  if (description.length < 20) { setError('Description must be at least 20 characters'); return; }
  if (!location && !manualAddress) { setError('Please capture your location or enter an address manually'); return; }
  if (!isResidenceVerified) { setError('You must verify your proof of residence before submitting a report'); return; }

  setIsSubmitting(true);

  try {
    const apiUrl = import.meta.env.VITE_API_URL || 'http://localhost:8000';

    // Map display category to backend enum
    const CATEGORY_MAP: Record<string, string> = {
      'Water & Sanitation': 'water',
      'Electricity': 'electricity',
      'Roads & Potholes': 'roads',
      'Waste Management': 'waste',
      'Public Safety': 'other',
      'Housing': 'other',
      'GBV/Abuse': 'gbv',
      'Other': 'other',
    };
    const backendCategory = isGbv ? 'gbv' : (CATEGORY_MAP[category] ?? 'other');

    const payload = {
      description,
      category: backendCategory,
      location: location ? {
        latitude: location.latitude,
        longitude: location.longitude,
        accuracy: location.accuracy,  // Need to add accuracy to LocationData state
        source: 'gps',
      } : null,
      manual_address: manualAddress || null,
      media_file_ids: [],  // Phase 8: skip media linking (photos in storage but not linked)
      language: 'en',
      is_gbv: isGbv,
    };

    const { data: { session } } = await supabase.auth.getSession();
    if (!session) throw new Error('Not authenticated');

    const response = await fetch(`${apiUrl}/api/v1/reports/submit`, {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${session.access_token}`,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(payload),
    });

    if (!response.ok) {
      const errorData = await response.json();
      throw new Error(errorData.detail || `Submit failed: ${response.statusText}`);
    }

    const data = await response.json();

    setReceiptData({
      trackingNumber: data.tracking_number,  // Real tracking number from backend
      category,
      description,
      expectedResponseTime: getExpectedResponseTime(category),
    });
    setPageState('receipt');

    // Reset form
    setCategory(''); setDescription(''); setLocation(null);
    setManualAddress(''); setUploadedFiles([]); setIsGbv(false);

  } catch (error) {
    console.error('[ReportIssuePage] Submit failed:', error);
    setError(error instanceof Error ? error.message : 'Failed to submit report');
  } finally {
    setIsSubmitting(false);
  }
};
```

### PostGIS Location Fix (src/api/v1/reports.py)

```python
# Source: routing_service.py pattern (geoalchemy2.shape.from_shape)
import os
USE_POSTGIS = os.getenv("USE_SQLITE_TESTS") != "1"
if USE_POSTGIS:
    try:
        from shapely.geometry import Point
        from geoalchemy2.shape import from_shape
    except ImportError:
        USE_POSTGIS = False

# In submit_report():
# Step 3: Extract location data
location_value = None
address = report.manual_address

if report.location:
    lat = report.location.latitude
    lng = report.location.longitude
    if USE_POSTGIS:
        location_value = from_shape(Point(lng, lat), srid=4326)  # Note: Point(lon, lat)
    if not address:
        address = f"{lat}, {lng}"

ticket = Ticket(
    tracking_number=tracking_number,
    category=category,
    description=ticket_description,
    encrypted_description=encrypted_description,
    location=location_value,   # PostGIS WKBElement or None
    address=address,
    # Remove: latitude=latitude, longitude=longitude  (these are read-only properties)
    ...
)
```

### ManagerCrew Mock for Tests (tests/test_reports_api.py)

```python
# Replace stale IntakeFlow patches with ManagerCrew patches
with patch('src.api.v1.reports.ManagerCrew') as mock_crew_class:
    mock_crew = MagicMock()
    mock_crew.kickoff = AsyncMock(return_value={"routing_phase": "municipal"})
    mock_crew_class.return_value = mock_crew
    # test code
    mock_crew_class.assert_not_called()  # for pre-selected category tests
```

---

## Scope Boundary

### What Phase 8 Covers
- Wire `handleSubmit()` in `ReportIssuePage.tsx` to `POST /api/v1/reports/submit`
- Fix PostGIS `location` field assignment bug in `reports.py`
- Add `accuracy` field to GPS location state and payload
- Map frontend category display strings to backend enum values
- Update stale `IntakeFlow` test mocks to `ManagerCrew`
- Pass `media_file_ids: []` (skip linking for now — photos still upload to Supabase Storage)
- Verify receipt shows real tracking number from backend response
- Verify GBV path sets `is_gbv: true` and receives `gbv` category in response

### What Phase 8 Does NOT Cover (deferred)
- Creating `MediaAttachment` DB records during photo upload (upload endpoint wiring) — deferred to a follow-up
- OCR bridge to `residence_verified` user_metadata (separate Phase 9 work)
- Ward councillor filtering (separate Phase 9 work)
- Render.yaml deployment fixes (Phase 10)

---

## Upload Endpoint Research Note

The `src/api/v1/uploads.py` endpoint needs quick inspection during planning to determine if it creates `MediaAttachment` DB records. If it does, photos can be fully linked in Phase 8. If it only returns presigned URLs, media linking requires a separate MediaAttachment creation step.

**Assumption (to verify):** Based on the Phase 03 decision "Upload-first workflow (MediaAttachment created without ticket_id, linked on submission)", the upload endpoint likely creates MediaAttachment records with `ticket_id=None`. If so, photos CAN be linked in Phase 8 by checking what `file_id` the upload endpoint returns.

---

## Route Order Issue (Minor Bug)

`reports.py` currently defines routes as:
1. `POST /submit`
2. `GET /{tracking_number}`
3. `GET /my`

FastAPI route `/my` is AFTER `/{tracking_number}`. Since FastAPI matches routes in definition order, `GET /my` will be intercepted by `GET /{tracking_number}` with `tracking_number="my"` — returning a 404 "Report my not found". The `/my` route must be moved BEFORE `/{tracking_number}`.

---

## Open Questions

1. **Does uploads.py create MediaAttachment records?**
   - What we know: Phase 03 decision says "Upload-first workflow (MediaAttachment created without ticket_id)"
   - What's unclear: Whether the current `uploads.py` implementation actually creates DB records with a `file_id`
   - Recommendation: Read `src/api/v1/uploads.py` at start of planning to determine if media linking is feasible in Phase 8

2. **Is USE_POSTGIS guard needed in test context for reports.py?**
   - What we know: `USE_SQLITE_TESTS=1` disables geoalchemy2 imports; test_reports_api.py is marked `@pytest.mark.integration`
   - What's unclear: Integration tests presumably run against PostgreSQL with PostGIS; the SQLite guard may not be needed in reports.py
   - Recommendation: Add the guard conservatively (matches routing_service.py pattern), no harm in being safe

3. **Should /reports/my and /api/v1/citizen/my-reports be consolidated?**
   - What we know: Milestone audit notes these are duplicates with slightly different GBV filtering
   - What's unclear: Which endpoint `useCitizenReports.ts` uses (it uses `/api/v1/citizen/my-reports`)
   - Recommendation: Fix the route ordering bug in Phase 8, but do not consolidate (separate concern)

---

## Sources

### Primary (HIGH confidence — direct codebase inspection)
- `frontend-public/src/pages/ReportIssuePage.tsx` — mock submit handler at line 260-286
- `src/api/v1/reports.py` — backend implementation (ManagerCrew already correct, PostGIS bug at lines 149-150)
- `src/schemas/report.py` — `ReportSubmitRequest` Pydantic schema (accuracy required in LocationData)
- `src/models/ticket.py` — `Ticket` model (location is PostGIS Geometry, latitude/longitude are read-only @property)
- `src/core/encryption.py` — `EncryptedString` Fernet TypeDecorator (transparent, key-rotation aware)
- `tests/test_reports_api.py` — stale IntakeFlow mocks at lines 121, 154
- `.planning/v1.0-MILESTONE-AUDIT.md` — gap evidence and integration chain analysis
- `frontend-public/src/hooks/useCitizenReports.ts` — API call pattern with Supabase auth token
- `frontend-public/src/contexts/AuthContext.tsx` — session exposes `access_token`
- `src/services/routing_service.py` — USE_POSTGIS guard and geoalchemy2 import pattern

### Secondary (MEDIUM confidence)
- PostGIS coordinate order `Point(longitude, latitude)` — standard geographic convention (x=lon, y=lat), consistent with ST_MakePoint(longitude, latitude) in migration `2026_02_10_0734-04_01_postgis_teams_sla.py`

---

## Metadata

**Confidence breakdown:**
- Frontend wiring task: HIGH — gap is a single TODO comment; pattern is established in useCitizenReports.ts
- PostGIS location bug: HIGH — confirmed from model (no lat/lng columns, read-only @property), reports.py uses removed kwargs
- Category mapping: HIGH — frontend options vs backend enum values directly inspected
- Media linking feasibility: MEDIUM — depends on uploads.py implementation (needs verification)
- Test fixes: HIGH — stale IntakeFlow import confirmed against current reports.py imports

**Research date:** 2026-02-22
**Valid until:** 2026-03-22 (stable codebase, 30 days)
