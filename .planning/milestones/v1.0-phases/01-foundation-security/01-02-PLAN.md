---
phase: 01-foundation-security
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/core/security.py
  - src/api/deps.py
  - src/api/v1/auth.py
  - src/api/v1/users.py
  - src/main.py
  - tests/test_auth.py
autonomous: true

must_haves:
  truths:
    - "User can register with email/password and POPIA consent is captured at registration"
    - "User can login with valid credentials and receive JWT access + refresh tokens"
    - "Invalid credentials return 401 with generic 'Invalid credentials' message (no user enumeration)"
    - "Protected endpoints reject requests without valid JWT token"
    - "Endpoints with role restrictions reject users without required role with 403"
  artifacts:
    - path: "src/core/security.py"
      provides: "JWT creation/verification and Argon2 password hashing"
      contains: "create_access_token"
    - path: "src/api/deps.py"
      provides: "get_current_user and require_role dependency factories"
      contains: "require_role"
    - path: "src/api/v1/auth.py"
      provides: "POST /register, POST /login, POST /refresh endpoints"
      exports: ["router"]
    - path: "tests/test_auth.py"
      provides: "Auth endpoint tests"
      contains: "test_register"
  key_links:
    - from: "src/api/v1/auth.py"
      to: "src/core/security.py"
      via: "password hashing and token creation"
      pattern: "create_access_token|get_password_hash"
    - from: "src/api/deps.py"
      to: "src/core/security.py"
      via: "token decoding for user extraction"
      pattern: "decode_access_token"
    - from: "src/api/v1/auth.py"
      to: "src/models/consent.py"
      via: "consent record creation at registration"
      pattern: "ConsentRecord"
---

<objective>
Implement the complete authentication and authorization system: JWT token generation with PyJWT, Argon2 password hashing, user registration (with mandatory POPIA consent capture), login, token refresh, and reusable RBAC dependency injection for protecting endpoints.

Purpose: Every API endpoint in the platform needs authentication and role-based access control. Registration must capture POPIA consent from day one (SEC-02). This plan creates the auth foundation that Plans 03, 04, and 05 all depend on.
Output: Working auth flow (register/login/refresh) with RBAC dependencies, POPIA consent at registration.
</objective>

<execution_context>
@C:/Users/Bantu/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Bantu/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-foundation-security/01-RESEARCH.md
@.planning/phases/01-foundation-security/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Security utilities and auth dependencies</name>
  <files>
    src/core/security.py
    src/api/deps.py
  </files>
  <action>
    **src/core/security.py:** Create security utilities using PyJWT (NOT python-jose -- deprecated, security issues) and Argon2-cffi (NOT bcrypt -- OWASP now recommends Argon2id):

    Password hashing with Argon2:
    - from argon2 import PasswordHasher
    - ph = PasswordHasher() (uses Argon2id by default with safe params)
    - def get_password_hash(password: str) -> str: return ph.hash(password)
    - def verify_password(plain_password: str, hashed_password: str) -> bool: use ph.verify() wrapped in try/except for argon2.exceptions.VerifyMismatchError

    JWT token management with PyJWT:
    - def create_access_token(data: dict, expires_delta: timedelta | None = None) -> str:
      Build payload with "sub" (user_id), "tenant_id", "role", "exp" (expiry), "iat" (issued at), "type": "access"
      Use jwt.encode(payload, settings.SECRET_KEY, algorithm=settings.ALGORITHM)
    - def create_refresh_token(data: dict) -> str:
      Same as access but with REFRESH_TOKEN_EXPIRE_DAYS expiry and "type": "refresh"
    - def decode_access_token(token: str) -> dict | None:
      Use jwt.decode(token, settings.SECRET_KEY, algorithms=[settings.ALGORITHM])
      Return None on jwt.ExpiredSignatureError, jwt.InvalidTokenError
      Validate token "type" == "access" (reject refresh tokens used as access tokens)

    **src/api/deps.py:** Replace placeholder stubs with real auth dependencies:

    - from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
    - security = HTTPBearer()

    - async def get_current_user(credentials: HTTPAuthorizationCredentials = Depends(security), db: AsyncSession = Depends(get_db)) -> User:
      Decode token, extract user_id from "sub" claim, extract tenant_id and set_tenant_context(tenant_id).
      Query User by id. Raise 401 if token invalid or user not found or user.is_active is False.
      Return User object.

    - def require_role(*allowed_roles: UserRole) -> Callable:
      Return inner async function that calls get_current_user and checks user.role in allowed_roles.
      Raise 403 with detail "Requires role: {roles}" if not authorized.
      Return user if authorized.

    - async def get_current_active_user(current_user: User = Depends(get_current_user)) -> User:
      Check is_active and not is_deleted. Raise 403 if inactive.

    IMPORTANT: Do NOT use passlib.context.CryptContext -- passlib maintenance ended 2020. Use argon2-cffi directly.
    IMPORTANT: Do NOT use python-jose -- last updated 2021. Use PyJWT (pyjwt package, imported as jwt).
  </action>
  <verify>
    Run: python -c "
from src.core.security import get_password_hash, verify_password, create_access_token, decode_access_token
h = get_password_hash('testpass123')
assert verify_password('testpass123', h), 'Password verify failed'
token = create_access_token({'sub': 'user1', 'tenant_id': 'muni1', 'role': 'citizen'})
decoded = decode_access_token(token)
assert decoded['sub'] == 'user1', 'Token decode failed'
print('Security utils OK')
"
  </verify>
  <done>
    Password hashing with Argon2 works (hash + verify round-trip). JWT creation with PyJWT works (encode + decode round-trip with claims preserved). get_current_user dependency extracts user from token and sets tenant context. require_role factory creates role-checking dependencies.
  </done>
</task>

<task type="auto">
  <name>Task 2: Auth endpoints with POPIA consent at registration</name>
  <files>
    src/api/v1/auth.py
    src/api/v1/users.py
    src/main.py
    tests/test_auth.py
  </files>
  <action>
    **src/api/v1/auth.py:** Create auth router with APIRouter(prefix="/api/v1/auth", tags=["Authentication"]):

    POST /register:
    - Accept RegisterRequest schema: email, password (min 8 chars), full_name, phone (optional),
      preferred_language (en/zu/af), municipality_code, consent (ConsentCreate object -- required, must have consented=True)
    - Create RegisterRequest schema that extends UserCreate with mandatory consent field
    - Validate municipality_code exists in Municipality table. Return 404 if not found.
    - Check email uniqueness within tenant (same email can exist in different municipalities). Return 409 if duplicate.
    - Hash password with Argon2
    - Create User record with tenant_id = municipality.id
    - Create ConsentRecord with purpose="platform_registration",
      purpose_description set per language:
        en: "I consent to SALGA Trust Engine processing my personal data for municipal service reporting, issue tracking, and communication about reported issues."
        zu: "Ngiyavuma ukuthi i-SALGA Trust Engine icubungule idatha yami yomuntu siqu ukuze ngibike izinkinga zikamsipala, ukulandelela izinkinga, nokuxhumana ngezinkinga ezibikiwe."
        af: "Ek stem in dat SALGA Trust Engine my persoonlike data verwerk vir munisipale diensverslaggewing, kwessie-opsporing en kommunikasie oor aangemelde kwessies."
    - Return 201 with UserResponse + TokenResponse (auto-login after registration)
    - Log audit entry for user creation

    POST /login:
    - Accept LoginRequest schema: email, password
    - Look up user by email (across all tenants -- email + password is enough to identify)
    - Use GENERIC error message "Invalid credentials" for both wrong email and wrong password (prevent user enumeration per SEC-08)
    - On success: create access_token + refresh_token with user_id, tenant_id, role claims
    - Return TokenResponse

    POST /refresh:
    - Accept body with refresh_token string
    - Decode refresh token, validate type == "refresh"
    - Look up user, verify still active
    - Issue new access_token + refresh_token pair (token rotation)
    - Return TokenResponse

    **src/api/v1/users.py:** Create users router with APIRouter(prefix="/api/v1/users", tags=["Users"]):

    GET /me:
    - Depends(get_current_active_user)
    - Return current user's UserResponse

    **src/main.py:** Update to include auth and users routers:
    - app.include_router(auth_router)
    - app.include_router(users_router)

    **tests/test_auth.py:** Create tests:
    - test_register_success: Register user, verify 201 response, verify tokens returned
    - test_register_requires_consent: Try registering without consent, verify 422
    - test_register_duplicate_email: Register same email twice in same municipality, verify 409
    - test_login_success: Login with valid credentials, verify tokens
    - test_login_invalid_password: Login with wrong password, verify 401 with "Invalid credentials" (NOT "wrong password")
    - test_login_nonexistent_user: Login with non-existent email, verify 401 with same "Invalid credentials" message
    - test_protected_endpoint_no_token: Access /api/v1/users/me without token, verify 401/403
    - test_protected_endpoint_with_token: Access /api/v1/users/me with valid token, verify 200

    Use app.dependency_overrides to mock database in tests. Create test municipality fixture.
  </action>
  <verify>
    Run: pytest tests/test_auth.py -v (all tests should pass)
    If database not available for tests, verify by running app and testing manually:
    - uvicorn src.main:app --reload
    - Visit http://localhost:8000/docs to see auth endpoints documented
    - Verify /api/v1/auth/register, /api/v1/auth/login, /api/v1/auth/refresh, /api/v1/users/me appear in docs
  </verify>
  <done>
    Registration creates user + consent record in single transaction. Login returns JWT tokens. Refresh rotates tokens. /users/me returns current user. All auth tests pass. POPIA consent captured at registration with trilingual purpose descriptions (SEC-02 satisfied). Error messages are generic to prevent user enumeration.
  </done>
</task>

</tasks>

<verification>
1. Registration endpoint captures POPIA consent with purpose description in user's language
2. Login returns JWT access + refresh tokens
3. Protected endpoints reject unauthenticated requests
4. Role-based deps (require_role) reject unauthorized roles with 403
5. Error messages don't leak whether user exists (SEC-08)
6. Argon2 is used for password hashing (not bcrypt)
7. PyJWT is used for tokens (not python-jose)
</verification>

<success_criteria>
- POST /api/v1/auth/register creates user + consent record, returns tokens
- POST /api/v1/auth/login authenticates and returns tokens
- POST /api/v1/auth/refresh rotates tokens
- GET /api/v1/users/me requires auth, returns user data
- require_role dependency factory works for all 5 roles
- Auth test suite passes
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-security/01-02-SUMMARY.md`
</output>
