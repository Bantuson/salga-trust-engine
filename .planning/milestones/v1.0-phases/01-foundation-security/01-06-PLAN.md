---
phase: 01-foundation-security
plan: 06
type: execute
wave: 1
depends_on: []
files_modified:
  - .env.example
  - .env
  - src/core/config.py
  - pyproject.toml
  - tests/conftest.py
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "DATABASE_URL enforces SSL connection to PostgreSQL via sslmode parameter"
    - "Encryption at rest strategy is documented and connection-level TLS is enforced"
    - "pytest configuration registers custom marks and configures coverage measurement"
    - "Test conftest.py handles Windows asyncio event loop policy correctly"
    - "Unit tests can run without PostgreSQL by skipping integration tests"
  artifacts:
    - path: ".env.example"
      provides: "DATABASE_URL template with sslmode=require"
      contains: "sslmode=require"
    - path: "pyproject.toml"
      provides: "pytest config with markers, coverage settings, asyncio_mode"
      contains: "pytest-cov"
    - path: "tests/conftest.py"
      provides: "Fixed test infrastructure with Windows event loop, SQLite fallback for unit tests"
      contains: "WindowsSelectorEventLoopPolicy"
  key_links:
    - from: ".env.example"
      to: "src/core/config.py"
      via: "DATABASE_URL environment variable"
      pattern: "sslmode"
    - from: "pyproject.toml"
      to: "tests/"
      via: "pytest configuration"
      pattern: "tool.pytest"
---

<objective>
Fix database encryption configuration (Gap 1) and test infrastructure (Gap 2 foundation) to close verification gaps from Phase 01.

Purpose: SEC-01 requires encryption at rest and in transit. The DATABASE_URL lacks sslmode=require, leaving DB connections unencrypted. Additionally, the entire test suite (60 tests) fails because conftest.py lacks Windows event loop policy and there is no way to run unit tests without PostgreSQL. This plan fixes the infrastructure; the next plan rewrites tests to actually pass.

Output: Updated .env.example with sslmode, pytest configuration with coverage and markers, fixed conftest.py with Windows compatibility and integration test separation.
</objective>

<execution_context>
@C:/Users/Bantu/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Bantu/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-security/01-VERIFICATION.md
@src/core/config.py
@src/core/database.py
@tests/conftest.py
@pyproject.toml
@.env.example
</context>

<tasks>

<task type="auto">
  <name>Task 1: Database Encryption Configuration (SEC-01 Gap Closure)</name>
  <files>.env.example, .env, src/core/config.py</files>
  <action>
1. Update `.env.example` — change the DATABASE_URL to include sslmode=require:
   ```
   DATABASE_URL=postgresql+psycopg://user:password@localhost:5432/salga_trust?sslmode=require
   ```
   Add a comment above it: `# sslmode=require enforces TLS encryption for database connections (SEC-01)`
   Also add a comment block at the top of the file documenting the encryption at rest strategy:
   ```
   # ENCRYPTION STRATEGY (SEC-01 / POPIA Compliance)
   # - In transit: sslmode=require on DATABASE_URL enforces TLS for all DB connections
   # - In transit: HSTS security header enforces HTTPS for all API traffic
   # - At rest: PostgreSQL should run on encrypted storage (dm-crypt/LUKS on Linux, BitLocker on Windows, or cloud-managed encryption e.g. Azure/AWS RDS encryption)
   # - At rest: For column-level encryption of sensitive fields, pgcrypto extension can be added in future phases
   ```

2. Update `.env` (the actual env file) — add `?sslmode=prefer` to the DATABASE_URL (use `prefer` for local dev since local PostgreSQL may not have SSL configured, but production MUST use `require`). Add a comment noting this.

3. In `src/core/config.py`, add a `DB_SSL_MODE` field with default "require" and a validator that warns if sslmode is not present in DATABASE_URL for non-development environments. Specifically:
   - Add a field: `DB_SSL_MODE: str = Field(default="require", description="PostgreSQL SSL mode")`
   - Add a `@model_validator(mode='after')` that checks: if `self.ENVIRONMENT != "development"` and `"sslmode" not in self.DATABASE_URL`, log a warning (use `import warnings; warnings.warn(...)`) about missing sslmode. Do NOT raise an error (don't break existing setups), just warn.
  </action>
  <verify>
  - Verify `.env.example` contains `sslmode=require` in DATABASE_URL
  - Verify `src/core/config.py` has DB_SSL_MODE field and model_validator
  - Run: `python -c "from src.core.config import Settings"` to confirm Settings class loads without error
  </verify>
  <done>DATABASE_URL in .env.example includes sslmode=require, encryption strategy is documented, config warns on missing sslmode in non-dev environments</done>
</task>

<task type="auto">
  <name>Task 2: Test Infrastructure Overhaul (pytest config, conftest, coverage)</name>
  <files>pyproject.toml, tests/conftest.py</files>
  <action>
1. Update `pyproject.toml` to add test configuration and dependencies:
   - Add `pytest-cov==6.0.0` to `[project.optional-dependencies] dev`
   - Add `[tool.pytest.ini_options]` section with:
     ```toml
     [tool.pytest.ini_options]
     asyncio_mode = "auto"
     markers = [
         "integration: requires PostgreSQL database connection",
     ]
     testpaths = ["tests"]
     filterwarnings = [
         "ignore::DeprecationWarning",
     ]
     addopts = "-v --tb=short"
     ```
   - Add `[tool.coverage.run]` section:
     ```toml
     [tool.coverage.run]
     source = ["src"]
     omit = ["src/__init__.py", "src/*/__init__.py"]

     [tool.coverage.report]
     fail_under = 80
     show_missing = true
     exclude_lines = [
         "pragma: no cover",
         "if __name__ == .__main__.",
         "pass",
     ]
     ```

2. Rewrite `tests/conftest.py` completely with these critical fixes:
   a. Add Windows event loop policy at the TOP of the file (before any async imports):
      ```python
      import sys
      import asyncio
      if sys.platform == "win32":
          asyncio.set_event_loop_policy(asyncio.WindowsSelectorEventLoopPolicy())
      ```
   b. Detect whether PostgreSQL is available by attempting a connection. Create a module-level variable `POSTGRES_AVAILABLE` that is True/False based on whether the DB is reachable. Use a synchronous test connection attempt wrapped in try/except.
   c. For the test database engine and session:
      - If POSTGRES_AVAILABLE is True: use the existing PostgreSQL test URL (append _test to db name)
      - If POSTGRES_AVAILABLE is False: use `sqlite+aiosqlite:///./test.db` as a fallback for unit tests. Add `aiosqlite` to dev dependencies in pyproject.toml.
   d. Keep all existing fixtures (db_session, client, async_client, setup_test_database, test_municipality, test_user, admin_user, citizen_user, admin_token, citizen_token) but make the database-dependent ones check POSTGRES_AVAILABLE and skip with `pytest.skip("PostgreSQL not available")` when needed for integration tests.
   e. Add a `conftest_skip_integration` autouse fixture that automatically skips tests marked `@pytest.mark.integration` when POSTGRES_AVAILABLE is False.
   f. Export `POSTGRES_AVAILABLE` so test files can use it.
   g. The `event_loop` fixture must use `scope="session"` and set WindowsSelectorEventLoopPolicy on Windows.

   Here is the key detection logic:
   ```python
   def _check_postgres():
       """Check if PostgreSQL is reachable."""
       try:
           import psycopg
           # Try synchronous connection
           conn = psycopg.connect(
               settings.DATABASE_URL.replace("+psycopg", "").replace("postgresql", "postgresql"),
               connect_timeout=3,
           )
           conn.close()
           return True
       except Exception:
           return False

   POSTGRES_AVAILABLE = _check_postgres()
   ```

   For the SQLite fallback, the setup_test_database fixture should create tables with `Base.metadata.create_all`. Note: SQLite won't support RLS or PostgreSQL-specific features, but it's sufficient for unit tests that test application logic (auth, sanitization, API routing, model creation).

   IMPORTANT: When using SQLite fallback, the db_session fixture should still work for basic model operations. The tenant filtering event listener in base.py works with any SQLAlchemy backend. Only RLS-specific tests (which are already marked integration or skipped) need PostgreSQL.
  </action>
  <verify>
  - Run: `pip install pytest-cov aiosqlite` (or `uv pip install pytest-cov aiosqlite`)
  - Run: `python -m pytest tests/test_middleware_unit.py -v` — should pass (pure unit tests, no DB)
  - Run: `python -m pytest tests/test_middleware.py -v -m "not integration"` — should pass (unit test classes only)
  - Run: `python -m pytest tests/ -v -m "not integration" --co` — should collect tests without errors
  - Verify pyproject.toml has [tool.pytest.ini_options] and [tool.coverage.run] sections
  </verify>
  <done>pytest configured with markers and coverage, conftest.py handles Windows event loop and SQLite fallback, integration tests auto-skip when no PostgreSQL, pure unit tests can execute independently</done>
</task>

</tasks>

<verification>
1. `.env.example` DATABASE_URL contains `sslmode=require`
2. `src/core/config.py` warns on missing sslmode in production
3. `pyproject.toml` has pytest markers, coverage config, and new dev deps (pytest-cov, aiosqlite)
4. `tests/conftest.py` starts with Windows event loop policy
5. `tests/conftest.py` has POSTGRES_AVAILABLE detection
6. `python -m pytest tests/test_middleware_unit.py -v` passes without PostgreSQL
7. `python -m pytest -m "not integration" --co` collects non-integration tests without error
</verification>

<success_criteria>
- SEC-01 gap closed: DATABASE_URL enforces sslmode, encryption strategy documented
- Test infrastructure ready: pytest markers registered, coverage configured, Windows event loop fixed
- Unit tests collectible: non-integration tests can be collected and run without PostgreSQL
- No regressions: existing test code is not broken (just properly skipped when DB unavailable)
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-security/01-06-SUMMARY.md`
</output>
