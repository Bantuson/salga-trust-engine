---
phase: 01-foundation-security
plan: 03
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/middleware/__init__.py
  - src/middleware/tenant_middleware.py
  - src/middleware/security_headers.py
  - src/middleware/rate_limit.py
  - src/middleware/error_handler.py
  - src/core/sanitization.py
  - src/main.py
  - tests/test_middleware.py
autonomous: true

must_haves:
  truths:
    - "Requests without X-Tenant-ID header are rejected with 400 (except auth and health endpoints)"
    - "Public endpoints (login, register, health) have rate limits enforced"
    - "All responses include security headers (X-Content-Type-Options, X-Frame-Options, Strict-Transport-Security)"
    - "HTML content in user input is stripped by sanitization utilities"
    - "CORS only allows configured origins (not wildcard)"
  artifacts:
    - path: "src/middleware/tenant_middleware.py"
      provides: "Tenant context extraction and validation middleware"
      contains: "TenantContextMiddleware"
    - path: "src/middleware/rate_limit.py"
      provides: "Rate limiting configuration with slowapi"
      contains: "limiter"
    - path: "src/middleware/security_headers.py"
      provides: "Security headers middleware"
      contains: "SecurityHeadersMiddleware"
    - path: "src/core/sanitization.py"
      provides: "Input sanitization with nh3"
      contains: "sanitize_html"
    - path: "src/middleware/error_handler.py"
      provides: "Global error handler that strips sensitive details in production"
      contains: "global_exception_handler"
  key_links:
    - from: "src/middleware/tenant_middleware.py"
      to: "src/core/tenant.py"
      via: "sets tenant context per request"
      pattern: "set_tenant_context"
    - from: "src/main.py"
      to: "src/middleware"
      via: "middleware registration"
      pattern: "add_middleware"
    - from: "src/middleware/rate_limit.py"
      to: "src/core/config.py"
      via: "Redis URL for distributed rate limiting"
      pattern: "settings\\.REDIS_URL"
---

<objective>
Implement all security middleware and API hardening: tenant context extraction middleware, rate limiting with slowapi, security response headers, CORS configuration, input sanitization utilities with nh3, and a global error handler that prevents information leakage in production.

Purpose: These security layers protect every API endpoint from abuse (rate limiting), cross-tenant data leakage (tenant middleware), XSS/injection attacks (sanitization), and information disclosure (error handling). Addresses PLAT-05, PLAT-06, SEC-06, SEC-08.
Output: Middleware stack applied to FastAPI app, sanitization utilities available for use in schemas.
</objective>

<execution_context>
@C:/Users/Bantu/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Bantu/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-foundation-security/01-RESEARCH.md
@.planning/phases/01-foundation-security/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Tenant context middleware and security headers</name>
  <files>
    src/middleware/__init__.py
    src/middleware/tenant_middleware.py
    src/middleware/security_headers.py
    src/middleware/error_handler.py
  </files>
  <action>
    Create src/middleware/__init__.py (empty).

    **src/middleware/tenant_middleware.py:** Create TenantContextMiddleware:
    - Inherit from starlette.middleware.base.BaseHTTPMiddleware
    - Define EXCLUDED_PATHS that do NOT require tenant context:
      "/api/v1/auth/login", "/api/v1/auth/register", "/api/v1/auth/refresh",
      "/health", "/docs", "/redoc", "/openapi.json"
    - In dispatch():
      1. Check if request.url.path is in EXCLUDED_PATHS -- if so, skip tenant check
      2. For all other paths, extract X-Tenant-ID header
      3. If missing, return 400 JSON response: {"detail": "X-Tenant-ID header required"}
      4. Validate tenant_id is a valid UUID format (not just any string)
      5. Call set_tenant_context(tenant_id) from src.core.tenant
      6. In try/finally block: call_next(request) then clear_tenant_context()
    - IMPORTANT: Do NOT query the database to validate tenant exists in middleware (performance).
      Validation that tenant exists happens when the query executes (RLS or app-level filter returns empty).

    **src/middleware/security_headers.py:** Create SecurityHeadersMiddleware:
    - Inherit from BaseHTTPMiddleware
    - In dispatch(), add these headers to every response:
      "X-Content-Type-Options": "nosniff"
      "X-Frame-Options": "DENY"
      "X-XSS-Protection": "0" (deprecated but set to 0 per OWASP -- modern browsers use CSP instead)
      "Strict-Transport-Security": "max-age=31536000; includeSubDomains" (only in production)
      "Content-Security-Policy": "default-src 'self'" (basic CSP)
      "Referrer-Policy": "strict-origin-when-cross-origin"
      "Permissions-Policy": "camera=(), microphone=(), geolocation=()" (restrict browser APIs)
    - In development mode (settings.DEBUG=True), relax CSP to allow Swagger UI assets:
      "Content-Security-Policy": "default-src 'self' 'unsafe-inline' cdn.jsdelivr.net"

    **src/middleware/error_handler.py:** Create global exception handler:
    - async def global_exception_handler(request: Request, exc: Exception) -> JSONResponse:
    - In production (settings.DEBUG=False):
      Log full exception with traceback to server logs (logging.exception)
      Return JSONResponse with status 500 and generic message: {"detail": "Internal server error"}
      NEVER include stack trace, SQL errors, or internal paths in response
    - In development (settings.DEBUG=True):
      Return full error details for debugging: {"detail": str(exc), "type": type(exc).__name__}
    - Register with app.add_exception_handler(Exception, global_exception_handler)
    - Also handle HTTPException separately to preserve FastAPI's default behavior for 4xx errors
    - Handle RequestValidationError to return 422 with field-level errors but without internal details
  </action>
  <verify>
    Run: python -c "
from src.middleware.tenant_middleware import TenantContextMiddleware
from src.middleware.security_headers import SecurityHeadersMiddleware
from src.middleware.error_handler import global_exception_handler
print('All middleware importable')
"
  </verify>
  <done>
    TenantContextMiddleware extracts X-Tenant-ID from requests, skips auth/health paths, rejects missing header with 400. SecurityHeadersMiddleware adds OWASP-recommended headers to all responses. Error handler prevents information leakage in production mode.
  </done>
</task>

<task type="auto">
  <name>Task 2: Rate limiting, input sanitization, CORS, and middleware registration</name>
  <files>
    src/middleware/rate_limit.py
    src/core/sanitization.py
    src/main.py
    tests/test_middleware.py
  </files>
  <action>
    **src/middleware/rate_limit.py:** Configure slowapi rate limiting:
    - from slowapi import Limiter, _rate_limit_exceeded_handler
    - from slowapi.util import get_remote_address
    - from slowapi.errors import RateLimitExceeded

    - Create limiter instance:
      In production: use Redis storage_uri from settings.REDIS_URL
      In development: use in-memory storage (default)
      Key function: get_remote_address (rate limit by IP)

    - Define rate limit constants:
      AUTH_RATE_LIMIT = "5/minute" (login attempts)
      REGISTER_RATE_LIMIT = "3/hour" (registrations)
      API_DEFAULT_RATE_LIMIT = "60/minute" (general API calls)
      DATA_EXPORT_RATE_LIMIT = "5/hour" (POPIA data export -- expensive operation)

    - Export limiter instance for use as decorator in route files
    - Create setup_rate_limiting(app) function that:
      Sets app.state.limiter = limiter
      Adds RateLimitExceeded exception handler

    **src/core/sanitization.py:** Input sanitization utilities:
    - import nh3
    - def sanitize_html(text: str) -> str:
      Strip ALL HTML tags: nh3.clean(text, tags=set())
      This prevents XSS in any user-provided text field
    - def sanitize_text_field(text: str, max_length: int = 5000) -> str:
      Call sanitize_html, then strip whitespace, then truncate to max_length
    - Create Pydantic field validator factory:
      def SanitizedStr(max_length: int = 5000) -> type:
        Returns Annotated[str, BeforeValidator(lambda v: sanitize_text_field(v, max_length))]
      This can be used in schemas: title: SanitizedStr(200) = Field(...)

    **src/main.py:** Update to register ALL middleware in correct order (order matters!):
    Middleware executes in REVERSE order of addition, so add in this order:
    1. Add CORS middleware (from starlette.middleware.cors.CORSMiddleware):
       allow_origins=settings.ALLOWED_ORIGINS (NOT "*" -- per research pitfall 5)
       allow_credentials=True
       allow_methods=["GET", "POST", "PUT", "DELETE", "PATCH"]
       allow_headers=["Authorization", "Content-Type", "X-Tenant-ID"]
    2. Add SecurityHeadersMiddleware
    3. Add TenantContextMiddleware
    4. Call setup_rate_limiting(app)
    5. Register global_exception_handler

    Apply rate limit decorators to existing auth endpoints:
    - /login: @limiter.limit(AUTH_RATE_LIMIT)
    - /register: @limiter.limit(REGISTER_RATE_LIMIT)
    NOTE: Since auth.py is in Plan 02 (same wave), the rate limit decorators should be applied in src/api/v1/auth.py. Import limiter from src.middleware.rate_limit in auth.py.
    If Plan 02 executes first, add rate limits; if Plan 03 executes first, add TODO comments in auth.py placeholder or add limits to main.py config.

    **tests/test_middleware.py:** Create middleware tests:
    - test_health_endpoint_no_tenant_required: GET /health without X-Tenant-ID returns 200
    - test_api_endpoint_requires_tenant: GET /api/v1/users/me without X-Tenant-ID returns 400
    - test_security_headers_present: Any response includes X-Content-Type-Options, X-Frame-Options
    - test_cors_rejects_unknown_origin: OPTIONS request with unknown origin gets no CORS headers
    - test_sanitize_html_strips_tags: sanitize_html("<script>alert('xss')</script>hello") == "hello"
    - test_sanitize_preserves_text: sanitize_html("normal text") == "normal text"
    - test_rate_limit_format: Verify rate limit constants are valid format strings
  </action>
  <verify>
    Run: pytest tests/test_middleware.py -v
    Run: python -c "
from src.core.sanitization import sanitize_html
result = sanitize_html('<script>alert(1)</script>Hello')
assert 'script' not in result, f'XSS not sanitized: {result}'
assert 'Hello' in result, f'Text lost: {result}'
print(f'Sanitization OK: {result}')
"
    Run: python -c "from src.middleware.rate_limit import limiter; print('Rate limiter OK')"
  </verify>
  <done>
    Rate limiting configured with slowapi (Redis in production, in-memory in dev). nh3 sanitization strips HTML from user input. CORS restricts to configured origins only. All middleware registered on FastAPI app in correct order. Security headers on all responses. Middleware tests pass.
  </done>
</task>

</tasks>

<verification>
1. GET /health returns 200 without X-Tenant-ID header
2. GET /api/v1/users/me without X-Tenant-ID returns 400
3. Response headers include X-Content-Type-Options: nosniff
4. sanitize_html strips script tags and preserves text
5. Rate limiter instance is configured and importable
6. CORS does not use wildcard origins
</verification>

<success_criteria>
- Tenant middleware blocks non-exempt endpoints without X-Tenant-ID
- Security headers added to all responses
- Rate limiting configured (5/min login, 3/hr register, 60/min general)
- nh3 sanitization available as utility and Pydantic validator
- CORS configured with explicit origins list
- Error handler strips sensitive info in production mode
- All middleware tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-security/01-03-SUMMARY.md`
</output>
