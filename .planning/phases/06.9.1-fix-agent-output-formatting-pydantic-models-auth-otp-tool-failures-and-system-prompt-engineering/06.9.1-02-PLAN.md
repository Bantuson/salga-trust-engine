---
phase: 06.9.1-fix-agent-output-formatting-pydantic-models-auth-otp-tool-failures-and-system-prompt-engineering
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/agents/crews/base_crew.py
  - src/agents/crews/auth_crew.py
  - src/agents/crews/municipal_crew.py
  - src/agents/crews/gbv_crew.py
  - src/agents/crews/ticket_status_crew.py
  - src/agents/tools/auth_tool.py
autonomous: true
requirements: [AI-03, AI-04, AI-05, AI-06]

must_haves:
  truths:
    - "MunicipalCrew produces structured MunicipalResponse Pydantic output with message, language, action_taken fields"
    - "GBVCrew produces structured GBVResponse Pydantic output with emergency number guarantee in error fallback"
    - "TicketStatusCrew produces structured TicketStatusResponse Pydantic output"
    - "All crews use a shared repair strategy when Pydantic conversion fails on raw LLM output"
    - "Auth OTP verify_otp uses type=email for email path (not magiclink)"
    - "Auth OTP send_otp uses should_create_user=False for returning users"
    - "All auth tool failures are logged with context and repeated failures (3+ in 5 min) flagged as critical"
  artifacts:
    - path: "src/agents/crews/base_crew.py"
      provides: "AgentResponse base Pydantic model + _repair_from_raw() repair strategy"
      contains: "class AgentResponse"
    - path: "src/agents/crews/municipal_crew.py"
      provides: "MunicipalResponse Pydantic model + output_pydantic on task"
      contains: "class MunicipalResponse"
    - path: "src/agents/crews/gbv_crew.py"
      provides: "GBVResponse Pydantic model with emergency number error fallback"
      contains: "class GBVResponse"
    - path: "src/agents/crews/ticket_status_crew.py"
      provides: "TicketStatusResponse Pydantic model"
      contains: "class TicketStatusResponse"
    - path: "src/agents/crews/auth_crew.py"
      provides: "Updated AuthResult with language field + repair fallback"
      contains: "language"
    - path: "src/agents/tools/auth_tool.py"
      provides: "Fixed OTP type handling + tool failure logging"
      contains: "_log_tool_failure"
  key_links:
    - from: "src/agents/crews/base_crew.py"
      to: "src/agents/crews/municipal_crew.py"
      via: "_repair_from_raw imported/used in parse_result()"
      pattern: "_repair_from_raw"
    - from: "src/agents/crews/municipal_crew.py"
      to: "src/agents/config/tasks.yaml"
      via: "output_pydantic=MunicipalResponse passed via build_task_kwargs()"
      pattern: "output_pydantic.*MunicipalResponse"
    - from: "src/agents/tools/auth_tool.py"
      to: "src/agents/crews/auth_crew.py"
      via: "auth tools imported and used as crew tools"
      pattern: "from src.agents.tools.auth_tool import"
---

<objective>
Add Pydantic structured output models to all remaining crews (Municipal, GBV, TicketStatus), add shared repair strategy in base_crew.py, update AuthResult with language field, and fix auth OTP tool failures with proper error logging.

Purpose: This delivers the structured output layer that forces LLM responses into clean, validated shapes. When Pydantic conversion fails (common with DeepSeek), the repair strategy extracts usable data from raw output instead of passing garbled text to citizens. The OTP tool fixes resolve the "emails not arriving" and "phone call verification" root causes.

Output: Pydantic models on all 4 specialist crews, shared repair utility in base_crew.py, fixed auth_tool.py with proper OTP type handling and failure logging.
</objective>

<execution_context>
@C:/Users/Bantu/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Bantu/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06.9.1-fix-agent-output-formatting-pydantic-models-auth-otp-tool-failures-and-system-prompt-engineering/06.9.1-RESEARCH.md
@src/agents/crews/base_crew.py
@src/agents/crews/auth_crew.py
@src/agents/crews/municipal_crew.py
@src/agents/crews/gbv_crew.py
@src/agents/crews/ticket_status_crew.py
@src/agents/tools/auth_tool.py
@src/agents/prompts/auth.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Pydantic models and repair strategy to base_crew.py, then add models to Municipal, GBV, and TicketStatus crews</name>
  <files>
    src/agents/crews/base_crew.py
    src/agents/crews/municipal_crew.py
    src/agents/crews/gbv_crew.py
    src/agents/crews/ticket_status_crew.py
    src/agents/crews/auth_crew.py
  </files>
  <action>
    **base_crew.py additions** (add at the top, after existing imports):

    1. Add `AgentResponse` base Pydantic model:
    ```python
    from pydantic import BaseModel, field_validator

    class AgentResponse(BaseModel):
        """Base structured output model shared by all specialist crews."""
        message: str                     # Clean citizen-facing text
        language: str = "en"            # "en" | "zu" | "af"
        action_taken: str = "unknown"   # Crew-specific action identifier
        requires_followup: bool = False
        tracking_number: str | None = None
        raw_output: str | None = None   # Debug only, never citizen-facing

        @field_validator("message")
        @classmethod
        def strip_artifacts(cls, v: str) -> str:
            """Strip LLM artifacts from message field if present."""
            final_match = re.search(r"Final Answer:?\s*(.+)", v, re.DOTALL | re.IGNORECASE)
            if final_match:
                return final_match.group(1).strip()
            return v.strip()

        @field_validator("language")
        @classmethod
        def validate_language(cls, v: str) -> str:
            return v if v in ("en", "zu", "af") else "en"
    ```

    2. Add `_repair_from_raw()` function at module level (not inside a class):
    ```python
    def _repair_from_raw(raw: str, model_class, fallback_message: str, language: str = "en") -> dict:
        """Attempt to extract model fields from raw LLM output when Pydantic conversion fails.

        Two-step repair:
        1. Try JSON regex extraction -> validate with model_class
        2. Try Final Answer extraction -> build minimal valid model
        3. If both fail: return hardcoded safe fallback (never crashes)
        """
        # Step 1: Extract JSON object if present
        json_match = re.search(r'\{[^{}]*"message"[^{}]*\}', raw, re.DOTALL)
        if json_match:
            try:
                data = json.loads(json_match.group())
                return model_class(**data).model_dump()
            except Exception:
                pass

        # Step 2: Extract text after "Final Answer:" marker
        final_match = re.search(r"Final Answer:?\s*(.+)", raw, re.DOTALL | re.IGNORECASE)
        extracted_msg = final_match.group(1).strip() if final_match else raw.strip()

        # Step 3: Build minimal valid model from extracted text
        try:
            return model_class(
                message=extracted_msg or fallback_message,
                language=language,
            ).model_dump()
        except Exception:
            # Final fallback: dict that always works (never fails)
            return {
                "message": fallback_message,
                "language": language,
                "action_taken": "error",
                "requires_followup": False,
                "raw_output": raw[:500] if raw else None,
            }
    ```

    3. Update `parse_result()` in BaseCrew to use Pydantic-aware parsing:
    Keep the existing parse_result() logic as-is but add a Pydantic path at the top:
    ```python
    def parse_result(self, result) -> dict[str, Any]:
        """Parse CrewAI result. Tries Pydantic model first, then regex fallback."""
        # Pydantic path: if result has .pydantic and it's not None
        if hasattr(result, "pydantic") and result.pydantic is not None:
            model_dict = result.pydantic.model_dump()
            model_dict["raw_output"] = str(result)
            return model_dict

        # Existing regex fallback (unchanged)
        raw = str(result)
        ... (keep existing code exactly as-is)
    ```

    **municipal_crew.py additions:**

    1. Add `MunicipalResponse` Pydantic model (inherits from AgentResponse):
    ```python
    from src.agents.crews.base_crew import BaseCrew, AgentResponse, _repair_from_raw

    class MunicipalResponse(AgentResponse):
        """Structured output from MunicipalCrew."""
        action_taken: str = "intake"  # "intake_started" | "ticket_created" | "clarifying"
    ```

    2. Add `build_task_kwargs()` override:
    ```python
    def build_task_kwargs(self, context: dict) -> dict:
        return {"output_pydantic": MunicipalResponse}
    ```

    3. Add `parse_result()` override using Pydantic-aware parsing with repair:
    ```python
    def parse_result(self, result) -> dict[str, Any]:
        if hasattr(result, "pydantic") and result.pydantic is not None:
            model_dict = result.pydantic.model_dump()
            model_dict["raw_output"] = str(result)
            return model_dict
        # Repair from raw output
        raw = str(result)
        fallback = "I'm Gugu from SALGA Trust Engine. Sorry, I didn't quite catch that -- could you describe your issue again?"
        return _repair_from_raw(raw, MunicipalResponse, fallback, language=self.language)
    ```

    **gbv_crew.py additions:**

    1. Add `GBVResponse` Pydantic model:
    ```python
    from src.agents.crews.base_crew import BaseCrew, AgentResponse, _repair_from_raw

    class GBVResponse(AgentResponse):
        """Structured output from GBVCrew. Emergency numbers always in error fallback."""
        action_taken: str = "safety_check"  # "safety_check" | "report_filed" | "escalated"
        requires_followup: bool = True  # GBV always requires followup
    ```

    2. Add `build_task_kwargs()`:
    ```python
    def build_task_kwargs(self, context: dict) -> dict:
        return {"output_pydantic": GBVResponse}
    ```

    3. Update `parse_result()` to use Pydantic + repair:
    ```python
    def parse_result(self, result) -> dict[str, Any]:
        if hasattr(result, "pydantic") and result.pydantic is not None:
            model_dict = result.pydantic.model_dump()
            model_dict["raw_output"] = str(result)
            model_dict["category"] = "gbv"  # Safety: always force category
            return model_dict
        raw = str(result)
        fallback = "I'm here to help you. If you are in immediate danger, please call 10111 or the GBV Command Centre at 0800 150 150."
        repaired = _repair_from_raw(raw, GBVResponse, fallback, language=self.language)
        repaired["category"] = "gbv"  # Safety: always force category
        return repaired
    ```

    4. Update `get_error_response()` â€” keep existing but ensure emergency numbers are always included (they already are).

    **ticket_status_crew.py additions:**

    1. Add `TicketStatusResponse` Pydantic model:
    ```python
    from src.agents.crews.base_crew import BaseCrew, AgentResponse, _repair_from_raw

    class TicketStatusResponse(AgentResponse):
        """Structured output from TicketStatusCrew."""
        action_taken: str = "status_lookup"  # "status_lookup" | "no_tickets" | "details_shown"
        tickets_found: int = 0
    ```

    2. Add `build_task_kwargs()`:
    ```python
    def build_task_kwargs(self, context: dict) -> dict:
        return {"output_pydantic": TicketStatusResponse}
    ```

    3. Update `parse_result()` to use Pydantic + repair + preserve agent tag:
    ```python
    def parse_result(self, result) -> dict[str, Any]:
        if hasattr(result, "pydantic") and result.pydantic is not None:
            model_dict = result.pydantic.model_dump()
            model_dict["raw_output"] = str(result)
            model_dict["agent"] = "ticket_status"
            return model_dict
        raw = str(result)
        fallback = "I'm Gugu from SALGA Trust Engine. I couldn't find that report right now. Please check your tracking number or try again."
        repaired = _repair_from_raw(raw, TicketStatusResponse, fallback, language=self.language)
        repaired["agent"] = "ticket_status"
        return repaired
    ```

    **auth_crew.py updates:**

    1. Add `language` field to `AuthResult` model (currently missing):
    ```python
    class AuthResult(BaseModel):
        authenticated: bool
        user_id: str | None = None
        session_status: str
        municipality_id: str | None = None
        message: str
        language: str = "en"  # NEW: add language tracking
        error: str | None = None
    ```

    2. Update `parse_result()` to use repair when Pydantic path fails:
    After the existing Pydantic path (lines 45-52, keep as-is), update the fallback path to use _repair_from_raw:
    ```python
    from src.agents.crews.base_crew import _repair_from_raw
    # ... in parse_result, after the Pydantic path:
    raw = str(result)
    repaired = _repair_from_raw(raw, AuthResult, "Authentication failed due to an unexpected error. Please try again.", language=self.language)
    # Merge auth-specific defaults for missing fields
    repaired.setdefault("authenticated", False)
    repaired.setdefault("session_status", "failed")
    repaired.setdefault("error", None)
    return repaired
    ```

    CRITICAL: Do NOT add output_pydantic to ManagerCrew. Research confirms this causes issues with Process.hierarchical. ManagerCrew keeps its existing regex parse_result().
  </action>
  <verify>
    Python syntax check on all modified files:
    ```
    OPENAI_API_KEY=dummy python -c "
    from src.agents.crews.base_crew import BaseCrew, AgentResponse, _repair_from_raw
    from src.agents.crews.municipal_crew import MunicipalCrew, MunicipalResponse
    from src.agents.crews.gbv_crew import GBVCrew, GBVResponse
    from src.agents.crews.ticket_status_crew import TicketStatusCrew, TicketStatusResponse
    from src.agents.crews.auth_crew import AuthCrew
    from src.agents.prompts.auth import AuthResult
    # Test repair function
    result = _repair_from_raw('Final Answer: Hello there', MunicipalResponse, 'fallback')
    assert result['message'] == 'Hello there', f'Got: {result}'
    assert result['language'] == 'en'
    # Test AuthResult has language field
    ar = AuthResult(authenticated=True, session_status='active', message='hi', language='zu')
    assert ar.language == 'zu'
    print('All Pydantic models and repair OK')
    "
    ```
  </verify>
  <done>
    All 4 specialist crews have Pydantic output models with output_pydantic on their tasks. AuthResult has language field. Shared _repair_from_raw() in base_crew.py handles graceful fallback. GBV error fallback always includes emergency numbers. ManagerCrew is unchanged (no output_pydantic per research anti-pattern).
  </done>
</task>

<task type="auto">
  <name>Task 2: Fix auth OTP tool type handling and add structured failure logging</name>
  <files>
    src/agents/tools/auth_tool.py
  </files>
  <action>
    **Fix 1: Add tool failure logging module-level infrastructure:**

    Add at top of file, after the existing imports:
    ```python
    import logging
    import time
    from collections import defaultdict

    logger = logging.getLogger("auth_tools")

    # Track failures per tool for repeated failure detection (per locked decision)
    _tool_failure_counts: dict[str, list[float]] = defaultdict(list)

    def _log_tool_failure(tool_name: str, error: str, user_identifier: str) -> None:
        """Log tool failure with context. Flag if 3+ failures in 5 minutes (locked decision).

        Args:
            tool_name: Name of the failed tool
            error: Error message string
            user_identifier: Partial user identifier (truncated for POPIA)
        """
        now = time.time()
        # Prune failures older than 5 minutes
        _tool_failure_counts[tool_name] = [
            t for t in _tool_failure_counts[tool_name] if now - t < 300
        ]
        _tool_failure_counts[tool_name].append(now)

        count = len(_tool_failure_counts[tool_name])
        log_data = {
            "tool": tool_name,
            "error": error,
            "user": user_identifier[:8] + "..." if len(user_identifier) > 8 else user_identifier,
            "failure_count_5min": count,
        }
        if count >= 3:
            logger.critical("URGENT: Repeated tool failures -- %s", log_data)
        else:
            logger.error("Tool failure -- %s", log_data)
    ```

    **Fix 2: Update _send_otp_impl to support should_create_user=False for returning users:**

    Add a `is_returning_user` parameter (default False):
    ```python
    def _send_otp_impl(phone_or_email: str, channel: str = "sms", is_returning_user: bool = False) -> str:
    ```

    In the try block, when channel is NOT "sms" (email path), add should_create_user option:
    ```python
    otp_options = {"email": phone_or_email}
    if is_returning_user:
        otp_options["options"] = {"should_create_user": False}
    client.auth.sign_in_with_otp(otp_options)
    ```

    Similarly for phone path:
    ```python
    otp_options = {"phone": phone_or_email}
    if is_returning_user:
        otp_options["options"] = {"should_create_user": False}
    client.auth.sign_in_with_otp(otp_options)
    ```

    In the except block, call _log_tool_failure before returning:
    ```python
    except Exception as e:
        _log_tool_failure("send_otp_tool", str(e), phone_or_email)
        return f"Error sending OTP: {str(e)}"
    ```

    **Fix 3: Confirm _verify_otp_impl uses correct types:**

    The current code already uses "sms" for phone and "email" for email (lines 78-89). This was fixed in a previous phase. Verify the logic is correct and add failure logging:

    In the except block:
    ```python
    except Exception as e:
        _log_tool_failure("verify_otp_tool", str(e), phone_or_email)
        return f"Error verifying OTP: {str(e)}"
    ```

    **Fix 4: Add failure logging to _create_supabase_user_impl and _lookup_user_impl:**

    In each except block, add _log_tool_failure call before the return:
    ```python
    # In _create_supabase_user_impl:
    except Exception as e:
        _log_tool_failure("create_supabase_user_tool", str(e), phone_or_email)
        return f"Error creating user: {str(e)}"

    # In _lookup_user_impl:
    except Exception as e:
        _log_tool_failure("lookup_user_tool", str(e), phone_or_email)
        return f"Error looking up user: {str(e)}"
    ```

    IMPORTANT: The tool decorator (@tool) signatures must remain compatible. The is_returning_user parameter has a default value so existing callers are not broken.
  </action>
  <verify>
    ```
    OPENAI_API_KEY=dummy python -c "
    from src.agents.tools.auth_tool import (
        _send_otp_impl, _verify_otp_impl,
        _create_supabase_user_impl, _lookup_user_impl,
        _log_tool_failure, _tool_failure_counts,
        send_otp_tool, verify_otp_tool,
        create_supabase_user_tool, lookup_user_tool,
    )
    # Verify _log_tool_failure exists and works
    _log_tool_failure('test_tool', 'test error', '+27821001001')
    assert len(_tool_failure_counts['test_tool']) == 1
    # Verify tools still importable (decorator intact)
    assert send_otp_tool is not None
    assert verify_otp_tool is not None
    print('Auth tools OK')
    "
    ```
  </verify>
  <done>
    Auth OTP tools use correct type="email" for email verification path. send_otp supports should_create_user=False for returning users. All 4 auth tools log failures with context. Repeated failures (3+ in 5 min) logged at CRITICAL level. Tool decorator signatures remain compatible.
  </done>
</task>

</tasks>

<verification>
1. All 4 specialist crews have Pydantic output models (AuthResult, MunicipalResponse, GBVResponse, TicketStatusResponse)
2. ManagerCrew does NOT have output_pydantic (anti-pattern for hierarchical mode)
3. _repair_from_raw() correctly extracts message from "Final Answer: ..." raw strings
4. GBV error fallback always includes emergency numbers
5. Auth tool _send_otp_impl supports is_returning_user parameter
6. _log_tool_failure logs at CRITICAL for 3+ failures in 5 min
7. All files import successfully with no circular imports
</verification>

<success_criteria>
Pydantic output models on all specialist crews with shared repair strategy. Auth OTP tools fixed with correct types and structured failure logging. No regressions in existing imports or tool signatures.
</success_criteria>

<output>
After completion, create `.planning/phases/06.9.1-fix-agent-output-formatting-pydantic-models-auth-otp-tool-failures-and-system-prompt-engineering/06.9.1-02-SUMMARY.md`
</output>
