---
phase: 06.4-dashboard-landing-pages-public-hero-polish-and-citizen-auth-architecture-on-public-portal
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - frontend-public/src/lib/supabase.ts
  - frontend-public/src/contexts/AuthContext.tsx
  - frontend-public/src/hooks/useAuth.ts
  - frontend-public/src/components/auth/ProtectedRoute.tsx
autonomous: true

must_haves:
  truths:
    - "Citizen auth context provides user, session, loading state to entire public app"
    - "Supabase client supports session persistence and token refresh for citizens"
    - "ProtectedRoute redirects unauthenticated users to /login with return URL preserved"
    - "useAuth hook exposes signInWithEmail, signInWithPhone, verifyOtp, signOut, signUp"
  artifacts:
    - path: "frontend-public/src/contexts/AuthContext.tsx"
      provides: "AuthProvider with React Context wrapping Supabase auth state"
      contains: "AuthProvider"
    - path: "frontend-public/src/hooks/useAuth.ts"
      provides: "useAuth hook consuming AuthContext"
      contains: "useAuth"
    - path: "frontend-public/src/components/auth/ProtectedRoute.tsx"
      provides: "Route wrapper redirecting unauthenticated users with return URL"
      contains: "ProtectedRoute"
    - path: "frontend-public/src/lib/supabase.ts"
      provides: "Supabase client with session persistence enabled"
      contains: "persistSession: true"
  key_links:
    - from: "frontend-public/src/hooks/useAuth.ts"
      to: "frontend-public/src/contexts/AuthContext.tsx"
      via: "useContext(AuthContext)"
      pattern: "useContext.*AuthContext"
    - from: "frontend-public/src/components/auth/ProtectedRoute.tsx"
      to: "frontend-public/src/hooks/useAuth.ts"
      via: "useAuth hook for session check"
      pattern: "useAuth"
    - from: "frontend-public/src/contexts/AuthContext.tsx"
      to: "frontend-public/src/lib/supabase.ts"
      via: "supabase.auth methods"
      pattern: "supabase\\.auth"
---

<objective>
Build citizen authentication infrastructure for the public portal (frontend-public).

Purpose: The public portal currently has no authentication — its supabase client explicitly disables session persistence. This plan creates the auth foundation: an AuthContext provider, useAuth hook, and ProtectedRoute wrapper that all subsequent citizen-facing auth features depend on. This reuses the proven pattern from the municipal dashboard (frontend-dashboard/src/hooks/useAuth.ts) adapted for citizen use.

Output: Four files providing the complete auth infrastructure layer for the public portal.
</objective>

<execution_context>
@C:/Users/Bantu/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Bantu/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@frontend-public/src/lib/supabase.ts
@frontend-dashboard/src/hooks/useAuth.ts
@frontend-dashboard/src/lib/supabase.ts
@frontend-public/src/App.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update Supabase client + Create AuthContext provider and useAuth hook</name>
  <files>
    frontend-public/src/lib/supabase.ts
    frontend-public/src/contexts/AuthContext.tsx
    frontend-public/src/hooks/useAuth.ts
  </files>
  <action>
    **1. Update `frontend-public/src/lib/supabase.ts`:**

    Change the Supabase client configuration to support citizen authentication. The current client has `persistSession: false` and `autoRefreshToken: false`. Update to:
    - `persistSession: true` — citizens stay logged in across page refreshes
    - `autoRefreshToken: true` — automatic session refresh
    - `detectSessionInUrl: true` — for OAuth/magic link flows
    - Keep the same VITE_SUPABASE_URL and VITE_SUPABASE_ANON_KEY env vars
    - Add validation for env vars (throw Error if missing, matching dashboard pattern)
    - Update the JSDoc comment to reflect dual-purpose: public anonymous queries AND citizen authentication

    IMPORTANT: This change is backward-compatible. Unauthenticated Supabase queries (RLS views for public data) still work with an authenticated client — the anon key is still used, and RLS policies handle both anon and authenticated roles.

    **2. Create `frontend-public/src/contexts/AuthContext.tsx`:**

    Create an AuthProvider using React Context API. Follow the pattern from the research document (Pattern 2). Include:
    - AuthContextType interface with: `user: User | null`, `session: Session | null`, `loading: boolean`, `signInWithEmail`, `signInWithPhone`, `verifyOtp`, `signUp` (for citizen registration — email+password with optional metadata), `signOut`
    - `signUp` function: calls `supabase.auth.signUp({ email, password, options: { data: metadata } })` where metadata includes `full_name`, `phone` (optional)
    - `signOut` function: calls `supabase.auth.signOut()`, clears sessionStorage, resets state
    - useEffect that: (a) calls `supabase.auth.getSession()` for initial session, (b) subscribes to `supabase.auth.onAuthStateChange` for reactive updates, (c) returns cleanup unsubscribe
    - Export `AuthProvider` component and `useAuth` hook (useContext with error if used outside provider)
    - Import User and Session types from `@supabase/supabase-js`

    **3. Create `frontend-public/src/hooks/useAuth.ts`:**

    This is a thin re-export wrapper for the context hook. Create the file that re-exports useAuth from the context:
    ```
    export { useAuth } from '../contexts/AuthContext';
    ```

    This allows components to import from hooks/ (consistent with dashboard pattern) while the implementation lives in contexts/. This pattern avoids breaking the import convention used by other components.
  </action>
  <verify>
    Run `cd frontend-public && npx tsc --noEmit` to verify TypeScript compiles without errors.
    Verify the three files exist and contain the expected exports.
  </verify>
  <done>
    AuthContext provides signInWithEmail, signInWithPhone, verifyOtp, signUp, signOut with user/session/loading state. Supabase client enables session persistence. useAuth hook is importable from hooks/.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create ProtectedRoute wrapper with return URL preservation</name>
  <files>
    frontend-public/src/components/auth/ProtectedRoute.tsx
  </files>
  <action>
    Create `frontend-public/src/components/auth/ProtectedRoute.tsx` that wraps auth-gated pages.

    The component must:
    1. Import `useAuth` from `../../hooks/useAuth`
    2. Import `Navigate` and `useLocation` from `react-router-dom`
    3. Accept `children: React.ReactNode` prop
    4. Get `user` and `loading` from useAuth()
    5. If `loading` is true, render a centered loading spinner (reuse the same spinner pattern from dashboard App.tsx — a spinning div with teal border-top)
    6. If `!user` (not authenticated):
       - Store current pathname in sessionStorage: `sessionStorage.setItem('returnUrl', location.pathname + location.search)`
       - Return `<Navigate to="/login" state={{ from: location }} replace />`
    7. If user exists, render `<>{children}</>`

    The sessionStorage fallback ensures the return URL survives page refreshes during the login flow (React Router state is lost on refresh). The login page will read from both `location.state?.from` and `sessionStorage.getItem('returnUrl')`.

    Per user decision: "Auth gate happens once per session — after login, citizen navigates freely between all pages." This is naturally satisfied because once authenticated, the ProtectedRoute passes through to children. No per-page re-authentication needed.
  </action>
  <verify>
    Run `cd frontend-public && npx tsc --noEmit` to verify TypeScript compiles.
    Verify the file exists at frontend-public/src/components/auth/ProtectedRoute.tsx and exports ProtectedRoute.
  </verify>
  <done>
    ProtectedRoute component redirects unauthenticated users to /login with return URL preserved in both React Router state and sessionStorage. Authenticated users pass through to children. Loading state shows spinner.
  </done>
</task>

</tasks>

<verification>
1. `cd frontend-public && npx tsc --noEmit` — TypeScript compiles with zero errors
2. All four files exist with correct exports
3. supabase.ts has persistSession: true
4. AuthContext.tsx has AuthProvider and useAuth exports
5. ProtectedRoute.tsx uses Navigate with state={{ from: location }}
</verification>

<success_criteria>
- Citizen auth infrastructure is ready for login/register pages to consume
- ProtectedRoute wrapper is ready to gate My Reports, Report Issue, and Profile routes
- Supabase client supports both anonymous public queries and authenticated citizen sessions
- Pattern matches municipal dashboard auth architecture for consistency
</success_criteria>

<output>
After completion, create `.planning/phases/06.4-dashboard-landing-pages-public-hero-polish-and-citizen-auth-architecture-on-public-portal/06.4-01-SUMMARY.md`
</output>
