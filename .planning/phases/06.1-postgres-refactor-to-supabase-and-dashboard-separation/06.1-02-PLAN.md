---
phase: 06.1-postgres-refactor-to-supabase-and-dashboard-separation
plan: 02
type: execute
wave: 2
depends_on: ["06.1-01"]
files_modified:
  - src/core/security.py
  - src/api/deps.py
  - src/api/v1/auth.py
  - src/schemas/auth.py
  - src/models/whatsapp_session.py
  - src/services/whatsapp_service.py
autonomous: true

must_haves:
  truths:
    - "User registration creates account in Supabase Auth (not local Argon2 hash)"
    - "User login authenticates via Supabase Auth and returns Supabase JWT"
    - "Citizen can register with email + password through Supabase Auth"
    - "Phone OTP registration is configured via Supabase Auth signInWithOtp"
    - "FastAPI validates Supabase JWTs (HS256 with SUPABASE_JWT_SECRET)"
    - "JWT contains app_metadata with role and tenant_id (via custom access token hook)"
    - "get_current_user extracts role and tenant_id from Supabase JWT app_metadata"
    - "WhatsApp phone numbers map to Supabase Auth users via whatsapp_sessions table"
    - "Token refresh handled by Supabase Auth (not custom refresh token logic)"
  artifacts:
    - path: "src/core/security.py"
      provides: "Supabase JWT verification replacing custom JWT/Argon2"
      contains: "SUPABASE_JWT_SECRET"
    - path: "src/api/deps.py"
      provides: "get_current_user extracting from Supabase JWT app_metadata"
      contains: "app_metadata"
    - path: "src/api/v1/auth.py"
      provides: "Register/login endpoints using Supabase Auth"
      contains: "supabase_admin.auth"
    - path: "src/models/whatsapp_session.py"
      provides: "WhatsApp session model linking phone to Supabase user"
      contains: "whatsapp_sessions"
  key_links:
    - from: "src/api/v1/auth.py"
      to: "src/core/supabase.py"
      via: "supabase_admin.auth.admin for user creation"
      pattern: "supabase_admin\\.auth"
    - from: "src/api/deps.py"
      to: "src/core/security.py"
      via: "verify_supabase_token for JWT validation"
      pattern: "verify_supabase_token"
    - from: "src/services/whatsapp_service.py"
      to: "src/models/whatsapp_session.py"
      via: "Phone lookup to find Supabase user ID"
      pattern: "whatsapp_sessions"
---

<objective>
Migrate authentication from custom JWT + Argon2 to Supabase Auth. Replace register/login/refresh endpoints to use Supabase Auth API. Update JWT verification to validate Supabase tokens with role and tenant_id from app_metadata. Create WhatsApp session table for phone-to-user mapping.

Purpose: Supabase Auth replaces the entire custom auth system with OWASP-compliant authentication including automatic token refresh, MFA readiness, phone OTP, and email verification. Per locked decisions, this is a full migration.

Output: All auth flows use Supabase Auth. FastAPI validates Supabase JWTs. WhatsApp users linked to Supabase users.
</objective>

<execution_context>
@C:/Users/Bantu/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Bantu/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06.1-postgres-refactor-to-supabase-and-dashboard-separation/06.1-CONTEXT.md
@.planning/phases/06.1-postgres-refactor-to-supabase-and-dashboard-separation/06.1-RESEARCH.md
@.planning/phases/06.1-postgres-refactor-to-supabase-and-dashboard-separation/06.1-01-SUMMARY.md
@src/core/security.py
@src/api/deps.py
@src/api/v1/auth.py
@src/schemas/auth.py
@src/models/user.py
@src/services/whatsapp_service.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Migrate auth endpoints and JWT verification to Supabase Auth</name>
  <files>
    src/core/security.py
    src/api/deps.py
    src/api/v1/auth.py
    src/schemas/auth.py
  </files>
  <action>
    **Step 1: Rewrite src/core/security.py**
    Replace the entire custom JWT + Argon2 system:
    - Remove: create_access_token, create_refresh_token, decode_access_token, decode_refresh_token, get_password_hash, verify_password, hash_password, PasswordHasher import
    - Add: verify_supabase_token(token: str) -> dict function that:
      - Uses PyJWT to decode with settings.SUPABASE_JWT_SECRET, algorithm HS256, audience "authenticated"
      - Returns decoded payload with sub (user_id), app_metadata (role, tenant_id), email, phone
      - Returns None on any jwt.InvalidTokenError or jwt.ExpiredSignatureError
    - Keep the module importable with backward-compatible names where needed by other modules

    **Step 2: Rewrite src/api/deps.py get_current_user**
    - Replace decode_access_token call with verify_supabase_token
    - Extract user_id from payload["sub"]
    - Extract role from payload.get("app_metadata", {}).get("role") — if role is None, default to "citizen"
    - Extract tenant_id from payload.get("app_metadata", {}).get("tenant_id")
    - Set tenant context from JWT app_metadata tenant_id
    - Query user from database by id (same as before)
    - If user not found in local DB, this is a Supabase Auth user without a local record — create one lazily or return 401

    **Step 3: Rewrite src/api/v1/auth.py endpoints**

    **/register endpoint:**
    - Accept same RegisterRequest (email, password, full_name, phone, municipality_code, consent, preferred_language)
    - Validate municipality exists (same as before)
    - Call supabase_admin.auth.admin.create_user() with:
      - email=registration.email
      - password=registration.password
      - phone=registration.phone (if provided)
      - email_confirm=True (auto-confirm for now, enable email verification later)
      - app_metadata={"role": "citizen", "tenant_id": str(municipality.id)}
      - user_metadata={"full_name": registration.full_name, "preferred_language": registration.preferred_language}
    - Create local User record with the Supabase auth user's ID as the primary key (user.id = supabase_user.id)
    - Hash password field can be set to "supabase_managed" (no longer used locally)
    - Create ConsentRecord as before
    - Return user response (client will use Supabase Auth SDK for actual login)

    **/login endpoint:**
    - Accept LoginRequest (email, password)
    - Call supabase_admin.auth.sign_in_with_password({"email": email, "password": password})
    - Return TokenResponse with access_token and refresh_token from Supabase Auth response
    - On auth error, return 401 with generic "Invalid credentials" message

    **/refresh endpoint:**
    - Accept RefreshRequest with refresh_token
    - Call supabase_admin.auth.refresh_session(refresh_token) — OR instruct client to use Supabase JS SDK refresh (preferred)
    - Return new TokenResponse

    **Step 4: Update src/schemas/auth.py**
    - RegisterRequest: keep as-is (email, password, full_name, etc.)
    - LoginRequest: keep as-is (email, password)
    - Add PhoneOtpRequest schema: phone (str, +27 format)
    - Add VerifyOtpRequest schema: phone (str), token (str, 6-digit OTP)
    - TokenResponse: keep access_token, refresh_token, token_type

    **Step 5: Add phone OTP endpoints to auth.py**
    - POST /api/v1/auth/otp/send — calls supabase_admin.auth.sign_in_with_otp({"phone": phone})
    - POST /api/v1/auth/otp/verify — calls supabase_admin.auth.verify_otp({"phone": phone, "token": token, "type": "sms"})
    - These support the locked decision: "Citizen web portal supports BOTH phone OTP and email + password"
  </action>
  <verify>
    - `python -c "from src.core.security import verify_supabase_token; print('OK')"` succeeds
    - `python -c "from src.api.deps import get_current_user; print('OK')"` succeeds
    - `python -c "from src.api.v1.auth import router; print(len(router.routes))"` shows 5+ routes
    - `python -c "from src.schemas.auth import PhoneOtpRequest, VerifyOtpRequest; print('OK')"` succeeds
  </verify>
  <done>
    Auth endpoints use Supabase Auth for registration, login, refresh, and phone OTP. JWT verification uses Supabase JWT secret. get_current_user extracts role and tenant_id from app_metadata.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create WhatsApp session model and update WhatsApp service for Supabase Auth linking</name>
  <files>
    src/models/whatsapp_session.py
    src/models/__init__.py
    src/services/whatsapp_service.py
  </files>
  <action>
    **Step 1: Create src/models/whatsapp_session.py**
    New SQLAlchemy model:
    ```python
    class WhatsAppSession(NonTenantModel):
        __tablename__ = "whatsapp_sessions"

        phone_number: Mapped[str] = mapped_column(String, primary_key=True)  # Override id from NonTenantModel
        user_id: Mapped[UUID] = mapped_column(nullable=False, index=True)
        tenant_id: Mapped[str] = mapped_column(String, nullable=False, index=True)
        expires_at: Mapped[datetime] = mapped_column(DateTime(timezone=True), nullable=False)
    ```
    Note: This uses NonTenantModel because phone lookups are cross-tenant (per Phase 03 decision). Override primary key to be phone_number instead of UUID id. The expires_at field enforces 24-hour session expiry per research recommendation.

    **Step 2: Create Alembic migration for whatsapp_sessions table**
    Generate and write migration that creates:
    - whatsapp_sessions table with phone_number (PK), user_id, tenant_id, expires_at, created_at, updated_at
    - Index on user_id for reverse lookups
    - Index on expires_at for cleanup queries

    **Step 3: Update src/models/__init__.py**
    Add WhatsAppSession to model imports so Alembic autogenerate detects it.

    **Step 4: Update src/services/whatsapp_service.py**
    Add methods to the WhatsApp service for Supabase Auth user linking:
    - lookup_or_create_session(phone: str, db: AsyncSession) -> WhatsAppSession | None
      - Query whatsapp_sessions by phone_number WHERE expires_at > now()
      - If valid session exists, return it (user is authenticated)
      - If expired or not found, return None (user needs to authenticate via OTP)
    - create_session(phone: str, user_id: UUID, tenant_id: str, db: AsyncSession) -> WhatsAppSession
      - Insert new session with 24-hour expiry
      - Upsert pattern: ON CONFLICT (phone_number) DO UPDATE
    - In the existing webhook handler logic, before processing a message:
      - Lookup session by phone number
      - If session exists and not expired, use session.user_id and session.tenant_id
      - If no session, prompt user to verify via OTP (future: WhatsApp OTP flow)
  </action>
  <verify>
    - `python -c "from src.models.whatsapp_session import WhatsAppSession; print(WhatsAppSession.__tablename__)"` prints "whatsapp_sessions"
    - `alembic heads` shows new migration for whatsapp_sessions
    - `python -c "from src.services.whatsapp_service import WhatsAppService; print('OK')"` succeeds
  </verify>
  <done>
    WhatsApp session model created with phone_number PK, 24hr expiry. WhatsApp service updated to lookup/create sessions for phone-to-user mapping. Migration ready.
  </done>
</task>

</tasks>

<verification>
1. Auth registration creates user in Supabase Auth: verify via `python -c "from src.api.v1.auth import router"` and check route count
2. JWT verification uses Supabase secret: verify security.py imports and functions
3. WhatsApp session model exists with correct schema
4. No import errors across auth-related modules
5. Existing unit tests that don't hit auth endpoints still pass
</verification>

<success_criteria>
- Register endpoint calls supabase_admin.auth.admin.create_user()
- Login endpoint calls supabase_admin.auth.sign_in_with_password()
- Phone OTP endpoints exist (send + verify)
- get_current_user reads role and tenant_id from JWT app_metadata
- WhatsApp session table created with phone-to-user mapping
- Token refresh delegates to Supabase Auth
</success_criteria>

<output>
After completion, create `.planning/phases/06.1-postgres-refactor-to-supabase-and-dashboard-separation/06.1-02-SUMMARY.md`
</output>
