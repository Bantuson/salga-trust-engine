---
phase: 06.1-postgres-refactor-to-supabase-and-dashboard-separation
plan: 05
type: execute
wave: 4
depends_on: ["06.1-02", "06.1-03"]
files_modified:
  - frontend-dashboard/package.json
  - frontend-dashboard/vite.config.ts
  - frontend-dashboard/tsconfig.json
  - frontend-dashboard/tsconfig.app.json
  - frontend-dashboard/tsconfig.node.json
  - frontend-dashboard/index.html
  - frontend-dashboard/src/main.tsx
  - frontend-dashboard/src/App.tsx
  - frontend-dashboard/src/lib/supabase.ts
  - frontend-dashboard/src/hooks/useAuth.ts
  - frontend-dashboard/src/hooks/useRealtimeTickets.ts
  - frontend-dashboard/src/services/api.ts
  - frontend-dashboard/src/pages/LoginPage.tsx
  - frontend-dashboard/src/pages/DashboardPage.tsx
  - frontend-dashboard/src/pages/TicketListPage.tsx
  - frontend-dashboard/src/components/ReportForm.tsx
autonomous: true

must_haves:
  truths:
    - "Municipal dashboard is an independent Vite app in frontend-dashboard/"
    - "Municipal dashboard has its own package.json (not shared with public dashboard)"
    - "Municipal dashboard authenticates via Supabase Auth (email+password and phone OTP)"
    - "Municipal dashboard calls FastAPI backend for all data operations"
    - "Municipal dashboard uses Supabase Realtime for live ticket updates (not SSE)"
    - "Municipal dashboard has login page with role-based redirect"
    - "Dashboard, ticket list, report form, and export functionality all work"
    - "RBAC enforced: different views for MANAGER, ADMIN, WARD_COUNCILLOR, CITIZEN"
  artifacts:
    - path: "frontend-dashboard/package.json"
      provides: "Independent package manifest with Supabase JS client"
      contains: "@supabase/supabase-js"
    - path: "frontend-dashboard/src/lib/supabase.ts"
      provides: "Supabase client with auth session persistence"
      contains: "createClient"
    - path: "frontend-dashboard/src/hooks/useAuth.ts"
      provides: "Authentication hooks (login, logout, session state)"
      contains: "signInWithPassword"
    - path: "frontend-dashboard/src/hooks/useRealtimeTickets.ts"
      provides: "Supabase Realtime subscription for live ticket updates"
      contains: "supabase.channel"
  key_links:
    - from: "frontend-dashboard/src/services/api.ts"
      to: "FastAPI backend"
      via: "axios with Supabase JWT in Authorization header"
      pattern: "Authorization.*Bearer"
    - from: "frontend-dashboard/src/hooks/useAuth.ts"
      to: "frontend-dashboard/src/lib/supabase.ts"
      via: "supabase.auth for session management"
      pattern: "supabase\\.auth"
    - from: "frontend-dashboard/src/hooks/useRealtimeTickets.ts"
      to: "frontend-dashboard/src/lib/supabase.ts"
      via: "supabase.channel for WebSocket subscriptions"
      pattern: "supabase\\.channel"
---

<objective>
Create the municipal operations dashboard as an independent Vite React app in frontend-dashboard/. Migrate all existing dashboard components from frontend/ with Supabase Auth login, Supabase Realtime for live updates, and FastAPI as the data layer.

Purpose: Per locked decision, the municipal dashboard is a separate Vite app deployed independently on Vercel. It authenticates via Supabase Auth and calls FastAPI for all data operations. This separates concerns: the public dashboard can be fully serverless while the municipal dashboard retains FastAPI business logic.

Output: Complete frontend-dashboard/ app with login, dashboard metrics, ticket list, report form, and Supabase Realtime integration.
</objective>

<execution_context>
@C:/Users/Bantu/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Bantu/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@.planning/phases/06.1-postgres-refactor-to-supabase-and-dashboard-separation/06.1-CONTEXT.md
@.planning/phases/06.1-postgres-refactor-to-supabase-and-dashboard-separation/06.1-RESEARCH.md
@.planning/phases/06.1-postgres-refactor-to-supabase-and-dashboard-separation/06.1-02-SUMMARY.md
@.planning/phases/06.1-postgres-refactor-to-supabase-and-dashboard-separation/06.1-03-SUMMARY.md
@frontend/package.json
@frontend/src/App.tsx
@frontend/src/services/api.ts
@frontend/src/services/sse.ts
@frontend/src/pages/DashboardPage.tsx
@frontend/src/pages/TicketListPage.tsx
@frontend/src/components/ReportForm.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Scaffold frontend-dashboard/ Vite app with Supabase Auth</name>
  <files>
    frontend-dashboard/package.json
    frontend-dashboard/vite.config.ts
    frontend-dashboard/tsconfig.json
    frontend-dashboard/tsconfig.app.json
    frontend-dashboard/tsconfig.node.json
    frontend-dashboard/index.html
    frontend-dashboard/.env.example
    frontend-dashboard/src/main.tsx
    frontend-dashboard/src/App.tsx
    frontend-dashboard/src/App.css
    frontend-dashboard/src/lib/supabase.ts
    frontend-dashboard/src/hooks/useAuth.ts
    frontend-dashboard/src/services/api.ts
    frontend-dashboard/src/pages/LoginPage.tsx
  </files>
  <action>
    **Step 1: Create frontend-dashboard/ project structure**
    Initialize as a new Vite React TypeScript project:
    - Copy vite.config.ts, tsconfig files from frontend/ as starting point
    - Create package.json with:
      - name: "frontend-dashboard"
      - Same React/Vite/TypeScript versions as frontend/
      - Add: @supabase/supabase-js (latest 2.x)
      - Keep: @tanstack/react-table, axios, date-fns, recharts, zustand
      - Keep: react-dropzone (for report form)
      - Remove: leaflet, react-leaflet, react-leaflet-heatmap-layer-v3 (public dashboard only)
    - Create .env.example with VITE_SUPABASE_URL, VITE_SUPABASE_ANON_KEY, VITE_API_URL

    **Step 2: Create src/lib/supabase.ts**
    ```typescript
    import { createClient } from '@supabase/supabase-js';

    export const supabase = createClient(
      import.meta.env.VITE_SUPABASE_URL,
      import.meta.env.VITE_SUPABASE_ANON_KEY,
      {
        auth: {
          persistSession: true,
          autoRefreshToken: true,
        }
      }
    );
    ```

    **Step 3: Create src/hooks/useAuth.ts**
    Authentication hook with:
    - signInWithEmail(email: string, password: string) — calls supabase.auth.signInWithPassword
    - signInWithPhone(phone: string) — calls supabase.auth.signInWithOtp({phone})
    - verifyOtp(phone: string, token: string) — calls supabase.auth.verifyOtp
    - signOut() — calls supabase.auth.signOut()
    - session state management via supabase.auth.onAuthStateChange
    - getAccessToken() — returns current session access token for API calls
    - user/session/loading state

    **Step 4: Create src/services/api.ts**
    Migrate from frontend/src/services/api.ts:
    - Keep axios instance pointing to VITE_API_URL (FastAPI backend)
    - Replace hardcoded Bearer token with Supabase session token:
      ```typescript
      api.interceptors.request.use(async (config) => {
        const { data: { session } } = await supabase.auth.getSession();
        if (session?.access_token) {
          config.headers.Authorization = `Bearer ${session.access_token}`;
        }
        return config;
      });
      ```
    - Keep all existing API methods (fetchTickets, fetchDashboardMetrics, exportCSV, etc.)
    - Remove: X-Tenant-ID header injection (tenant comes from JWT now)

    **Step 5: Create src/pages/LoginPage.tsx**
    Login page with:
    - Email + password form (primary)
    - Phone OTP toggle (secondary) — phone input + send OTP button + verify code input
    - Error handling and loading states
    - On success: redirect to dashboard
    - Styled consistently with existing dashboard (same CSS patterns)

    **Step 6: Create src/App.tsx with auth routing**
    ```typescript
    function App() {
      const { session, loading } = useAuth();
      const [currentPage, setCurrentPage] = useState('#dashboard');

      if (loading) return <LoadingSpinner />;
      if (!session) return <LoginPage />;

      return (
        <div className="App">
          <nav>...</nav>
          {currentPage === '#dashboard' && <DashboardPage />}
          {currentPage === '#tickets' && <TicketListPage />}
          {currentPage === '#report' && <ReportForm />}
        </div>
      );
    }
    ```
    - Hash-based routing (same pattern as existing frontend)
    - No public dashboard pages (those go to frontend-public/)
    - Add logout button in nav
  </action>
  <verify>
    - `cd frontend-dashboard && npm install` succeeds
    - `cd frontend-dashboard && npx tsc --noEmit` succeeds (TypeScript compiles)
    - `cd frontend-dashboard && npm run build` produces dist/ with no errors
  </verify>
  <done>
    frontend-dashboard/ scaffolded with Supabase Auth, login page, API service with JWT auth, and app shell with hash routing. All TypeScript compiles. Build succeeds.
  </done>
</task>

<task type="auto">
  <name>Task 2: Migrate dashboard components and add Supabase Realtime</name>
  <files>
    frontend-dashboard/src/pages/DashboardPage.tsx
    frontend-dashboard/src/pages/TicketListPage.tsx
    frontend-dashboard/src/components/ReportForm.tsx
    frontend-dashboard/src/components/dashboard/MetricsCards.tsx
    frontend-dashboard/src/components/dashboard/VolumeChart.tsx
    frontend-dashboard/src/components/dashboard/SLAComplianceChart.tsx
    frontend-dashboard/src/components/dashboard/TeamWorkloadChart.tsx
    frontend-dashboard/src/components/dashboard/FilterBar.tsx
    frontend-dashboard/src/components/dashboard/TicketTable.tsx
    frontend-dashboard/src/components/dashboard/Pagination.tsx
    frontend-dashboard/src/components/dashboard/ExportButton.tsx
    frontend-dashboard/src/components/dashboard/RealtimeIndicator.tsx
    frontend-dashboard/src/components/FileUpload.tsx
    frontend-dashboard/src/components/GeolocationCapture.tsx
    frontend-dashboard/src/hooks/useRealtimeTickets.ts
    frontend-dashboard/src/hooks/useTicketFilters.ts
    frontend-dashboard/src/stores/dashboardStore.ts
    frontend-dashboard/src/types/dashboard.ts
  </files>
  <action>
    **Step 1: Copy and adapt dashboard components from frontend/**
    Copy all dashboard components, pages, hooks, stores, and types from frontend/src/ to frontend-dashboard/src/:
    - pages/DashboardPage.tsx — keep as-is (calls FastAPI via api.ts)
    - pages/TicketListPage.tsx — keep as-is
    - components/dashboard/* — keep all chart components, filter bar, table, pagination, export
    - components/ReportForm.tsx — update file upload to use Supabase Storage SDK:
      ```typescript
      // Instead of presigned POST to S3:
      const { data, error } = await supabase.storage
        .from('evidence')
        .upload(`${tenantId}/${fileId}/${file.name}`, file);
      ```
    - components/FileUpload.tsx — update to use Supabase Storage upload
    - components/GeolocationCapture.tsx — keep as-is (GPS capture unchanged)
    - hooks/useTicketFilters.ts — keep as-is
    - stores/dashboardStore.ts — keep as-is
    - types/dashboard.ts — keep as-is

    **Step 2: Create src/hooks/useRealtimeTickets.ts**
    Replace SSE with Supabase Realtime:
    ```typescript
    import { useEffect, useRef, useState } from 'react';
    import { supabase } from '../lib/supabase';

    export function useRealtimeTickets(municipalityId: string, onUpdate: () => void) {
      const [connected, setConnected] = useState(false);
      const channelRef = useRef<any>(null);

      useEffect(() => {
        if (!municipalityId) return;

        const channel = supabase
          .channel(`municipality:${municipalityId}`)
          .on('broadcast', { event: 'ticket_event' }, (payload) => {
            onUpdate(); // Trigger data refresh
          })
          .on('postgres_changes', {
            event: '*',
            schema: 'public',
            table: 'tickets',
            filter: `tenant_id=eq.${municipalityId}`
          }, (payload) => {
            onUpdate(); // Trigger data refresh on DB changes
          })
          .subscribe((status) => {
            setConnected(status === 'SUBSCRIBED');
          });

        channelRef.current = channel;

        return () => {
          if (channelRef.current) {
            supabase.removeChannel(channelRef.current);
          }
        };
      }, [municipalityId]);

      return { connected };
    }
    ```

    **Step 3: Update DashboardPage to use Supabase Realtime**
    - Replace useSSE hook with useRealtimeTickets
    - On realtime event, re-fetch dashboard metrics from FastAPI
    - Update RealtimeIndicator to show WebSocket connection status instead of SSE

    **Step 4: Remove SSE service**
    - Do NOT copy frontend/src/services/sse.ts or frontend/src/hooks/useSSE.ts
    - All realtime goes through Supabase Realtime WebSocket

    **Step 5: Update ReportForm file uploads**
    - Replace presigned POST upload flow with Supabase Storage direct upload
    - Use supabase.storage.from('evidence').upload() for evidence photos
    - Use supabase.storage.from('documents').upload() for proof of residence
    - For GBV reports, upload to 'gbv-evidence' bucket (only SAPS can read via RLS)
  </action>
  <verify>
    - `cd frontend-dashboard && npm run build` succeeds with no errors
    - `cd frontend-dashboard && npx tsc --noEmit` succeeds
    - All component imports resolve (no missing modules)
    - No references to SSE or Redis in frontend-dashboard/
  </verify>
  <done>
    All dashboard components migrated to frontend-dashboard/. SSE replaced with Supabase Realtime WebSocket. File uploads use Supabase Storage. Build compiles cleanly. Ready for Vercel deployment.
  </done>
</task>

</tasks>

<verification>
1. `cd frontend-dashboard && npm run build` succeeds
2. Login page renders with email + phone OTP options
3. Dashboard page fetches data from FastAPI using Supabase JWT
4. Realtime hook subscribes to Supabase channel (no SSE)
5. File uploads target Supabase Storage (no S3 references)
6. No shared dependencies between frontend-dashboard/ and frontend-public/
7. TypeScript compiles with zero errors
</verification>

<success_criteria>
- Independent Vite app in frontend-dashboard/ with own package.json
- Supabase Auth login (email + password and phone OTP)
- All dashboard pages ported: metrics, ticket list, report form
- API service uses Supabase JWT for FastAPI calls
- Supabase Realtime replaces SSE for live updates
- File uploads via Supabase Storage SDK
- Build succeeds with no errors
</success_criteria>

<output>
After completion, create `.planning/phases/06.1-postgres-refactor-to-supabase-and-dashboard-separation/06.1-05-SUMMARY.md`
</output>
