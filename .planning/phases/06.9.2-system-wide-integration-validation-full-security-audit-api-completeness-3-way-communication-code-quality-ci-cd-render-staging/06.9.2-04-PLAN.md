---
phase: 06.9.2-system-wide-integration-validation
plan: 04
type: execute
wave: 2
depends_on:
  - 06.9.2-01
files_modified:
  - tests/test_api_security_audit.py
  - tests/test_rbac_coverage.py
  - tests/test_gbv_firewall_comprehensive.py
autonomous: true
requirements:
  - SEC-02
  - SEC-03
  - SEC-04
  - SEC-05
  - PLAT-02
  - PLAT-03
  - PLAT-05
  - TKT-01
  - TKT-02

must_haves:
  truths:
    - "Every endpoint that requires auth returns 401 when called without a token"
    - "Every RBAC-restricted endpoint returns 403 when called with wrong role"
    - "SEC-05 GBV firewall holds at all 5 layers (routing, DB, API, storage, public views)"
    - "POPIA endpoints (consent, data rights) are functional and tested"
    - "Rate limiting returns 429 on exceeded limits"
    - "Tenant isolation prevents cross-municipality data access"
  artifacts:
    - path: "tests/test_api_security_audit.py"
      provides: "Comprehensive security tests for all endpoints"
      min_lines: 100
    - path: "tests/test_rbac_coverage.py"
      provides: "RBAC enforcement tests per role per endpoint"
      min_lines: 80
    - path: "tests/test_gbv_firewall_comprehensive.py"
      provides: "GBV 5-layer firewall validation tests"
      min_lines: 60
  key_links:
    - from: "tests/test_api_security_audit.py"
      to: "src/main.py"
      via: "TestClient"
      pattern: "TestClient"
    - from: "tests/test_rbac_coverage.py"
      to: "src/api/deps.py"
      via: "role injection mock"
      pattern: "require_role"
---

<objective>
Create comprehensive security audit tests covering OWASP Top 10, RBAC enforcement, SEC-05 GBV firewall, POPIA compliance, and rate limiting.

Purpose: Validates that all security measures implemented across 52+ plans actually work end-to-end. Tests assess component behavior, failure points, and system design soundness per user direction.

Output: 3 test files covering auth enforcement, RBAC, GBV firewall, POPIA, and rate limiting across all 71 endpoints.
</objective>

<execution_context>
@C:/Users/Bantu/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Bantu/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/main.py
@src/api/deps.py
@tests/conftest.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: API security audit tests — auth enforcement, rate limiting, input validation</name>
  <files>tests/test_api_security_audit.py</files>
  <action>
Create tests/test_api_security_audit.py with the following test structure. Use the existing test patterns from conftest.py (AsyncSession, override dependencies, TestClient).

**Section 1: Auth enforcement on protected endpoints**
Test that calling each protected endpoint WITHOUT a token returns 401.
Group by module — parametrize a list of (method, path) tuples:
```python
PROTECTED_ENDPOINTS = [
    ("GET", "/api/v1/tickets"),
    ("GET", "/api/v1/teams"),
    ("GET", "/api/v1/dashboard/metrics"),
    ("GET", "/api/v1/settings/sla"),
    ("GET", "/api/v1/settings/municipality"),
    ("POST", "/api/v1/teams"),
    ("POST", "/api/v1/reports/submit"),
    ("POST", "/api/v1/invitations/"),
    ("GET", "/api/v1/export/tickets/csv"),
    ("GET", "/api/v1/export/tickets/excel"),
    ("GET", "/api/v1/audit-logs"),
    ("GET", "/api/v1/citizen/reports"),
    ("GET", "/api/v1/onboarding/state"),
    ("POST", "/api/v1/uploads/presigned"),
    ("POST", "/api/v1/verification/submit"),
    ("GET", "/api/v1/events/stream"),
    # ... add ALL protected endpoints
]

@pytest.mark.parametrize("method,path", PROTECTED_ENDPOINTS)
async def test_protected_endpoint_requires_auth(client, method, path):
    """Every protected endpoint must return 401 without auth token."""
    response = getattr(client, method.lower())(path)
    assert response.status_code in (401, 403), f"{method} {path} returned {response.status_code}"
```

**Section 2: Public endpoints accessible without auth**
Test that public endpoints return 200 without auth:
```python
PUBLIC_ENDPOINTS = [
    ("GET", "/api/v1/public/stats"),
    ("GET", "/api/v1/public/municipalities"),
    ("GET", "/api/v1/public/heatmap"),
    ("GET", "/health"),
    ("POST", "/api/v1/access-requests"),
    # public endpoints
]
```

**Section 3: Input validation**
Test that malformed requests return 422 (Pydantic validation):
- POST /api/v1/auth/register with missing fields
- POST /api/v1/reports/submit with empty description
- POST /api/v1/teams with invalid data

**Section 4: Security headers**
Test that responses include security headers:
- X-Content-Type-Options: nosniff
- X-Frame-Options: DENY
- Strict-Transport-Security (in production mode)

**Section 5: Rate limiting triggers 429 on threshold breach**
Send requests in a loop that exceeds a rate-limited endpoint's threshold and assert the final response is 429:
```python
def test_rate_limit_triggers_429(client):
    """After exceeding limit, endpoint returns 429."""
    # SENSITIVE_WRITE_RATE_LIMIT = 30/minute — POST /api/v1/teams is rate-limited
    # Use a mock auth token so the requests reach the rate limiter
    headers = {"Authorization": "Bearer test-token"}
    responses = []
    for _ in range(35):  # exceed 30/minute limit
        r = client.post("/api/v1/teams", json={"name": "X", "category": "water"}, headers=headers)
        responses.append(r.status_code)
    assert 429 in responses, f"Expected 429 in responses after 35 requests, got: {set(responses)}"
```

Use the existing test infrastructure (conftest.py fixtures, TestClient, AsyncSession). Do NOT create real database connections — use SQLite in-memory per existing pattern.
  </action>
  <verify>`pytest tests/test_api_security_audit.py -v --timeout=120 2>&1 | tail -20`</verify>
  <done>Comprehensive auth enforcement tests cover all protected endpoints, public endpoints verified accessible, input validation tested, security headers verified, rate limiting verified (429 on threshold breach)</done>
</task>

<task type="auto">
  <name>Task 2: RBAC coverage tests and GBV firewall comprehensive validation</name>
  <files>tests/test_rbac_coverage.py, tests/test_gbv_firewall_comprehensive.py</files>
  <action>
**File 1: tests/test_rbac_coverage.py**

Test RBAC by mocking authenticated users with different roles and verifying access:

```python
# Test matrix: endpoint x role -> expected status
RBAC_MATRIX = [
    # (method, path, allowed_roles, test_body)
    ("GET", "/api/v1/tickets", ["manager", "admin", "ward_councillor", "field_worker"], None),
    ("GET", "/api/v1/dashboard/metrics", ["manager", "admin", "ward_councillor"], None),
    ("POST", "/api/v1/teams", ["manager", "admin"], {"name": "Test", "category": "water"}),
    ("GET", "/api/v1/export/tickets/csv", ["manager", "admin"], None),
    ("GET", "/api/v1/audit-logs", ["admin"], None),
    ("GET", "/api/v1/settings/sla", ["manager", "admin"], None),
    # ... key endpoints covering all 6 roles
]
```

For each entry:
1. Mock auth to return user with each allowed role -> expect 200 or appropriate success code
2. Mock auth to return user with citizen role (or other non-allowed role) -> expect 403

Use the existing pattern from conftest.py to override `get_current_user` dependency.

**File 2: tests/test_gbv_firewall_comprehensive.py**

Validate SEC-05 GBV 5-layer firewall in one comprehensive test file:

```python
# Layer 1: Routing — GBV tickets route to SAPS teams only
async def test_gbv_routing_to_saps_only():
    """GBV tickets MUST route to is_saps=True teams, never municipal teams."""

# Layer 2: Database RLS — is_sensitive filter on ticket queries
async def test_gbv_tickets_excluded_from_standard_queries():
    """Standard ticket queries (manager role) must filter is_sensitive=True tickets."""

# Layer 3: API — 403 for non-SAPS/admin on GBV endpoints
async def test_gbv_api_403_for_unauthorized_roles():
    """Roles other than saps_liaison and admin get 403 on GBV ticket access."""

# Layer 4: Storage — gbv-evidence bucket access
async def test_gbv_storage_bucket_access_control():
    """Only saps_liaison and admin roles can access gbv-evidence bucket."""

# Layer 5: Public views — exclude is_sensitive=true
async def test_public_views_exclude_sensitive():
    """Public dashboard endpoints NEVER return GBV ticket data."""
```

Also add POPIA compliance tests:
```python
# POPIA: consent capture at registration
async def test_registration_captures_consent():
    """Registration endpoint creates consent record with purpose explanation."""

# POPIA: data access request
async def test_data_access_request():
    """User can request access to their personal data."""

# POPIA: data deletion request
async def test_data_deletion_request():
    """User can request deletion of their data (soft delete + PII anonymization)."""
```

Follow existing test patterns in tests/ — use AsyncMock for database/Supabase calls, mock external services.
  </action>
  <verify>
    - `pytest tests/test_rbac_coverage.py -v --timeout=120 2>&1 | tail -20` — RBAC tests run
    - `pytest tests/test_gbv_firewall_comprehensive.py -v --timeout=120 2>&1 | tail -20` — GBV firewall tests run
  </verify>
  <done>RBAC tested for all 6 roles across key endpoints, GBV firewall validated at all 5 layers, POPIA consent/access/deletion tested</done>
</task>

</tasks>

<verification>
- All 3 test files exist and are importable
- `pytest tests/test_api_security_audit.py tests/test_rbac_coverage.py tests/test_gbv_firewall_comprehensive.py -v` — tests execute
- Security gaps identified during test creation documented in SUMMARY
</verification>

<success_criteria>
- Auth enforcement verified on all protected endpoints (401 without token)
- RBAC verified for key endpoints across all 6 roles
- GBV firewall validated at 5 layers
- POPIA endpoints tested (consent, data access, deletion)
- Rate limiting returns 429 on threshold breach
</success_criteria>

<output>
After completion, create `.planning/phases/06.9.2-system-wide-integration-validation-full-security-audit-api-completeness-3-way-communication-code-quality-ci-cd-render-staging/06.9.2-04-SUMMARY.md`
</output>
