---
phase: 06.2-ux-redesign-user-journeys-design-system-and-dashboard-consistency
plan: 08
type: execute
wave: 1
depends_on: []
files_modified:
  - alembic/versions/XXXX_add_access_requests_onboarding_invitations.py
  - src/models/access_request.py
  - src/models/onboarding_state.py
  - src/models/team_invitation.py
  - src/api/v1/access_requests.py
  - src/api/v1/onboarding.py
  - src/api/v1/invitations.py
  - src/api/v1/citizen.py
  - src/schemas/access_request.py
  - src/schemas/onboarding.py
  - src/schemas/invitation.py
  - src/schemas/citizen.py
  - src/api/v1/__init__.py
autonomous: true

must_haves:
  truths:
    - "Municipality access requests are stored in Supabase with status tracking (pending/approved/rejected)"
    - "Onboarding wizard state persists per municipality in Supabase and can be resumed"
    - "Team invitations are stored in Supabase with email, role, and acceptance status"
    - "Citizens can query their own tickets via API with GBV privacy rules enforced"
    - "Citizen personal analytics endpoint returns total reports, resolved count, avg resolution time"
    - "All new tables have RLS policies matching existing security patterns"
  artifacts:
    - path: "src/models/access_request.py"
      provides: "AccessRequest SQLAlchemy model"
      contains: "class AccessRequest"
    - path: "src/models/onboarding_state.py"
      provides: "OnboardingState SQLAlchemy model"
      contains: "class OnboardingState"
    - path: "src/models/team_invitation.py"
      provides: "TeamInvitation SQLAlchemy model"
      contains: "class TeamInvitation"
    - path: "src/api/v1/access_requests.py"
      provides: "POST /access-requests endpoint for municipality applications"
      contains: "router"
    - path: "src/api/v1/onboarding.py"
      provides: "GET/PUT /onboarding/state endpoint for wizard persistence"
      contains: "router"
    - path: "src/api/v1/invitations.py"
      provides: "POST /invitations endpoint for team member invites"
      contains: "router"
    - path: "src/api/v1/citizen.py"
      provides: "GET /citizen/my-reports and GET /citizen/stats endpoints"
      contains: "router"
  key_links:
    - from: "src/api/v1/citizen.py"
      to: "src/models/ticket.py"
      via: "query tickets by user_id with is_sensitive privacy filtering"
      pattern: "is_sensitive"
    - from: "src/api/v1/access_requests.py"
      to: "src/models/access_request.py"
      via: "CRUD operations on access_requests table"
      pattern: "AccessRequest"
    - from: "src/api/v1/onboarding.py"
      to: "src/models/onboarding_state.py"
      via: "upsert onboarding step data per municipality"
      pattern: "OnboardingState"
---

<objective>
Create all backend infrastructure needed for full-stack integration of Phase 6.2 features: database tables (access_requests, onboarding_state, team_invitations), Alembic migration, SQLAlchemy models, Pydantic schemas, and FastAPI endpoints for municipality access requests, onboarding wizard persistence, team invitations, citizen "My Reports" ticket retrieval, and citizen personal analytics.

Purpose: The user requires full backend integration for all new UI features. No localStorage-only or mock-data approaches. This plan creates the complete API layer that Plans 05 and 06 will consume from the frontend.

Output: 3 new database tables with RLS, 4 new API route modules, corresponding schemas and models.
</objective>

<execution_context>
@C:/Users/Bantu/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Bantu/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06.2-ux-redesign-user-journeys-design-system-and-dashboard-consistency/06.2-CONTEXT.md
@src/models/base.py
@src/models/municipality.py
@src/models/user.py
@src/models/ticket.py
@src/models/sla_config.py
@src/models/team.py
@src/api/deps.py
@src/api/v1/__init__.py
@src/api/v1/tickets.py
@alembic/versions/2026_02_09_1333-385cc1c2d1f2_initial_schema_municipalities_users_consent_audit.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create SQLAlchemy models, Pydantic schemas, and Alembic migration for 3 new tables</name>
  <files>
    src/models/access_request.py
    src/models/onboarding_state.py
    src/models/team_invitation.py
    src/schemas/access_request.py
    src/schemas/onboarding.py
    src/schemas/invitation.py
    src/schemas/citizen.py
    alembic/versions/XXXX_add_access_requests_onboarding_invitations.py
  </files>
  <action>
    **1. Create src/models/access_request.py:**
    ```python
    class AccessRequest(NonTenantModel):
        """Municipality access request - not tenant-scoped since municipality doesn't exist yet."""
        __tablename__ = "access_requests"

        municipality_name: str              # Required
        province: str                       # Required (one of 9 SA provinces)
        municipality_code: str | None       # Optional, e.g. "JHB"
        contact_name: str                   # Required
        contact_email: str                  # Required
        contact_phone: str | None           # Optional
        supporting_docs: str | None         # JSON array of document references (Supabase Storage paths)
        notes: str | None                   # Optional additional notes
        status: str                         # 'pending', 'approved', 'rejected' (default: 'pending')
        reviewed_by: UUID | None            # User ID of admin who reviewed
        reviewed_at: datetime | None        # When review happened
        review_notes: str | None            # Admin notes on decision
    ```
    Use `NonTenantModel` as base (same as Municipality and SLAConfig) since the request exists before a municipality tenant is created.
    Add proper column types: String for text fields, Text for notes, DateTime for reviewed_at.
    Default status to 'pending'.

    **2. Create src/models/onboarding_state.py:**
    ```python
    class OnboardingState(NonTenantModel):
        """Tracks municipality onboarding wizard progress."""
        __tablename__ = "onboarding_state"

        municipality_id: UUID               # FK to municipalities.id
        step_id: str                        # Step identifier: 'profile', 'team', 'wards', 'sla', 'complete'
        step_data: str | None               # JSON string with step form data
        is_completed: bool                  # Whether this step was completed (not skipped)
        completed_at: datetime | None       # When step was completed
    ```
    Use `NonTenantModel` since onboarding is municipality-level, not tenant-scoped.
    Add ForeignKey to municipalities.id.
    Add UniqueConstraint on (municipality_id, step_id) to allow upsert pattern.

    **3. Create src/models/team_invitation.py:**
    ```python
    class TeamInvitation(TenantAwareModel):
        """Pending team member invitations from onboarding wizard."""
        __tablename__ = "team_invitations"

        municipality_id: UUID               # FK to municipalities.id
        email: str                          # Invitee email
        role: str                           # Role to assign: 'manager', 'ward_councillor', 'field_worker'
        invited_by: UUID                    # FK to users.id (the admin who invited)
        status: str                         # 'pending', 'accepted', 'expired' (default: 'pending')
        accepted_at: datetime | None        # When invitation was accepted
        expires_at: datetime | None         # Expiry timestamp
    ```
    Use `TenantAwareModel` since invitations are tenant-scoped.
    Add ForeignKeys to municipalities.id and users.id.

    **4. Create Pydantic schemas:**

    **src/schemas/access_request.py:**
    - `AccessRequestCreate`: municipality_name, province (validated enum of 9 provinces), municipality_code?, contact_name, contact_email, contact_phone?, notes?
    - `AccessRequestResponse`: all fields + id, created_at, status
    - `AccessRequestReview`: status ('approved'|'rejected'), review_notes?

    **src/schemas/onboarding.py:**
    - `OnboardingStepSave`: step_id, step_data (dict/JSON), is_completed
    - `OnboardingStepResponse`: step_id, step_data, is_completed, completed_at
    - `OnboardingProgressResponse`: municipality_id, steps: list[OnboardingStepResponse], overall_progress: float (0-100)

    **src/schemas/invitation.py:**
    - `TeamInvitationCreate`: email, role (validated enum: manager, ward_councillor, field_worker)
    - `TeamInvitationBulkCreate`: invitations: list[TeamInvitationCreate]
    - `TeamInvitationResponse`: all fields + id, created_at, status

    **src/schemas/citizen.py:**
    - `CitizenTicketResponse`: tracking_number, category, status, created_at, address, severity, assigned_to_name?, assigned_team_name?, media_count: int, is_sensitive
    - `CitizenGBVTicketResponse`: tracking_number, status, assigned_officer_name?, station_name?, station_phone? (limited fields only)
    - `CitizenMyReportsResponse`: tickets: list[CitizenTicketResponse | CitizenGBVTicketResponse], total: int
    - `CitizenStatsResponse`: total_reports: int, resolved_count: int, avg_resolution_days: float | None, municipality_avg_resolution_days: float | None

    **5. Create Alembic migration:**
    Generate migration file using: `cd src && python -m alembic revision --autogenerate -m "add_access_requests_onboarding_invitations"`
    If autogenerate isn't available, create a manual migration file.

    The migration must create 3 tables:
    - `access_requests` with all columns from the model
    - `onboarding_state` with UniqueConstraint on (municipality_id, step_id)
    - `team_invitations` with ForeignKeys

    **6. Add RLS policies to the migration:**
    After creating the tables, add RLS policies following existing patterns from the codebase:

    ```sql
    -- access_requests: Platform admins can read all, anyone can insert (public form)
    ALTER TABLE access_requests ENABLE ROW LEVEL SECURITY;
    CREATE POLICY "Anyone can submit access request" ON access_requests
        FOR INSERT WITH CHECK (true);
    CREATE POLICY "Admins can view access requests" ON access_requests
        FOR SELECT USING (
            (current_setting('request.jwt.claims', true)::json->>'role') IN ('admin', 'platform_admin')
        );
    CREATE POLICY "Admins can update access requests" ON access_requests
        FOR UPDATE USING (
            (current_setting('request.jwt.claims', true)::json->>'role') IN ('admin', 'platform_admin')
        );

    -- onboarding_state: Municipality admins can read/write their own
    ALTER TABLE onboarding_state ENABLE ROW LEVEL SECURITY;
    CREATE POLICY "Municipality admins manage own onboarding" ON onboarding_state
        FOR ALL USING (
            municipality_id::text = (current_setting('request.jwt.claims', true)::json->>'municipality_id')
        );

    -- team_invitations: Tenant-scoped via tenant_id
    ALTER TABLE team_invitations ENABLE ROW LEVEL SECURITY;
    CREATE POLICY "Tenant isolation for invitations" ON team_invitations
        FOR ALL USING (
            tenant_id = (current_setting('request.jwt.claims', true)::json->>'tenant_id')
        );
    ```
    NOTE: Check the existing RLS patterns in earlier migrations (e.g., `2026_02_11_0915-29fc6e5ac39c_migrate_rls_to_supabase_auth.py`) and follow the EXACT same JWT claim extraction pattern. The above is illustrative -- match the actual pattern used in the codebase.

    **7. Run the migration:**
    ```bash
    cd C:/Users/Bantu/mzansi-agentive/salga-trust-engine && python -m alembic upgrade head
    ```
    If running against remote Supabase, use the Supabase MCP apply_migration tool instead.
  </action>
  <verify>
    - `ls src/models/access_request.py src/models/onboarding_state.py src/models/team_invitation.py` -- all model files exist
    - `ls src/schemas/access_request.py src/schemas/onboarding.py src/schemas/invitation.py src/schemas/citizen.py` -- all schema files exist
    - `grep "class AccessRequest" src/models/access_request.py` -- model defined
    - `grep "class OnboardingState" src/models/onboarding_state.py` -- model defined
    - `grep "class TeamInvitation" src/models/team_invitation.py` -- model defined
    - `grep "access_requests" alembic/versions/*access_requests*` -- migration exists
    - `grep "ROW LEVEL SECURITY" alembic/versions/*access_requests*` -- RLS policies included
  </verify>
  <done>
    3 new SQLAlchemy models (AccessRequest, OnboardingState, TeamInvitation) with matching Pydantic schemas. Alembic migration creates tables with proper foreign keys, constraints, and RLS policies. Migration applied successfully.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create FastAPI endpoints for access requests, onboarding, invitations, and citizen portal</name>
  <files>
    src/api/v1/access_requests.py
    src/api/v1/onboarding.py
    src/api/v1/invitations.py
    src/api/v1/citizen.py
    src/api/v1/__init__.py
  </files>
  <action>
    **1. Create src/api/v1/access_requests.py:**

    ```python
    router = APIRouter(prefix="/access-requests", tags=["access-requests"])
    ```

    **POST /access-requests** (public, no auth required):
    - Accepts AccessRequestCreate body
    - Validates province is one of 9 SA provinces
    - Creates AccessRequest record with status='pending'
    - Returns AccessRequestResponse with 201 status
    - NOTE: This endpoint does NOT require authentication (it's a public form)
    - Rate limit: consider adding basic rate limiting (IP-based) to prevent spam

    **GET /access-requests** (admin only):
    - Requires auth: admin or platform_admin role
    - Returns list of all access requests, optionally filtered by status
    - Query params: status? ('pending'|'approved'|'rejected'), page?, page_size?

    **PATCH /access-requests/{id}/review** (admin only):
    - Requires auth: admin or platform_admin role
    - Accepts AccessRequestReview body (status, review_notes)
    - Updates request status, sets reviewed_by, reviewed_at
    - If approved: optionally trigger municipality creation (or just mark approved for manual follow-up)
    - Returns updated AccessRequestResponse

    **2. Create src/api/v1/onboarding.py:**

    ```python
    router = APIRouter(prefix="/onboarding", tags=["onboarding"])
    ```

    **GET /onboarding/state** (authenticated, admin/manager):
    - Returns full onboarding progress for the current user's municipality
    - Query OnboardingState records where municipality_id matches user's municipality
    - Calculate overall_progress: (completed_steps / total_steps) * 100
    - Total steps = 5 (profile, team, wards, sla, complete)
    - Returns OnboardingProgressResponse

    **PUT /onboarding/state/{step_id}** (authenticated, admin/manager):
    - Upsert onboarding step data
    - step_id must be one of: 'profile', 'team', 'wards', 'sla', 'complete'
    - Accepts OnboardingStepSave body
    - If record exists for (municipality_id, step_id): update step_data, is_completed
    - If not: create new record
    - Returns OnboardingStepResponse

    **POST /onboarding/complete** (authenticated, admin/manager):
    - Marks onboarding as complete
    - Sets 'complete' step to is_completed=true
    - Could also update municipality.is_active or a separate onboarding_completed flag
    - Returns success message

    **3. Create src/api/v1/invitations.py:**

    ```python
    router = APIRouter(prefix="/invitations", tags=["invitations"])
    ```

    **POST /invitations** (authenticated, admin/manager):
    - Accepts TeamInvitationCreate body (single invite)
    - Creates TeamInvitation with status='pending', sets invited_by to current user
    - Sets tenant_id from current user's tenant
    - Sets municipality_id from current user's municipality
    - Sets expires_at to 7 days from now
    - Returns TeamInvitationResponse with 201 status

    **POST /invitations/bulk** (authenticated, admin/manager):
    - Accepts TeamInvitationBulkCreate body (list of invitations)
    - Creates multiple TeamInvitation records
    - Returns list of TeamInvitationResponse

    **GET /invitations** (authenticated, admin/manager):
    - Returns all invitations for current municipality
    - Query params: status? ('pending'|'accepted'|'expired')

    **DELETE /invitations/{id}** (authenticated, admin/manager):
    - Cancel/delete a pending invitation
    - Only works if status is 'pending'

    **4. Create src/api/v1/citizen.py:**

    ```python
    router = APIRouter(prefix="/citizen", tags=["citizen"])
    ```

    **GET /citizen/my-reports** (authenticated, citizen role):
    - Returns tickets created by the current user (user_id match)
    - For NON-sensitive tickets: return full CitizenTicketResponse
    - For sensitive tickets (is_sensitive=True): return CitizenGBVTicketResponse with ONLY:
      - tracking_number, status
      - assigned SAPS officer name (join users table on assigned_to where role=saps_liaison)
      - assigned team station info (join teams table where is_saps=True)
      - No description, no address, no photos, no detailed info
    - Query params: status? (filter by ticket status), page?, page_size?
    - Sort: newest first (created_at DESC)
    - Returns CitizenMyReportsResponse

    **GET /citizen/stats** (authenticated, citizen role):
    - Returns personal analytics for the current user:
      - total_reports: COUNT of tickets where user_id = current_user.id
      - resolved_count: COUNT of tickets where user_id = current_user.id AND status IN ('resolved', 'closed')
      - avg_resolution_days: AVG of (resolved_at - created_at) in days for resolved tickets by this user
      - municipality_avg_resolution_days: AVG of (resolved_at - created_at) in days for ALL resolved tickets in user's municipality (for comparison)
    - Uses SQL aggregation queries for performance
    - Returns CitizenStatsResponse

    NOTE for GBV privacy in citizen endpoint: The existing tickets.py endpoint already has GBV access control (SEC-05). The citizen endpoint MUST also enforce this:
    - Citizens can see their OWN GBV tickets (they reported it)
    - But only limited fields are returned (no description, address, evidence)
    - This is different from the staff ticket endpoint where SAPS_LIAISON sees full details

    **5. Update src/api/v1/__init__.py:**
    - Import and include the 4 new routers:
      ```python
      from src.api.v1.access_requests import router as access_requests_router
      from src.api.v1.onboarding import router as onboarding_router
      from src.api.v1.invitations import router as invitations_router
      from src.api.v1.citizen import router as citizen_router
      ```
    - Add to the main API router with appropriate prefix

    **Build verification:**
    ```bash
    cd C:/Users/Bantu/mzansi-agentive/salga-trust-engine && python -c "from src.api.v1.access_requests import router; from src.api.v1.onboarding import router; from src.api.v1.invitations import router; from src.api.v1.citizen import router; print('All routers import successfully')"
    ```
  </action>
  <verify>
    - `ls src/api/v1/access_requests.py src/api/v1/onboarding.py src/api/v1/invitations.py src/api/v1/citizen.py` -- all API files exist
    - `grep "access.requests" src/api/v1/__init__.py` -- router registered
    - `grep "onboarding" src/api/v1/__init__.py` -- router registered
    - `grep "invitations" src/api/v1/__init__.py` -- router registered
    - `grep "citizen" src/api/v1/__init__.py` -- router registered
    - `grep "my-reports\|my_reports" src/api/v1/citizen.py` -- citizen reports endpoint
    - `grep "is_sensitive" src/api/v1/citizen.py` -- GBV privacy filtering
    - `grep "avg_resolution\|resolved_count\|total_reports" src/api/v1/citizen.py` -- analytics queries
    - `grep "POST\|post" src/api/v1/access_requests.py` -- POST endpoint exists
    - `grep "upsert\|PUT\|put" src/api/v1/onboarding.py` -- upsert endpoint exists
    - `python -c "from src.api.v1 import access_requests, onboarding, invitations, citizen"` -- imports work
  </verify>
  <done>
    4 new API route modules: access_requests (public submit + admin review), onboarding (wizard state persistence with upsert), invitations (single + bulk create), citizen (my-reports with GBV privacy + personal stats with aggregations). All routers registered in __init__.py. Python imports successful.
  </done>
</task>

</tasks>

<verification>
1. All 3 new tables exist in database (access_requests, onboarding_state, team_invitations)
2. RLS policies applied following existing codebase patterns
3. Access request can be submitted without authentication (public form)
4. Onboarding state can be saved/loaded per municipality (authenticated)
5. Team invitations can be created individually and in bulk (authenticated)
6. Citizen can query their own tickets with GBV privacy enforcement
7. Citizen stats endpoint returns aggregated analytics
8. All new routers registered and importable
9. `python -m pytest tests/ -x` passes (or at minimum, imports don't break existing tests)
</verification>

<success_criteria>
- POST /api/v1/access-requests creates a new access request record
- GET /api/v1/onboarding/state returns wizard progress for authenticated user's municipality
- PUT /api/v1/onboarding/state/{step_id} upserts step data
- POST /api/v1/invitations creates a team invitation
- GET /api/v1/citizen/my-reports returns user's tickets with GBV privacy
- GET /api/v1/citizen/stats returns personal analytics with municipality comparison
- All endpoints follow existing RBAC patterns from src/api/deps.py
</success_criteria>

<output>
After completion, create `.planning/phases/06.2-ux-redesign-user-journeys-design-system-and-dashboard-consistency/06.2-08-SUMMARY.md`
</output>
