---
phase: 01-foundation-security
plan: 05
type: execute
wave: 3
depends_on: ["01-02", "01-03"]
files_modified:
  - src/api/v1/municipalities.py
  - src/schemas/municipality.py
  - alembic/versions/rls_policies.py
  - src/core/database.py
  - src/models/base.py
  - src/main.py
  - tests/test_multitenancy.py
  - tests/test_municipalities.py
autonomous: true

must_haves:
  truths:
    - "Admin can create, list, and manage municipalities via API"
    - "PostgreSQL RLS policies enforce that queries only return rows matching current tenant"
    - "Application-level SQLAlchemy event listener provides backup tenant filtering (defense-in-depth)"
    - "A user in Municipality A cannot see data belonging to Municipality B even with direct SQL"
    - "Tenant context is set from authenticated user's JWT claim (not from client-provided header alone)"
  artifacts:
    - path: "src/api/v1/municipalities.py"
      provides: "Municipality CRUD endpoints (admin-only)"
      exports: ["router"]
    - path: "src/schemas/municipality.py"
      provides: "Municipality Pydantic schemas"
      contains: "MunicipalityCreate"
    - path: "alembic/versions/rls_policies.py"
      provides: "Alembic migration adding RLS policies to all tenant-aware tables"
      contains: "ENABLE ROW LEVEL SECURITY"
    - path: "src/models/base.py"
      provides: "Updated TenantAwareModel with SQLAlchemy query filter event"
      contains: "do_orm_execute"
    - path: "tests/test_multitenancy.py"
      provides: "Multi-tenant isolation tests"
      contains: "test_cross_tenant_isolation"
  key_links:
    - from: "alembic/versions/rls_policies.py"
      to: "src/models/user.py"
      via: "RLS policy on users table"
      pattern: "tenant_isolation.*users"
    - from: "src/core/database.py"
      to: "src/core/tenant.py"
      via: "sets PostgreSQL session variable for RLS on each connection"
      pattern: "SET LOCAL app\\.current_tenant"
    - from: "src/models/base.py"
      to: "src/core/tenant.py"
      via: "SQLAlchemy event filters queries by tenant_id"
      pattern: "do_orm_execute"
    - from: "src/api/v1/municipalities.py"
      to: "src/api/deps.py"
      via: "admin-only access via require_role"
      pattern: "require_role.*ADMIN"
---

<objective>
Implement municipality management API and defense-in-depth multi-tenant data isolation: PostgreSQL Row-Level Security (RLS) policies enforced at the database level, plus application-level SQLAlchemy query filtering as backup. This ensures that even if application code has a bug, the database itself prevents cross-tenant data access.

Purpose: PLAT-01 requires complete data isolation between municipalities. This is the most critical security feature -- a single cross-tenant data leak would destroy trust in the entire platform. Defense-in-depth (RLS + app-level) means two independent layers must both fail for a breach to occur.
Output: Municipality CRUD API, RLS policies on all tenant-aware tables, application-level tenant filtering, proven cross-tenant isolation tests.
</objective>

<execution_context>
@C:/Users/Bantu/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Bantu/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-foundation-security/01-RESEARCH.md
@.planning/phases/01-foundation-security/01-01-SUMMARY.md
@.planning/phases/01-foundation-security/01-02-SUMMARY.md
@.planning/phases/01-foundation-security/01-03-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Municipality management API</name>
  <files>
    src/api/v1/municipalities.py
    src/schemas/municipality.py
    src/main.py
    tests/test_municipalities.py
  </files>
  <action>
    **src/schemas/municipality.py:** Create municipality Pydantic schemas:
    - MunicipalityCreate(BaseModel): name (str, min 3 max 100), code (str, min 2 max 10, uppercase),
      province (str -- validate against list: "Eastern Cape", "Free State", "Gauteng", "KwaZulu-Natal",
      "Limpopo", "Mpumalanga", "Northern Cape", "North West", "Western Cape"),
      population (int, optional, ge=0), contact_email (EmailStr, optional)
    - MunicipalityUpdate(BaseModel): name (optional), contact_email (optional), is_active (optional), population (optional)
    - MunicipalityResponse(BaseModel): id, name, code, province, population, is_active, contact_email, created_at
      model_config = ConfigDict(from_attributes=True)

    **src/api/v1/municipalities.py:** Create municipalities router with APIRouter(prefix="/api/v1/municipalities", tags=["Municipalities"]):

    POST / (create municipality -- admin only):
    - Depends(require_role(UserRole.ADMIN))
    - Accept MunicipalityCreate schema
    - Validate code uniqueness (return 409 if duplicate)
    - Validate name uniqueness (return 409 if duplicate)
    - Create Municipality record
    - Return 201 with MunicipalityResponse
    - NOTE: This endpoint does NOT require tenant context (municipalities are above tenant scope).
      Add "/api/v1/municipalities" to TenantContextMiddleware EXCLUDED_PATHS -- but it still requires auth.

    GET / (list municipalities -- admin only):
    - Depends(require_role(UserRole.ADMIN))
    - Return list of all municipalities (paginated: limit/offset query params, default limit=50)
    - Include is_active filter query param

    GET /{municipality_id} (get municipality -- admin only):
    - Depends(require_role(UserRole.ADMIN))
    - Return single MunicipalityResponse or 404

    PATCH /{municipality_id} (update municipality -- admin only):
    - Depends(require_role(UserRole.ADMIN))
    - Accept MunicipalityUpdate, apply non-None fields
    - Return updated MunicipalityResponse

    IMPORTANT: Municipality endpoints need auth but NOT tenant context (they manage tenants themselves).
    Add to TenantContextMiddleware excluded paths: paths starting with "/api/v1/municipalities"

    **src/main.py:** Register municipalities router.

    **tests/test_municipalities.py:** Create municipality tests:
    - test_create_municipality: Admin creates municipality, verify 201
    - test_create_municipality_non_admin: Citizen tries to create, verify 403
    - test_create_duplicate_code: Create two with same code, verify 409
    - test_list_municipalities: List returns created municipalities
    - test_update_municipality: Update name, verify changed
    - test_invalid_province: Create with invalid province, verify 422
  </action>
  <verify>
    Run: pytest tests/test_municipalities.py -v
    If database not available, verify endpoints in docs:
    - uvicorn src.main:app --reload
    - Check /docs shows municipality endpoints with admin-only security
  </verify>
  <done>
    Municipality CRUD API works with admin-only access control. Validates province names against SA province list. Enforces unique code and name. Municipality endpoints excluded from tenant context requirement. Tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: PostgreSQL RLS policies and application-level tenant filtering</name>
  <files>
    alembic/versions/rls_policies.py
    src/core/database.py
    src/models/base.py
    tests/test_multitenancy.py
  </files>
  <action>
    **Alembic migration for RLS policies:**
    Run: alembic revision -m "add_rls_policies"
    This creates a new migration file. Edit it to add RLS policies:

    In upgrade():
    ```python
    # Create application role (if not exists)
    op.execute("DO $$ BEGIN IF NOT EXISTS (SELECT FROM pg_roles WHERE rolname = 'app_user') THEN CREATE ROLE app_user; END IF; END $$;")

    # Enable RLS on all tenant-aware tables
    for table in ['users', 'consent_records']:
        op.execute(f"ALTER TABLE {table} ENABLE ROW LEVEL SECURITY;")
        op.execute(f"ALTER TABLE {table} FORCE ROW LEVEL SECURITY;")  # FORCE makes RLS apply even to table owner

        # Create tenant isolation policy
        op.execute(f"""
            CREATE POLICY tenant_isolation_{table} ON {table}
            USING (tenant_id = current_setting('app.current_tenant', true))
        """)

        # Grant permissions to app role
        op.execute(f"GRANT SELECT, INSERT, UPDATE, DELETE ON {table} TO app_user;")
    ```

    In downgrade():
    ```python
    for table in ['users', 'consent_records']:
        op.execute(f"DROP POLICY IF EXISTS tenant_isolation_{table} ON {table};")
        op.execute(f"ALTER TABLE {table} DISABLE ROW LEVEL SECURITY;")
    ```

    NOTE: Use current_setting('app.current_tenant', true) -- the `true` parameter makes it return NULL instead of error if the setting doesn't exist. Combined with USING clause, NULL tenant = no rows returned = fail closed.

    **src/core/database.py:** Add connection-level tenant context for RLS:

    Add SQLAlchemy event listener on connection checkout/begin:
    ```python
    from sqlalchemy import event, text

    @event.listens_for(engine.sync_engine, "connect")
    def set_search_path(dbapi_connection, connection_record):
        """Set default search path on new connections."""
        # Optional: set schema if using schema-per-tenant in future
        pass

    # For async: use after_begin on session
    @event.listens_for(AsyncSessionLocal, "after_begin")
    def set_tenant_rls_context(session, transaction, connection):
        """Set PostgreSQL session variable for RLS on every transaction start."""
        tenant_id = get_tenant_context()
        if tenant_id:
            connection.execute(
                text("SET LOCAL app.current_tenant = :tenant_id"),
                {"tenant_id": tenant_id}
            )
    ```

    CRITICAL: Use SET LOCAL (not SET) -- SET LOCAL is scoped to the current transaction and automatically resets when the transaction ends. This prevents tenant context leakage in connection pools (research pitfall 1).

    **src/models/base.py:** Add application-level tenant filtering (defense-in-depth):

    Add SQLAlchemy do_orm_execute event listener:
    ```python
    @event.listens_for(Session, "do_orm_execute")
    def add_tenant_filter(orm_execute_state):
        """Backup tenant filtering at application level (defense-in-depth with RLS)."""
        if not orm_execute_state.is_select:
            return  # Only filter SELECT queries

        # Skip if this is a raw text query (not ORM)
        if not hasattr(orm_execute_state, 'bind_mapper') or orm_execute_state.bind_mapper is None:
            return

        tenant_id = get_tenant_context()

        # Check if the mapper's class has tenant_id (is tenant-aware)
        mapper_class = orm_execute_state.bind_mapper.class_
        if not hasattr(mapper_class, 'tenant_id'):
            return  # NonTenantModel, skip filtering

        if tenant_id is None:
            # FAIL CLOSED: no tenant context for tenant-aware query = deny
            raise SecurityError("Tenant context not set for tenant-aware query - potential data leakage")

        # Add tenant_id filter using options
        orm_execute_state.statement = orm_execute_state.statement.options(
            with_loader_criteria(TenantAwareModel, TenantAwareModel.tenant_id == tenant_id)
        )
    ```

    Alternative simpler approach if with_loader_criteria is complex:
    Use the `statement` attribute directly to add a WHERE clause:
    ```python
    orm_execute_state.statement = orm_execute_state.statement.where(
        mapper_class.tenant_id == tenant_id
    )
    ```

    Create custom SecurityError exception class in src/core/audit.py or a new src/core/exceptions.py.

    **tests/test_multitenancy.py:** Create cross-tenant isolation tests:
    - test_cross_tenant_isolation: Create users in Municipality A and Municipality B.
      Set tenant context to A, query users, verify ONLY A's users returned.
      Set tenant context to B, query users, verify ONLY B's users returned.
    - test_no_tenant_context_fails_closed: Clear tenant context, attempt tenant-aware query,
      verify SecurityError is raised (not an empty result set -- fail closed, not fail open).
    - test_create_user_gets_tenant_id: Create user with tenant context set, verify tenant_id column matches.
    - test_rls_policy_exists: Connect to database and verify RLS is enabled on users table:
      SELECT relrowsecurity FROM pg_class WHERE relname = 'users' (should be True).
    - test_set_local_resets_after_transaction: Verify SET LOCAL app.current_tenant is transaction-scoped
      and doesn't leak to next transaction.

    IMPORTANT: If PostgreSQL is not available, create the migration file and test stubs.
    Mark database-dependent tests with @pytest.mark.skipif(not DB_AVAILABLE, reason="PostgreSQL required").
  </action>
  <verify>
    Run: pytest tests/test_multitenancy.py -v
    Run: pytest tests/test_municipalities.py -v
    If database available, verify RLS:
    - alembic upgrade head
    - Connect to DB and check: SELECT tablename, policyname FROM pg_policies;
    If database not available, verify migration file exists and contains CREATE POLICY statements.
  </verify>
  <done>
    PostgreSQL RLS policies enabled on users and consent_records tables with FORCE ROW LEVEL SECURITY. SET LOCAL app.current_tenant used per-transaction for RLS context (no connection pool leakage). Application-level SQLAlchemy event listener provides backup filtering. Fail-closed behavior: missing tenant context raises SecurityError. Cross-tenant isolation tests prove Municipality A cannot see Municipality B's data. Defense-in-depth: two independent layers prevent cross-tenant leakage.
  </done>
</task>

</tasks>

<verification>
1. Admin can create municipality with valid SA province
2. Non-admin users get 403 on municipality endpoints
3. RLS migration file contains CREATE POLICY with tenant_isolation
4. SET LOCAL app.current_tenant is used (not SET -- prevents pool leakage)
5. Application-level filter raises SecurityError when tenant context is missing
6. Cross-tenant query test proves isolation: user in tenant A invisible to tenant B
7. Municipalities endpoints work without tenant context header
</verification>

<success_criteria>
- Municipality CRUD works with admin-only RBAC
- PostgreSQL RLS enabled with FORCE on all tenant-aware tables
- Application-level tenant filtering as defense-in-depth backup
- Fail-closed: missing tenant context = SecurityError (not empty results)
- Cross-tenant isolation proven by tests
- SET LOCAL used for connection-pool-safe tenant context
- 3+ pilot municipalities can be created and managed
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-security/01-05-SUMMARY.md`
</output>
