---
phase: 06.7-municipal-intake-agent-testing
plan: 02
type: execute
wave: 2
depends_on: ["06.7-01"]
files_modified:
  - src/agents/crews/auth_crew.py
  - src/agents/prompts/auth.py
  - src/agents/config/agents.yaml
  - src/agents/config/tasks.yaml
autonomous: true

must_haves:
  truths:
    - "AuthCrew class follows the same pattern as MunicipalCrew and GBVCrew"
    - "Auth agent uses trilingual prompts (EN/ZU/AF) for conversational registration flow"
    - "Auth crew supports dual registration paths (phone-first or email-first) per locked decision"
    - "Auth crew has memory=False to prevent PII retention across sessions"
    - "YAML config has auth_agent and auth_task entries"
  artifacts:
    - path: "src/agents/crews/auth_crew.py"
      provides: "AuthCrew class with create_crew() and kickoff()"
      contains: "class AuthCrew"
    - path: "src/agents/prompts/auth.py"
      provides: "Trilingual auth agent prompts"
      contains: "AUTH_PROMPTS"
    - path: "src/agents/config/agents.yaml"
      provides: "auth_agent YAML config entry"
      contains: "auth_agent"
    - path: "src/agents/config/tasks.yaml"
      provides: "auth_task YAML config entry"
      contains: "auth_task"
  key_links:
    - from: "src/agents/crews/auth_crew.py"
      to: "src/agents/tools/auth_tool.py"
      via: "tool imports"
      pattern: "from src.agents.tools.auth_tool import"
    - from: "src/agents/crews/auth_crew.py"
      to: "src/agents/prompts/auth.py"
      via: "prompt import"
      pattern: "AUTH_PROMPTS"
---

<objective>
Create the AuthCrew — a CrewAI crew that handles conversational citizen authentication with dual registration paths (phone or email), OTP verification, and proof of residence requirement before municipality assignment.

Purpose: The auth agent gates all report access. No citizen can submit a ticket without completing authentication first. This crew mirrors the existing MunicipalCrew/GBVCrew pattern but handles the registration/re-authentication conversation.

Output: AuthCrew class, trilingual auth prompts, and YAML config entries.
</objective>

<execution_context>
@C:/Users/Bantu/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Bantu/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@src/agents/crews/municipal_crew.py
@src/agents/crews/gbv_crew.py
@src/agents/prompts/municipal.py
@src/agents/prompts/gbv.py
@src/agents/config/agents.yaml
@src/agents/config/tasks.yaml
@src/agents/flows/state.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create trilingual auth prompts</name>
  <files>src/agents/prompts/auth.py</files>
  <action>
Create `src/agents/prompts/auth.py` with trilingual authentication prompts. Follow the exact pattern from `src/agents/prompts/municipal.py` and `src/agents/prompts/gbv.py`.

The AUTH_PROMPTS dict should have keys "en", "zu", "af" with conversational backstory text for each language.

Key requirements for the prompt content:
1. **Dual registration path** — Agent must ask "Would you like to register with your phone number or email address?" and adapt the flow based on user choice.
2. **Phone path**: collect phone -> send OTP -> verify OTP -> collect name + email -> proof of residence upload -> municipality assignment
3. **Email path**: collect email -> send OTP -> verify OTP -> collect name + phone -> proof of residence upload -> municipality assignment
4. **Returning users**: If context shows user_exists=True and session_status=expired, ask for OTP re-authentication only (no password flow).
5. **Proof of residence REQUIRED** before municipality assignment (strict, not deferred).
6. **Conversational tone** — not like a form. Guide the user naturally through steps.
7. **GBV same auth** — Sensitivity handled at intake level, not auth level.

Also create an AUTH_TASK_TEMPLATE string that the AuthCrew will format with context variables. The template should include placeholders for: `{user_exists}`, `{session_status}`, `{user_id}`, `{phone}`, `{language}`, `{conversation_history}`.

For returning users (user_exists=True, session_status=expired), the task should instruct the agent to only request OTP verification, not full registration.

For new users (user_exists=False), the task should instruct the agent to run the full dual-path registration flow.

Also create an AuthResult Pydantic model for the crew output:
```python
from pydantic import BaseModel

class AuthResult(BaseModel):
    authenticated: bool
    user_id: str | None = None
    session_status: str  # "active", "created", "failed"
    municipality_id: str | None = None
    message: str  # Response message to citizen
    error: str | None = None
```
  </action>
  <verify>
Run `python -c "from src.agents.prompts.auth import AUTH_PROMPTS, AUTH_TASK_TEMPLATE, AuthResult; assert 'en' in AUTH_PROMPTS; assert 'zu' in AUTH_PROMPTS; assert 'af' in AUTH_PROMPTS; print('OK')"`.
  </verify>
  <done>AUTH_PROMPTS has EN/ZU/AF entries with conversational dual-path registration guidance. AUTH_TASK_TEMPLATE has context placeholders. AuthResult Pydantic model exists.</done>
</task>

<task type="auto">
  <name>Task 2: Create AuthCrew class and update YAML configs</name>
  <files>src/agents/crews/auth_crew.py, src/agents/config/agents.yaml, src/agents/config/tasks.yaml</files>
  <action>
**AuthCrew** (`src/agents/crews/auth_crew.py`):

Create an AuthCrew class that mirrors MunicipalCrew and GBVCrew structure:

```python
class AuthCrew:
    def __init__(self, language: str = "en", llm=None):
        self.language = language if language in ["en", "zu", "af"] else "en"
        self.llm = llm  # Will be passed from crew server (LLM object, not string)

    def create_crew(self, context: dict) -> Crew:
        """Create auth crew for registration or re-authentication.

        Args:
            context: Dict with keys: user_exists (bool), session_status (str),
                     user_id (str|None), phone (str), conversation_history (str)
        """
        ...

    async def kickoff(self, context: dict) -> dict:
        """Run auth crew. Uses run_in_executor for sync crew.kickoff()."""
        ...
```

Key implementation details:
1. Import tools from `src/agents/tools/auth_tool.py`: send_otp_tool, verify_otp_tool, create_supabase_user_tool, lookup_user_tool
2. Import AUTH_PROMPTS and AUTH_TASK_TEMPLATE from `src/agents/prompts/auth.py`
3. Import AuthResult from `src/agents/prompts/auth.py` for output_pydantic
4. Set `memory=False` on the Crew (same as GBVCrew — PII in auth conversations)
5. Set `max_iter=15` (auth needs more turns than intake — full registration is 6+ steps)
6. Set `allow_delegation=False`
7. Set `verbose=False`
8. The `llm` parameter accepts either an LLM object or None. If None, import and call `get_deepseek_llm()` from `src/agents/llm.py` as default.
9. The `kickoff()` method should use `asyncio.get_event_loop().run_in_executor(None, ...)` to run the synchronous `crew.kickoff()` in a thread pool.
10. Format AUTH_TASK_TEMPLATE with context dict values.

**YAML Configs**:

Append to `src/agents/config/agents.yaml`:
```yaml
auth_agent:
  role: "Citizen Authentication Specialist"
  goal: "Register or re-authenticate citizens in {language} before they can submit reports"
  backstory: >
    You are an authentication specialist for South African municipal services.
    You guide citizens through account registration or re-authentication.
    You must verify identity via OTP before allowing access to report submission.
    Always respond in {language}. Be conversational, not like a form.
  allow_delegation: false
  max_iter: 15
  verbose: false
```

Append to `src/agents/config/tasks.yaml`:
```yaml
auth_task:
  description: >
    Authenticate a citizen for municipal service reporting.
    Phone: {phone}
    Language: {language}
    User exists: {user_exists}
    Session status: {session_status}

    If returning user with expired session: request OTP re-authentication only.
    If new user: offer phone or email registration path, then collect full details.
    Proof of residence is REQUIRED before municipality assignment.
  expected_output: >
    Authenticated user with active session, or clear error message explaining
    what step failed and how to retry.
```
  </action>
  <verify>
Run `python -c "from src.agents.crews.auth_crew import AuthCrew; crew = AuthCrew(language='en'); print('OK')"` to confirm import.
Check agents.yaml contains "auth_agent" entry.
Check tasks.yaml contains "auth_task" entry.
  </verify>
  <done>AuthCrew class exists with create_crew() and kickoff() methods. memory=False, max_iter=15. YAML configs updated with auth_agent and auth_task entries.</done>
</task>

</tasks>

<verification>
1. `python -c "from src.agents.prompts.auth import AUTH_PROMPTS; assert len(AUTH_PROMPTS) == 3"` passes
2. `python -c "from src.agents.crews.auth_crew import AuthCrew; c = AuthCrew(); print(c.language)"` prints "en"
3. agents.yaml contains auth_agent entry
4. tasks.yaml contains auth_task entry
5. AuthCrew uses memory=False on Crew creation
6. All existing tests still pass: `pytest tests/ -x --ignore=tests/integration -q`
</verification>

<success_criteria>
- AuthCrew class mirrors MunicipalCrew/GBVCrew patterns
- Trilingual prompts guide conversational dual-path registration
- memory=False prevents PII retention
- max_iter=15 accommodates multi-step auth flow
- YAML config entries added for auth_agent and auth_task
- AuthResult Pydantic model provides structured output
</success_criteria>

<output>
After completion, create `.planning/phases/06.7-municipal-intake-agent-testing-deepseek-llm-streamlit-chat-dashboard-auth-agent-phone-detection-api-first-security/06.7-02-SUMMARY.md`
</output>
