---
phase: 06.7-municipal-intake-agent-testing
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/core/config.py
  - src/agents/tools/auth_tool.py
  - src/services/phone_detection.py
autonomous: true

must_haves:
  truths:
    - "Settings class loads DEEPSEEK_API_KEY, DEEPSEEK_BASE_URL, CREW_SERVER_URL, and CREW_SERVER_API_KEY from environment"
    - "get_deepseek_llm() factory returns a crewai.LLM object configured for DeepSeek V3.2"
    - "detect_phone_session() deterministically returns user_exists, session_status, user_id from WhatsAppSession table"
    - "Auth tools (send_otp, verify_otp, create_supabase_user, lookup_user) wrap existing Supabase Admin SDK calls as synchronous CrewAI tools"
  artifacts:
    - path: "src/core/config.py"
      provides: "DeepSeek and crew server env var fields"
      contains: "DEEPSEEK_API_KEY"
    - path: "src/agents/tools/auth_tool.py"
      provides: "Synchronous CrewAI tools for auth agent"
      contains: "@tool"
    - path: "src/services/phone_detection.py"
      provides: "Deterministic phone session lookup"
      contains: "detect_phone_session"
  key_links:
    - from: "src/agents/tools/auth_tool.py"
      to: "src/core/supabase.py"
      via: "get_supabase_admin()"
      pattern: "get_supabase_admin"
    - from: "src/services/phone_detection.py"
      to: "src/models/whatsapp_session.py"
      via: "WhatsAppSession query"
      pattern: "WhatsAppSession"
---

<objective>
Create the foundation layer for Phase 06.7: DeepSeek LLM configuration, deterministic phone detection service, and synchronous auth tools for CrewAI.

Purpose: These are the building blocks that the auth crew (Plan 02) and crew server (Plan 03) depend on. Config provides env vars, phone detection provides session lookup, and auth tools provide the Supabase operations the auth agent will invoke.

Output: Three new/updated files providing LLM factory, phone detection, and auth tool implementations.
</objective>

<execution_context>
@C:/Users/Bantu/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Bantu/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@src/core/config.py
@src/core/supabase.py
@src/models/whatsapp_session.py
@src/agents/tools/ticket_tool.py
@src/agents/tools/saps_tool.py
@src/api/v1/auth.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add DeepSeek config fields and LLM factory to settings</name>
  <files>src/core/config.py</files>
  <action>
Add the following fields to the Settings class in src/core/config.py:

```python
# DeepSeek LLM
DEEPSEEK_API_KEY: str = Field(default="", description="DeepSeek API key for LLM")
DEEPSEEK_BASE_URL: str = Field(
    default="https://api.deepseek.com/v1",
    description="DeepSeek API base URL (OpenAI-compatible)"
)

# Crew Server
CREW_SERVER_URL: str = Field(
    default="http://localhost:8001",
    description="URL of the crew server for Streamlit to connect to"
)
CREW_SERVER_API_KEY: str = Field(
    default="",
    description="API key for crew server authentication (dev tool security)"
)
```

Also create a new module `src/agents/llm.py` with a `get_deepseek_llm()` factory function:

```python
from crewai import LLM
from src.core.config import settings

def get_deepseek_llm() -> LLM:
    """Factory for DeepSeek V3.2 LLM via OpenAI-compatible endpoint.

    Uses LiteLLM format 'deepseek/deepseek-chat' for provider routing.
    """
    return LLM(
        model="deepseek/deepseek-chat",
        base_url=settings.DEEPSEEK_BASE_URL,
        api_key=settings.DEEPSEEK_API_KEY,
        temperature=0.7,
        max_tokens=2048,
    )
```

The factory is separate from config.py to avoid circular imports (config is imported everywhere).
  </action>
  <verify>
Run `python -c "from src.core.config import settings; print('DEEPSEEK_API_KEY' in settings.model_fields)"` and confirm it prints True.
Run `python -c "from src.agents.llm import get_deepseek_llm; print(type(get_deepseek_llm))"` and confirm it imports without error.
  </verify>
  <done>Settings class has DEEPSEEK_API_KEY, DEEPSEEK_BASE_URL, CREW_SERVER_URL, CREW_SERVER_API_KEY fields. get_deepseek_llm() factory exists and returns crewai.LLM object.</done>
</task>

<task type="auto">
  <name>Task 2: Build phone detection service and auth tools</name>
  <files>src/services/phone_detection.py, src/agents/tools/auth_tool.py</files>
  <action>
**Phone Detection Service** (`src/services/phone_detection.py`):

Create a deterministic (no LLM) phone detection module that queries the existing WhatsAppSession model. This is code-based per locked decision — NOT an agent.

```python
"""Deterministic phone session detection for intake routing.

NOT an agent — this is pure code-based lookup against WhatsAppSession table.
Triggers on session start only. Returns minimal context for auth agent routing.
"""
from sqlalchemy.orm import Session
from src.models.whatsapp_session import WhatsAppSession

def _normalize_phone(phone_number: str) -> str:
    """Normalize phone to E.164 format (South African).

    Converts 0XX to +27XX format. Preserves already-E.164 numbers.
    """
    phone = phone_number.strip()
    if phone.startswith("0") and len(phone) == 10:
        phone = "+27" + phone[1:]
    if not phone.startswith("+"):
        phone = "+" + phone
    return phone

def detect_phone_session(phone_number: str, db_session: Session) -> dict:
    """Deterministic phone detection — no LLM involved.

    Returns minimal context: user_exists, session_status, user_id.
    Per locked decision: detection triggers on session start only.
    """
    normalized = _normalize_phone(phone_number)

    session = db_session.query(WhatsAppSession).filter(
        WhatsAppSession.phone_number == normalized
    ).first()

    if session is None:
        return {"user_exists": False, "session_status": "none", "user_id": None}

    if session.is_expired:
        return {"user_exists": True, "session_status": "expired", "user_id": str(session.user_id)}

    return {"user_exists": True, "session_status": "active", "user_id": str(session.user_id)}
```

**Auth Tools** (`src/agents/tools/auth_tool.py`):

Create synchronous CrewAI tools that wrap existing Supabase Admin SDK calls. Follow the exact pattern from ticket_tool.py (implementation function + @tool wrapper). Tools needed:

1. `send_otp_tool` — Sends OTP via phone (SMS) or email. Wraps `supabase.auth.sign_in_with_otp()`.
2. `verify_otp_tool` — Verifies OTP code. Wraps `supabase.auth.verify_otp()`.
3. `create_supabase_user_tool` — Creates Supabase Auth user with app_metadata (role=citizen, tenant_id) and user_metadata (full_name, residence_verified, preferred_language). Wraps `supabase.auth.admin.create_user()`.
4. `lookup_user_tool` — Looks up user by phone or email in Supabase Auth. Wraps `supabase.auth.admin.list_users()` with filter.

Each tool must:
- Be synchronous (CrewAI requirement)
- Use `get_supabase_admin()` from `src/core/supabase.py`
- Return string messages (not complex objects) for LLM consumption
- Handle exceptions gracefully (return error string, never raise)
- Follow the `_impl` + `@tool` wrapper pattern from ticket_tool.py

Critical: Set `memory=False` reasoning — auth tools handle PII (phone, email, OTP). Keep tool implementations stateless.

Do NOT create a tool for proof of residence upload — per research Pitfall 5, that's handled as a separate API call outside the agent conversation, passing document_id to a simpler verification tool.
  </action>
  <verify>
Run `python -c "from src.services.phone_detection import detect_phone_session; print('OK')"` to confirm import.
Run `python -c "from src.agents.tools.auth_tool import send_otp_tool, verify_otp_tool, create_supabase_user_tool, lookup_user_tool; print('OK')"` to confirm all tools import.
  </verify>
  <done>Phone detection service returns {user_exists, session_status, user_id} from WhatsAppSession lookup. Four auth tools (send_otp, verify_otp, create_user, lookup_user) exist as synchronous CrewAI tools wrapping Supabase Admin SDK.</done>
</task>

</tasks>

<verification>
1. `python -c "from src.core.config import Settings; s = Settings.model_fields; assert 'DEEPSEEK_API_KEY' in s"` passes
2. `python -c "from src.agents.llm import get_deepseek_llm"` imports without error
3. `python -c "from src.services.phone_detection import detect_phone_session"` imports without error
4. `python -c "from src.agents.tools.auth_tool import send_otp_tool, verify_otp_tool, create_supabase_user_tool, lookup_user_tool"` imports without error
5. All existing tests still pass: `pytest tests/ -x --ignore=tests/integration -q`
</verification>

<success_criteria>
- Settings class loads 4 new env vars (DEEPSEEK_API_KEY, DEEPSEEK_BASE_URL, CREW_SERVER_URL, CREW_SERVER_API_KEY)
- get_deepseek_llm() returns crewai.LLM object with deepseek/deepseek-chat model
- detect_phone_session() queries WhatsAppSession and returns minimal context dict
- Four auth tools exist as synchronous @tool-wrapped functions
- No regressions in existing test suite
</success_criteria>

<output>
After completion, create `.planning/phases/06.7-municipal-intake-agent-testing-deepseek-llm-streamlit-chat-dashboard-auth-agent-phone-detection-api-first-security/06.7-01-SUMMARY.md`
</output>
