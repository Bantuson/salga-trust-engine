# Phase 06.9: Multi-Agent Manager Refactor — Research

**Researched:** 2026-02-18
**Domain:** CrewAI hierarchical routing, multi-crew orchestration, Flow-based intent routing
**Confidence:** MEDIUM — CrewAI 1.8.1 verified in codebase; hierarchical process has documented pitfalls that affect architecture decisions

---

<user_constraints>
## User Constraints (from CONTEXT.md)

### Locked Decisions

**Manager Routing Logic**
- Full LLM-based classification (no keyword lists) — manager uses the LLM to understand citizen intent and route to the correct specialist
- CrewAI `Process.hierarchical` with a `manager_agent` — native delegation, not custom routing code
- 5 routing categories: greeting, municipal report, GBV report, ticket status, auth
- Off-topic messages handled with warm redirect — Gugu explains she handles municipal services and GBV reporting, asks how she can help with those

**Greeting & Handoff Flow**
- Manager greets first, then routes — Gugu welcome message comes from the manager, not specialists
- For generic messages ("Hi"), manager greets warmly and asks citizen's intent to determine routing
- Specialist keeps control until task completes OR citizen interrupts with out-of-scope intent
- Intent interruption: if citizen shifts intent mid-conversation (e.g., mentions GBV while checking ticket status), specialist confirms whether to switch, then manager re-routes if citizen agrees
- Post-task: specialist sends closing summary (tracking number, next steps), then manager follows up with "Is there anything else I can help you with?"
- Manager receives full context pass-through from specialist outcomes (ticket created, auth complete, etc.) for informed follow-up

**Ticket Status Agent (NEW)**
- Dual lookup: tracking number search AND smart lookup by authenticated user's phone — always scoped to the authenticated user only (no cross-user data access)
- Ticket details shown: current status plus timeline of changes (created -> assigned -> in progress -> resolved)
- Multiple tickets: show most recent ticket's detail first, then offer "You have X more open reports — want to see them?"
- GBV tickets: visible but minimal info only (status, SAPS officer, station phone, emergency numbers) — consistent with existing citizen portal GBV card pattern (SEC-05)

**Auth Integration**
- Existing phone detection logic (`crew_server.py` session_status, user_exists, user_id) passes to manager agent as context — no new detection code needed
- Auth is demand-driven, NOT auto-triggered — manager only routes to auth when citizen's intent requires it (submitting a report or checking ticket status)
- Auth-free intents: general info questions ("what is this platform?", "what do you do?", "how does this work?") do not require authentication
- Auth-gated intents: submitting a new report and checking ticket status require authentication
- Post-auth routing covers both cases:
  - Generic initial message ("Hi") → after auth, manager asks intent
  - Intent-bearing initial message ("I want to report a water leak") → manager remembers original intent, routes to correct specialist without citizen repeating
- Returning authenticated users: if recent in-progress conversation exists, offer to resume where they left off; otherwise clean slate with "Welcome back! What can I help you with?"

### Claude's Discretion
- Exact CrewAI hierarchical process configuration (manager_llm, manager_agent setup)
- How intent memory is stored between auth and post-auth routing (conversation state vs flow state)
- Specialist interrupt detection implementation (prompt-based vs tool-based)
- Conversation history injection pattern for manager context awareness
- How to refactor crew_server.py to use the new manager-based routing

### Deferred Ideas (OUT OF SCOPE)
None — discussion stayed within phase scope
</user_constraints>

---

<phase_requirements>
## Phase Requirements

| ID | Description | Research Support |
|----|-------------|-----------------|
| AI-01 | System uses CrewAI-based agentic architecture with manager agent receiving all incoming messages | Manager crew pattern with Process.hierarchical or Flow-based routing; existing BaseCrew foundation |
| AI-02 | Manager agent analyzes message content and routes to appropriate specialist agent by category | LLM classification via manager agent task; 5-category routing (greeting/municipal/gbv/ticket_status/auth) |
| AI-03 | Specialist agent for municipal services handles report capture and ticket creation | Existing MunicipalCrew — no replacement, receives delegated context |
| AI-04 | Specialist agent for GBV/domestic violence/abuse handles sensitive report capture | Existing GBVCrew — no replacement, receives delegated context |
| AI-05 | Each specialist agent conducts structured conversational intake | Already implemented in existing crews; manager preserves conversation handoff |
| AI-06 | Agents support English, isiZulu, and Afrikaans (detect language, respond in kind) | Existing lingua-based detection + YAML backstory trilingual prompts preserved |
| AI-07 | All agent interactions have guardrails preventing inappropriate responses or data leakage | Existing guardrails engine preserved; manager task descriptions include guardrail instructions |
</phase_requirements>

---

## Summary

Phase 06.9 replaces the keyword-based `IntakeFlow` router and imperative routing in `whatsapp_service.py` with a CrewAI manager agent that performs full LLM-based intent classification and delegates to specialist crews. The locked decision is `Process.hierarchical` with a `manager_agent` — but research reveals significant pitfalls with this pattern in CrewAI 1.8.1 that the planner must navigate carefully.

**The core tension:** The decision locks in `Process.hierarchical` + `manager_agent`, but multiple verified reports show CrewAI's hierarchical process has persistent bugs in 1.8.x — specifically, manager agents often fail to delegate and instead execute all tasks themselves. The working mitigation is: use the hierarchical process as the user decided, but structure the implementation so the manager's task description does explicit intent classification and routing instructions with detailed coworker role names that match specialist agent roles exactly. This aligns with the "custom step-wise manager" fix documented in the community.

**The additional new component** is the TicketStatusCrew — a new specialist crew following the existing `BaseCrew` pattern, adding a `lookup_ticket_tool` that queries Supabase for tickets owned by the authenticated user.

**The architectural strategy** that resolves the discretion areas: store `pending_intent` and `pre_auth_context` in the `ConversationState` (Redis-backed, already in place) so intent survives the auth handoff. The manager's Flow state holds the routing decision; Redis holds the cross-turn context.

**Primary recommendation:** Use `Process.hierarchical` with an explicit `manager_agent` (Gugu persona, `allow_delegation=True`, no tools), passing `manager_llm=get_deepseek_llm()` as a duplicate safety net since the framework sometimes ignores `manager_agent.llm` and defaults to OpenAI. Structure specialist agents with `allow_delegation=False` and exact role names that the manager references in its task prompt.

---

## Standard Stack

### Core
| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| crewai | 1.8.1 (installed) | Multi-agent orchestration, hierarchical process | Already in use; all existing crews built on it |
| crewai.Agent | 1.8.1 | Manager and specialist agent definitions | Core CrewAI primitive |
| crewai.Crew | 1.8.1 | Process.hierarchical orchestration container | Only way to use hierarchical process |
| crewai.Process | 1.8.1 | `Process.hierarchical` for manager delegation | User-locked decision |
| crewai.LLM | 1.8.1 | LLM configuration (DeepSeek via OpenAI-compatible endpoint) | Existing pattern in `src/agents/llm.py` |
| pydantic BaseModel | 2.x (via crewai deps) | Flow state, manager result typing | Already used across codebase |
| supabase-py | >=2.27.3 | Ticket lookup in TicketStatusCrew tool | Already in pyproject.toml |
| redis.asyncio | via redis==5.2.0 | ConversationState persistence for pending_intent | Already in place |

### Supporting
| Library | Version | Purpose | When to Use |
|---------|---------|---------|-------------|
| crewai.tools.tool | 1.8.1 | `@tool` decorator for TicketStatusCrew lookup_ticket_tool | New tool for ticket status lookup |
| crewai.Task | 1.8.1 | Manager task (classification + routing) and specialist tasks | One manager task; specialist tasks via existing BaseCrew.create_crew() |
| lingua-language-detector | >=2.0.0 | Language detection (EN/ZU/AF) | Keep existing detection before manager invocation |

### Alternatives Considered
| Instead of | Could Use | Tradeoff |
|------------|-----------|----------|
| Process.hierarchical + manager_agent | CrewAI Flow with @router decorator | Flow router is more reliable (no delegation bugs), but user locked in hierarchical process |
| Redis ConversationState for pending_intent | Flow Pydantic state (self.state) | Flow state is per-execution; Redis survives across turns — Redis is correct choice for WhatsApp multi-turn |
| Single manager task with 5-route prompt | Separate routing task + specialist tasks | Single task simpler, avoids task-assignment confusion in hierarchical mode |

---

## Architecture Patterns

### Recommended Project Structure

```
src/agents/
├── crews/
│   ├── base_crew.py          # UNCHANGED — existing BaseCrew foundation
│   ├── auth_crew.py          # UNCHANGED — specialist, called by manager
│   ├── municipal_crew.py     # UNCHANGED — specialist, called by manager
│   ├── gbv_crew.py           # UNCHANGED — specialist, called by manager
│   ├── ticket_status_crew.py # NEW — follows BaseCrew pattern
│   ├── manager_crew.py       # NEW — ManagerCrew with Process.hierarchical
│   └── __init__.py           # UPDATE — export ManagerCrew, TicketStatusCrew
├── config/
│   ├── agents.yaml           # UPDATE — add manager_agent, ticket_status_agent entries
│   └── tasks.yaml            # UPDATE — add manager_task, ticket_status_task entries
├── tools/
│   ├── ticket_tool.py        # UNCHANGED
│   ├── auth_tool.py          # UNCHANGED
│   ├── saps_tool.py          # UNCHANGED
│   └── ticket_lookup_tool.py # NEW — lookup tickets by user_id or tracking_number
├── flows/
│   ├── intake_flow.py        # REPLACE — remove keyword classification, call ManagerCrew
│   └── state.py              # UPDATE — add pending_intent, pending_crew fields
└── llm.py                    # UNCHANGED
```

### Pattern 1: ManagerCrew with Process.hierarchical

**What:** A single Crew with `Process.hierarchical`, `manager_agent=gugu_manager`, and all specialist agents as workers. The manager task prompt contains LLM-based intent classification + delegation instructions that name each specialist by their exact `role` string.

**When to use:** Every incoming citizen message enters through ManagerCrew. ManagerCrew decides routing based on the message, conversation history, and auth context passed in as task inputs.

**Critical implementation detail (HIGH confidence):** In CrewAI 1.8.x hierarchical mode, the manager agent is the **only** agent in `self.agents`; specialist agents are available as "coworkers" to delegate to via the `delegate_work` tool. The manager must have `allow_delegation=True` and specialist agents must have `allow_delegation=False`. The `delegate_work` tool accepts `task` (str), `context` (str), and `coworker` (the exact role string of the specialist agent).

```python
# Source: CrewAI official docs + verified community pattern
from crewai import Agent, Crew, Process, Task, LLM

class ManagerCrew:
    """Manager crew that handles all first-contact routing."""

    def create_crew(self, context: dict) -> Crew:
        llm = get_deepseek_llm()

        # Manager agent — Gugu persona, no tools, allow_delegation=True
        manager = Agent(
            role="Municipal Services Manager",
            goal="Greet citizens, understand their intent, and route them to the right specialist",
            backstory=...,   # Gugu persona from agents.yaml
            allow_delegation=True,
            llm=llm,
        )

        # Specialist agents — same config as existing crews, allow_delegation=False
        auth_agent = Agent(role="Citizen Authentication Specialist", allow_delegation=False, llm=llm, ...)
        municipal_agent = Agent(role="Municipal Services Intake Specialist", allow_delegation=False, llm=llm, tools=[create_municipal_ticket], ...)
        gbv_agent = Agent(role="Crisis Support Specialist", allow_delegation=False, llm=llm, tools=[create_municipal_ticket, notify_saps], ...)
        ticket_status_agent = Agent(role="Ticket Status Specialist", allow_delegation=False, llm=llm, tools=[lookup_ticket_tool], ...)

        # Single manager task — contains the routing logic in the description
        manager_task = Task(
            description=build_manager_task_description(context),  # See Pattern 2
            expected_output="Citizen helped and task delegated to appropriate specialist",
            agent=manager,
        )

        crew = Crew(
            agents=[auth_agent, municipal_agent, gbv_agent, ticket_status_agent],
            tasks=[manager_task],
            manager_agent=manager,
            process=Process.hierarchical,
            manager_llm=llm,  # CRITICAL: also set manager_llm to prevent OpenAI fallback
            memory=False,
            verbose=False,
        )
        return crew
```

**Why `manager_llm` even when `manager_agent` is set:** Verified community report (2025): when using non-OpenAI models, the hierarchical process ignores `manager_agent.llm` and falls back to OpenAI if `manager_llm` is not also explicitly set. Setting both is the safe pattern.

### Pattern 2: Manager Task Description for LLM Routing

**What:** The manager task description does the heavy lifting — it tells the LLM exactly what to classify and who to delegate to. This is the "custom step-wise manager" fix for the delegation bug.

**When to use:** Build the task description per-message with full citizen context.

```python
def build_manager_task_description(context: dict) -> str:
    """Build the manager routing task with explicit delegation instructions."""
    return f"""
You are Gugu, the SALGA Trust Engine municipal services manager.

CITIZEN CONTEXT:
- Phone: {context['phone']}
- Language: {context['language']}
- Session status: {context['session_status']}  # "none" | "active" | "expired"
- User exists: {context['user_exists']}
- User ID: {context['user_id']}
- Message: {context['message']}
- Conversation history: {context['conversation_history']}
- Pending intent (if any): {context.get('pending_intent', 'none')}

STEP 1: GREET (if this is the first message or a fresh session)
If session_status is "none" or "expired" and this is a new conversation,
greet warmly as Gugu. Ask how you can help.

STEP 2: CLASSIFY INTENT
Based on the citizen's message, classify as one of:
- "greeting": Generic hello/hi with no specific intent
- "auth": Citizen needs to register or re-authenticate
- "municipal_report": Citizen wants to report a water, roads, electricity, waste, or sanitation issue
- "gbv_report": Citizen mentions violence, abuse, assault, or needs crisis help
- "ticket_status": Citizen wants to check on an existing report or ticket
- "off_topic": Unrelated to municipal services or GBV (respond warmly and redirect)

STEP 3: AUTH CHECK
- "greeting", "off_topic" → NO AUTH REQUIRED
- "municipal_report", "ticket_status" → REQUIRES AUTH (session_status must be "active")
- "gbv_report" → REQUIRES AUTH (session_status must be "active")
If auth is needed and session_status is NOT "active":
  - Save the classified intent as pending_intent
  - Delegate to "Citizen Authentication Specialist"

STEP 4: DELEGATE
After auth is resolved (or if already authenticated), delegate to the correct specialist:
- "greeting" → respond yourself (Gugu), warmly ask what they need
- "municipal_report" → delegate to "Municipal Services Intake Specialist"
- "gbv_report" → delegate to "Crisis Support Specialist"
- "ticket_status" → delegate to "Ticket Status Specialist"
- "auth" → delegate to "Citizen Authentication Specialist"
- "off_topic" → respond yourself, explain you handle municipal services and GBV reporting

IMPORTANT: When delegating, pass the full citizen context (message, language, user_id, conversation history).
"""
```

### Pattern 3: TicketStatusCrew

**What:** New specialist crew following `BaseCrew` pattern. Has one tool: `lookup_ticket_tool`. Queries tickets by `user_id` (scoped) or `tracking_number` (also scoped to `user_id` — never cross-user).

```python
# src/agents/crews/ticket_status_crew.py
class TicketStatusCrew(BaseCrew):
    agent_key = "ticket_status_agent"
    task_key = "ticket_status_task"
    tools = [lookup_ticket_tool]
    memory_enabled = False  # No PII in memory

    def get_error_response(self, error):
        return {
            "error": str(error),
            "message": "I couldn't find that ticket right now. Please check your tracking number or try again.",
        }
```

```python
# src/agents/tools/ticket_lookup_tool.py
def _lookup_ticket_impl(
    user_id: str,
    tracking_number: str | None = None,
) -> dict:
    """Look up tickets for authenticated user only.

    Args:
        user_id: Authenticated citizen's UUID (mandatory — scopes all results)
        tracking_number: Optional TKT-YYYYMMDD-XXXXXX filter

    Returns:
        List of tickets with status timeline, or GBV-minimal info
    """
    client = get_supabase_admin()
    query = client.table("tickets").select(
        "id, tracking_number, category, status, severity, address, "
        "created_at, updated_at, resolved_at, is_sensitive"
    ).eq("user_id", user_id).order("created_at", desc=True)

    if tracking_number:
        query = query.eq("tracking_number", tracking_number)

    result = query.execute()
    tickets = result.data or []

    # GBV minimal info pattern (SEC-05 consistent)
    formatted = []
    for t in tickets:
        if t["is_sensitive"]:
            formatted.append({
                "tracking_number": t["tracking_number"],
                "category": "sensitive report",
                "status": t["status"],
                "note": "For support: SAPS 10111 | GBV Helpline 0800 150 150",
            })
        else:
            formatted.append({
                "tracking_number": t["tracking_number"],
                "category": t["category"],
                "status": t["status"],
                "severity": t["severity"],
                "address": t["address"],
                "created_at": t["created_at"],
                "updated_at": t["updated_at"],
                "resolved_at": t["resolved_at"],
            })
    return {"tickets": formatted, "count": len(formatted)}

lookup_ticket_tool = tool("lookup_ticket")(lookup_ticket_impl)
```

### Pattern 4: IntakeState / ConversationState Extension for Pending Intent

**What:** Extend `ConversationState` (Redis-backed) with two new optional fields: `pending_intent` (the classified intent before auth) and `pre_auth_message` (the original citizen message that triggered auth). These survive the auth round-trip.

**When to use:** When manager classifies intent as auth-gated but citizen is not authenticated — store before routing to AuthCrew, restore after auth completes.

```python
# src/core/conversation.py — extend ConversationState
class ConversationState(BaseModel):
    # ... existing fields ...
    pending_intent: str | None = None    # "municipal_report" | "gbv_report" | "ticket_status" | None
    pre_auth_message: str | None = None  # Original message that triggered auth
    routing_phase: str = "manager"       # "manager" | "auth" | "municipal" | "gbv" | "ticket_status"
```

**Why this over Flow state:** CrewAI Flow state is ephemeral per `flow.kickoff()` call. WhatsApp conversations are multi-turn and stateless per Twilio webhook hit — each message is a new HTTP request. Redis `ConversationState` already survives across webhook calls, making it the correct store for cross-turn context.

### Pattern 5: IntakeFlow Replacement (whatsapp_service.py integration)

**What:** Replace `IntakeFlow` keyword classification with `ManagerCrew.kickoff()`. The WhatsApp webhook pipeline stays identical — guardrails → conversation state → agent → guardrails → response. Only the middle step changes.

**Migration approach:** Keep `IntakeFlow` class but gut the `classify_message()` method. Replace the `@listen(receive_message) → classify_message → route_to_crew` chain with a direct call to `ManagerCrew`. Alternatively (simpler), delete `IntakeFlow` and replace the `flow.kickoff()` call in `whatsapp_service.py` with `manager_crew.kickoff()`.

```python
# src/services/whatsapp_service.py — replace flow section
# OLD:
flow = IntakeFlow(redis_url=self._redis_url, llm_model="gpt-4o")
flow._state = intake_state
result = flow.kickoff()

# NEW:
manager_crew = ManagerCrew(language=conversation_state.language, llm=get_deepseek_llm())
result = await manager_crew.kickoff({
    "message": input_result.sanitized_message,
    "user_id": user_id,
    "tenant_id": tenant_id,
    "language": conversation_state.language,
    "phone": sender_phone,  # From webhook payload
    "session_status": session_status,   # From phone_detection.detect_phone_session()
    "user_exists": user_exists,
    "conversation_history": format_conversation_history(conversation_state.turns),
    "pending_intent": conversation_state.pending_intent,
})
```

### Anti-Patterns to Avoid

- **Manager with tools:** In CrewAI's hierarchical process, the manager agent MUST NOT have tools. Verified bug reports (Issues #1851, #2131, #2054): assigning tools to the manager causes "Manager agent should not have tools" exception on subsequent crew.kickoff() calls in the same process run. Keep manager tool-free; specialists carry all tools.
- **Keyword routing in manager task:** Do not fall back to keyword matching in the manager task description. The locked decision is full LLM classification. The task description should use plain language instructions ("If the message mentions violence, abuse, or assault, classify as gbv_report").
- **Relying on Process.hierarchical's auto-delegation alone:** The framework's auto-delegation is unreliable in 1.8.x (manager executes all tasks itself). Compensate by making the manager task description extremely explicit — name each coworker by exact role string, give step-by-step instructions for when to delegate vs respond directly.
- **Separate tasks per route:** Do not create 5 separate tasks for 5 routing outcomes. The hierarchical process with a single manager task is the correct pattern. Multiple tasks cause the sequential execution bug where all tasks run in order regardless of delegation.
- **Storing intent in IntakeState (Flow state):** `IntakeState` (the old `Flow[IntakeState]` Pydantic model) is created fresh per webhook call. Do not use it for pending_intent storage. Use Redis `ConversationState` for cross-turn state.
- **Blocking the event loop in manager.kickoff():** BaseCrew already wraps `crew.kickoff()` in `loop.run_in_executor()`. ManagerCrew must do the same since CrewAI is synchronous internally.

---

## Don't Hand-Roll

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Intent classification routing | Custom keyword classifier | Manager agent LLM task | LLM handles multilingual (EN/ZU/AF) naturally; keyword lists were the problem being replaced |
| Ticket lookup with Supabase | Custom PostgreSQL query layer | Supabase PostgREST via existing `get_supabase_admin()` pattern | ticket_tool.py already uses this; same pattern for lookup |
| Conversation history formatting | Custom serializer | Simple join of `ConversationState.turns` dicts | Already stored in Redis with role/content/timestamp structure |
| Manager-to-specialist context pass | Custom message bus | CrewAI `delegate_work` tool context parameter | Built into hierarchical process |
| Trilingual manager prompts | Separate prompt files per language | Single manager prompt with language instruction in task description | Specialists already handle language; manager just passes language through |
| GBV ticket minimal display | New security layer | `is_sensitive` flag already on Ticket model | Filter in lookup_ticket_tool based on existing field |

**Key insight:** The codebase already has 80% of the plumbing — BaseCrew, ConversationManager, guardrails engine, Supabase admin client, phone detection, auth flow. Phase 06.9 is routing refactor + one new crew + one new tool, not a rewrite.

---

## Common Pitfalls

### Pitfall 1: Manager Agent OpenAI Fallback
**What goes wrong:** CrewAI hierarchical process ignores `manager_agent.llm` and calls OpenAI when `manager_llm` is not separately set. This fails because the project uses DeepSeek.
**Why it happens:** Internal CrewAI code has a separate code path for `manager_llm` vs `manager_agent.llm` configuration.
**How to avoid:** Always set BOTH `manager_agent=manager` (with `llm=get_deepseek_llm()`) AND `manager_llm=get_deepseek_llm()` in the `Crew()` constructor.
**Warning signs:** `AuthenticationError: OpenAI API key required` during manager crew kickoff when OPENAI_API_KEY is not set.

### Pitfall 2: Manager Executes All Tasks Itself
**What goes wrong:** With `Process.hierarchical`, the manager agent runs all tasks sequentially without delegating to specialists.
**Why it happens:** CrewAI's internal hierarchical orchestrator calls agents based on task assignment, not pure LLM delegation. The manager gets all tasks if task-to-agent assignment is ambiguous.
**How to avoid:** Use ONLY ONE task (the manager task). Do NOT assign specialist tasks in the `tasks=[]` list — they will be assigned to and run by the manager. Specialists are accessed exclusively through the `delegate_work` tool, not through task assignment.
**Warning signs:** No delegation in logs; manager response includes full specialist outputs without role handoff.

### Pitfall 3: Specialist Agents Not Found by Manager
**What goes wrong:** Manager tries to delegate to "Municipal Services Intake Specialist" but gets "coworker not found" error.
**Why it happens:** The `delegate_work` tool uses the exact `role` string to find coworkers. If the role in the Agent definition and the role referenced in the manager task description differ even slightly, delegation fails.
**How to avoid:** Define specialist agent roles as constants or load from agents.yaml. Reference those exact strings in the manager task description.
**Warning signs:** "I was unable to find the coworker" in manager output; manager falls back to answering directly.

### Pitfall 4: Auth-Gated Routing Loop
**What goes wrong:** Manager routes to AuthCrew → AuthCrew completes → manager re-routes to manager (not to the intended specialist) → citizen asked intent again.
**Why it happens:** After auth, the manager gets a fresh webhook message with no memory of the original intent unless it was stored.
**How to avoid:** On manager task completion after AuthCrew delegation, check `ConversationState.pending_intent`. If set, immediately route to that specialist crew. Clear `pending_intent` after routing.
**Warning signs:** Citizens report being asked "how can I help you?" after completing registration when they already said they wanted to report a water leak.

### Pitfall 5: GBV Memory Namespace vs Manager Flow
**What goes wrong:** Manager stores conversation context in `conv:municipal:` Redis namespace for a session that later gets classified as GBV, creating a data residue in the wrong namespace.
**Why it happens:** Manager runs before classification; initial turns are saved under municipal namespace; GBV crew clears `conv:gbv:` but municipal turns remain.
**How to avoid:** Until GBV is confirmed, use a neutral "pending" namespace or the municipal namespace. After GBV classification, the GBVCrew's existing session-clearing logic handles the GBV namespace. The municipal namespace turns (pre-classification) are low-risk (no victim details) and expire with normal TTL.
**Warning signs:** Redis accumulation in `conv:municipal:` for sessions that were classified as GBV.

### Pitfall 6: ticket_status_task with tickets table RLS
**What goes wrong:** `lookup_ticket_tool` uses `get_supabase_admin()` (service role key) which bypasses RLS. The user_id scoping in the query becomes the only protection.
**Why it happens:** Admin client has full access. Unlike citizen-facing queries, agent tools use admin client.
**How to avoid:** The `lookup_ticket_impl` function MUST always include `.eq("user_id", user_id)` in the query chain. Never call without user_id. Add assertion: `assert user_id, "user_id is required for ticket lookup"`.
**Warning signs:** Tickets from other users appearing in results (security incident, not just a bug).

---

## Code Examples

### Manager Agent YAML Config
```yaml
# src/agents/config/agents.yaml — add:
manager_agent:
  role: "Municipal Services Manager"
  goal: "Greet citizens warmly, understand their intent, and route them to the right specialist in {language}"
  backstory: >
    You are Gugu, the SALGA Trust Engine's first-contact manager —
    South Africa's municipal services reporting platform.

    The SALGA Trust Engine exists to close the gap between South African citizens
    and their local government — citizens report a problem and the municipality
    visibly responds. This feedback loop transforms opaque, reactive local
    government into transparent, accountable service delivery.

    Your role is to be the first voice citizens hear. You greet them, understand
    what they need, and connect them with the right specialist — whether that's
    registering them as a new user, helping them report a municipal problem, or
    supporting someone in a GBV crisis.

    === IDENTITY RULES ===

    YOUR NAME IS GUGU. You are the AI manager, NOT a citizen.
    Greet citizens warmly. Use their name once you know it.
    One step at a time — don't overwhelm.
    Be the calm, confident voice that makes citizens feel heard.

    === END IDENTITY RULES ===

    TONE: Warm, confident, community-focused. Like a trusted municipal liaison.
    You don't solve problems directly — you connect people with those who do.
  allow_delegation: true
  max_iter: 5
  verbose: false
```

### ManagerCrew.create_crew() with Process.hierarchical
```python
from crewai import Agent, Crew, Process, Task

crew = Crew(
    agents=[auth_agent, municipal_agent, gbv_agent, ticket_status_agent],
    tasks=[manager_task],          # ONE task only — manager task
    manager_agent=manager_agent,   # Custom Gugu manager
    manager_llm=get_deepseek_llm(), # BOTH manager_agent AND manager_llm — prevent OpenAI fallback
    process=Process.hierarchical,
    memory=False,
    verbose=False,
)
```

### TicketStatusCrew lookup_ticket_tool (scoped)
```python
@tool("lookup_ticket")
def lookup_ticket(user_id: str, tracking_number: str | None = None) -> dict:
    """Look up tickets for the authenticated user only."""
    assert user_id, "user_id is required — never look up tickets without it"
    client = get_supabase_admin()
    query = (
        client.table("tickets")
        .select("tracking_number, category, status, severity, address, created_at, updated_at, resolved_at, is_sensitive")
        .eq("user_id", user_id)
        .order("created_at", desc=True)
        .limit(10)  # Never dump full history in one call
    )
    if tracking_number:
        query = query.eq("tracking_number", tracking_number.upper())
    result = query.execute()
    ...
```

### ConversationState extended for pending_intent
```python
class ConversationState(BaseModel):
    # ... existing fields unchanged ...
    pending_intent: str | None = None      # Saved before auth handoff
    pre_auth_message: str | None = None    # Original message that triggered auth
    routing_phase: str = "manager"         # Tracks current handler
    last_specialist_result: dict | None = None  # Manager follow-up context
```

### IntakeFlow simplified — delegate to ManagerCrew
```python
# src/agents/flows/intake_flow.py
@start()
async def receive_and_route(self) -> dict:
    """Single entry point: detect language, run ManagerCrew."""
    detected_language = language_detector.detect(self.state.message, fallback="en")
    self.state.language = detected_language

    manager_crew = ManagerCrew(language=detected_language, llm=self._llm)
    result = await manager_crew.kickoff({
        "message": self.state.message,
        "user_id": self.state.user_id,
        "tenant_id": self.state.tenant_id,
        "language": detected_language,
        "session_status": self.state.session_status,
        "user_exists": self.state.user_exists,
        "conversation_history": self.state.conversation_history,
        "pending_intent": self.state.pending_intent,
    })
    self.state.is_complete = True
    return result
```

---

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| Keyword-based IntakeFlow classification | LLM manager agent classification | Phase 06.9 | Handles multilingual ambiguity, intent nuance, off-topic gracefully |
| IntakeFlow @router decorator routing | Process.hierarchical manager delegation | Phase 06.9 | Native CrewAI orchestration replaces custom routing code |
| Hard-coded route paths (municipal/gbv only) | 5 routing categories including greeting, ticket_status, auth | Phase 06.9 | Complete conversation coverage |
| Auth handled separately via crew_server.py conditionals | Demand-driven auth via manager classification | Phase 06.9 | Auth only triggered when needed |
| No ticket status capability | TicketStatusCrew with dual lookup | Phase 06.9 | Citizens can self-serve on existing reports |

**Deprecated/outdated:**
- `IntakeFlow.classify_message()`: The keyword list approach is replaced entirely by manager LLM classification
- `IntakeFlow.route_to_crew()`: The @router decorator chain is replaced by manager agent delegation
- Imperative `if session_status == "active"` routing in whatsapp_service.py: Replaced by manager task classification

---

## Open Questions

1. **How does the manager handle multi-turn specialist conversations?**
   - What we know: After manager delegates to a specialist, the specialist's response comes back to the citizen via the same webhook flow. The NEXT message from the citizen will hit the manager again.
   - What's unclear: Does the manager re-delegate to the same specialist for follow-up messages in an ongoing intake conversation? Or should WhatsApp service bypass the manager for in-progress specialist sessions?
   - Recommendation: Store `routing_phase` in `ConversationState`. If `routing_phase != "manager"`, whatsapp_service.py should call the active specialist crew directly, not re-enter the manager. Manager re-enters only when: (a) specialist sets `routing_phase = "manager"` on task completion, or (b) citizen interrupts with out-of-scope intent (interrupt detection is a discretion area).

2. **Interrupt detection implementation**
   - What we know: The user decision says specialists should detect when citizens shift intent mid-conversation. This is a Claude's Discretion area.
   - What's unclear: Prompt-based detection (add "watch for intent shifts" to specialist backstory) vs tool-based (specialist calls a `check_intent_shift` tool).
   - Recommendation: Prompt-based is simpler and consistent with existing specialist prompts. Add a section to each specialist's task description: "If the citizen says something that is NOT related to [this specialty], stop and respond: 'It sounds like you may need help with something else. Let me check if I should connect you with a different specialist.'" Specialist's response containing that phrase triggers manager re-routing in the service layer.

3. **ManagerCrew vs ManagerFlow — does the user's "Process.hierarchical" lock apply to module structure?**
   - What we know: The locked decision says "CrewAI Process.hierarchical with manager_agent". This specifies the Crew process mode, not whether to use a Flow wrapper.
   - What's unclear: Should ManagerCrew be wrapped in a Flow (replacing IntakeFlow) or should whatsapp_service.py call ManagerCrew.kickoff() directly?
   - Recommendation: Keep IntakeFlow as a thin wrapper for language detection + guardrails, but replace its classify/route methods with a single call to ManagerCrew.kickoff(). This preserves the existing whatsapp_service.py integration point with minimal changes.

4. **Ticket status timeline — is status_history in the DB?**
   - What we know: The Ticket model has `status` (current), `created_at`, `updated_at`, `resolved_at`, `escalated_at`, `first_responded_at`. No explicit `status_history` table visible.
   - What's unclear: Is there a separate audit/history table for status transitions?
   - Recommendation: Planner should check if `audit_log` table (seen in `src/core/audit.py`) contains ticket status change events. If yes, use it for timeline. If no, derive timeline from `created_at` → `first_responded_at` → `escalated_at` → `resolved_at` timestamps as proxy.

---

## Sources

### Primary (HIGH confidence)
- CrewAI codebase, `crewai.__version__ == "1.8.1"` — confirmed installed in project Python environment
- `src/agents/crews/base_crew.py` — existing BaseCrew pattern that all new crews must follow
- `src/agents/crews/auth_crew.py`, `municipal_crew.py`, `gbv_crew.py` — existing specialist patterns
- `src/agents/flows/intake_flow.py` — current keyword router being replaced
- `src/services/whatsapp_service.py` — integration point for manager crew
- `src/core/conversation.py` — ConversationState Redis pattern for pending_intent storage
- `src/agents/tools/ticket_tool.py` — Supabase PostgREST pattern to replicate in lookup_ticket_tool
- `src/models/ticket.py` — Ticket schema for status lookup fields
- `src/agents/config/agents.yaml`, `tasks.yaml` — YAML-first config pattern

### Secondary (MEDIUM confidence)
- [CrewAI Official Docs — Custom Manager Agent](https://docs.crewai.com/en/learn/custom-manager-agent) — Process.hierarchical + manager_agent code example verified
- [CrewAI Official Docs — Hierarchical Process](https://docs.crewai.com/how-to/hierarchical-process) — manager_llm requirement confirmed
- [CrewAI Community — Hierarchical Crews Manager Requires OpenAI](https://community.crewai.com/t/hierarchical-crews-manager-agent-requires-openai/4585) — `planning_llm=llm` + `manager_llm=llm` fix verified by user
- [DeepWiki — CrewAI State Management](https://deepwiki.com/crewAIInc/crewAI/3.3-state-management) — Flow state structure, thread-safety, SQLite persistence

### Tertiary (LOW confidence — flag for validation)
- [GitHub crewAI Discussion #1220](https://github.com/crewAIInc/crewAI/discussions/1220) — "manager executes all tasks" report; workaround via single-task pattern — WebSearch verified but not tested against 1.8.1 specifically
- [GitHub Issue #1851](https://github.com/crewAIInc/crewAI/issues/2131) — "Manager agent should not have tools" exception — reported Jan–Feb 2025; may be fixed in 1.8.1 (unverified)
- [GitHub Issue #2606](https://github.com/crewAIInc/crewAI/issues/2606) — TypeErrors in delegation schema — reported 2025; may be fixed in 1.8.1 (unverified)
- [ActiveWizards — Hierarchical AI Agents Guide](https://activewizards.com/blog/hierarchical-ai-agents-a-guide-to-crewai-delegation) — single-task-for-manager pattern confirmed; LLM-inferred delegation detail noted

---

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH — verified crewai 1.8.1 installed; all libraries already in pyproject.toml or codebase
- Architecture patterns: MEDIUM — official docs confirmed; delegation bugs documented in community but fix pattern not unit-tested against 1.8.1
- TicketStatusCrew pattern: HIGH — follows BaseCrew exactly; Supabase PostgREST pattern already proven in ticket_tool.py
- Pitfalls: MEDIUM — most confirmed in multiple community sources; exact fix behavior in 1.8.1 not independently verified
- ConversationState extension: HIGH — follows existing pattern exactly; Redis structure well understood from codebase

**Research date:** 2026-02-18
**Valid until:** 2026-03-18 (CrewAI moves fast; re-verify hierarchical bugs if upgrading past 1.8.1)
