---
phase: 03-citizen-reporting-channels
plan: 03
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - src/services/ocr_service.py
  - src/services/image_utils.py
  - src/api/v1/verification.py
  - src/main.py
autonomous: true

must_haves:
  truths:
    - "OCR service preprocesses images (grayscale, contrast, threshold, denoise) before text extraction"
    - "OCR extracts address and name from proof of residence documents (utility bills, bank statements)"
    - "OCR confidence score determines whether result is auto-accepted or needs manual review"
    - "EXIF metadata is stripped from uploaded images before storage for privacy"
    - "User verification endpoint accepts document file_id, runs OCR, and updates user verification_status"
    - "POPIA consent is captured before document upload (explicit biometric data consent)"
  artifacts:
    - path: "src/services/ocr_service.py"
      provides: "Tesseract OCR with preprocessing for proof of residence documents"
      contains: "extract_proof_of_residence"
    - path: "src/services/image_utils.py"
      provides: "Image preprocessing and EXIF stripping utilities"
      contains: "strip_exif_metadata"
    - path: "src/api/v1/verification.py"
      provides: "Proof of residence verification endpoint"
      contains: "verify_proof_of_residence"
  key_links:
    - from: "src/api/v1/verification.py"
      to: "src/services/ocr_service.py"
      via: "OCRService.extract_proof_of_residence()"
      pattern: "ocr_service\\.extract"
    - from: "src/api/v1/verification.py"
      to: "src/services/storage_service.py"
      via: "Download document from S3 for OCR processing"
      pattern: "storage_service\\.download|generate_presigned_get"
    - from: "src/services/ocr_service.py"
      to: "src/services/image_utils.py"
      via: "preprocess_image_for_ocr before Tesseract"
      pattern: "preprocess_image"
---

<objective>
Implement OCR-based proof of residence verification so citizens can bind their accounts to a specific municipality by uploading utility bills or bank statements.

Purpose: PLAT-03 requires proof of residence for account-municipality binding. OCR extracts address data from uploaded documents, enabling automated verification with confidence-based fallback to manual review.

Output: OCR service with preprocessing, image utilities with EXIF stripping, verification API endpoint
</objective>

<execution_context>
@C:/Users/Bantu/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Bantu/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-citizen-reporting-channels/03-RESEARCH.md
@.planning/phases/03-citizen-reporting-channels/03-01-SUMMARY.md
@src/models/user.py
@src/schemas/user.py
@src/services/storage_service.py
@src/core/config.py
@src/api/deps.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Image Utilities and OCR Service</name>
  <files>
    src/services/image_utils.py
    src/services/ocr_service.py
  </files>
  <action>
1. Create `src/services/image_utils.py`:

   **preprocess_image_for_ocr(image_bytes: bytes) -> Image.Image:**
   - Open image from bytes using PIL.Image
   - Convert to grayscale (img.convert('L'))
   - Increase contrast (ImageEnhance.Contrast, factor=2.0)
   - Apply binary threshold (128): `img.point(lambda p: 255 if p > 128 else 0)`
   - Denoise with MedianFilter(size=3)
   - Return processed PIL Image

   **strip_exif_metadata(image_bytes: bytes) -> bytes:**
   - Open image from bytes using PIL.Image
   - Preserve format (JPEG, PNG)
   - Create new image from pixel data only (strips all metadata):
     ```python
     data = list(img.getdata())
     clean_img = Image.new(img.mode, img.size)
     clean_img.putdata(data)
     ```
   - Save to BytesIO buffer in original format
   - Return cleaned bytes
   - NOTE: If image format detection fails, default to JPEG

   **extract_gps_from_exif(image_bytes: bytes) -> tuple[float, float] | None:**
   - Use exifread.process_file() to extract EXIF tags
   - If 'GPS GPSLatitude' and 'GPS GPSLongitude' present:
     - Convert DMS (degrees/minutes/seconds) to decimal degrees
     - Handle N/S and E/W reference tags for sign
     - Return (latitude, longitude)
   - Return None if no GPS data

   **validate_image_quality(image_bytes: bytes) -> dict:**
   - Open with PIL, check dimensions (min 800x600 for OCR)
   - Check file size (min 50KB — too small likely means screenshot or thumbnail)
   - Return dict: {"valid": bool, "width": int, "height": int, "size_bytes": int, "reason": str | None}

2. Create `src/services/ocr_service.py` — OCRService class:

   **ProofOfResidenceData(BaseModel):**
   - address: str | None = None
   - name: str | None = None
   - document_type: str | None = None (utility_bill, bank_statement, lease_agreement, municipal_account, other)
   - confidence: float = 0.0 (0-1 average OCR confidence)
   - raw_text: str = "" (full OCR text for debugging/manual review)

   **extract_proof_of_residence(self, image_bytes: bytes) -> ProofOfResidenceData:**
   - Call preprocess_image_for_ocr(image_bytes)
   - Run pytesseract.image_to_data() for confidence scores
   - Run pytesseract.image_to_string() for full text
   - Calculate average confidence from non-empty word confidences
   - Extract address using _extract_address_pattern(full_text)
   - Extract name using _extract_name_pattern(full_text)
   - Detect document type using _detect_document_type(full_text)
   - Return ProofOfResidenceData

   **_extract_address_pattern(self, text: str) -> str | None:**
   - South African address patterns (regex):
     - Street addresses: `\d+\s+[A-Za-z\s]+(?:Street|St|Road|Rd|Avenue|Ave|Drive|Dr|Lane|Ln|Crescent|Cres),?\s*[A-Za-z\s]+,?\s*\d{4}`
     - PO Box: `P\.?O\.?\s*Box\s+\d+,?\s*[A-Za-z\s]+,?\s*\d{4}`
     - Postal code alone: Match 4-digit postal codes near town names
   - Return first match or None

   **_extract_name_pattern(self, text: str) -> str | None:**
   - Look for name patterns: "Mr/Mrs/Ms/Dr" followed by words, or "Name:" followed by text
   - Also look for "Account Holder:" patterns common in utility bills
   - Return extracted name or None

   **_detect_document_type(self, text: str) -> str | None:**
   - Check for keywords:
     - electricity/eskom/municipal account -> "utility_bill"
     - bank statement/capitec/fnb/absa/standard bank/nedbank -> "bank_statement"
     - lease agreement/rental -> "lease_agreement"
     - water/sewerage/refuse -> "municipal_account"
   - Return type or None

   **determine_verification_result(self, ocr_data: ProofOfResidenceData) -> dict:**
   - If confidence >= 0.7 AND address found AND name found: `{"status": "verified", "auto": True}`
   - If confidence >= 0.5 AND (address found OR name found): `{"status": "pending", "auto": False, "reason": "Partial extraction - manual review needed"}`
   - If confidence < 0.5: `{"status": "rejected", "auto": True, "reason": "Document quality too low for OCR. Please upload a clearer image."}`
   - Return dict with status and reason

   **IMPORTANT:** Handle pytesseract.TesseractNotFoundError gracefully. If Tesseract is not installed, log error and return ProofOfResidenceData with confidence=0 and document_type=None. This allows the application to run without Tesseract installed (CI/testing), with OCR features degraded.
  </action>
  <verify>
    python -c "from src.services.ocr_service import OCRService, ProofOfResidenceData; from src.services.image_utils import strip_exif_metadata, preprocess_image_for_ocr, validate_image_quality; print('OCR services importable OK')"
  </verify>
  <done>
    OCR service extracts address, name, document type with confidence scoring from preprocessed images. Image utils strip EXIF metadata, validate quality, extract GPS. Graceful degradation when Tesseract not installed.
  </done>
</task>

<task type="auto">
  <name>Task 2: Proof of Residence Verification API Endpoint</name>
  <files>
    src/api/v1/verification.py
    src/main.py
  </files>
  <action>
1. Create `src/api/v1/verification.py`:

   **POST /api/v1/verification/proof-of-residence:**
   - Requires authentication (get_current_user)
   - Request body: UserVerificationRequest (document_file_id: str)
   - Flow:
     1. Check user is not already verified (verification_status != "verified")
     2. Download document from S3 using StorageService.generate_presigned_get() or direct download
        - Actually, since the document was uploaded directly to S3 via presigned URL, we need to download it from S3 for OCR processing. Use boto3 get_object or generate a presigned GET and download via httpx.
        - Look up MediaAttachment by file_id to get s3_bucket and s3_key
        - Download bytes from S3
     3. Strip EXIF metadata from image (privacy)
     4. Validate image quality
     5. Run OCR extraction: ocr_service.extract_proof_of_residence(image_bytes)
     6. Determine verification result
     7. Update user: verification_status, verified_address (from OCR), verification_document_id
     8. If auto-verified: set verified_at to now
     9. Return verification result with OCR data
   - Response: `{"status": "verified"|"pending"|"rejected", "address": str|null, "confidence": float, "document_type": str|null, "message": str}`

   **GET /api/v1/verification/status:**
   - Requires authentication
   - Returns current user's verification status: UserVerificationResponse

   **POST /api/v1/verification/upload-url:**
   - Requires authentication
   - Generates presigned POST URL specifically for proof of residence documents
   - Request: filename, content_type (must be image/jpeg, image/png, or application/pdf)
   - Calls StorageService.generate_presigned_post() with purpose="proof_of_residence"
   - Returns PresignedUploadResponse
   - Max size: 5MB for documents
   - POPIA: Include consent message in response: "By uploading this document, you consent to automated processing of your proof of residence for account verification. This document may contain biometric data (facial images). It will be deleted within 90 days of verification."

2. Register router in `src/main.py`:
   - Import verification module: `from src.api.v1 import verification`
   - Add: `app.include_router(verification.router, prefix="/api/v1")`
  </action>
  <verify>
    python -c "from src.api.v1.verification import router; from src.main import app; routes = [str(r.path) for r in app.routes]; assert '/api/v1/verification/proof-of-residence' in routes, f'Missing route'; print('Verification routes registered OK')"
  </verify>
  <done>
    Proof of residence verification endpoint runs OCR on uploaded documents, extracts address/name, auto-verifies if confidence >= 0.7, queues for manual review otherwise. Upload URL endpoint provides presigned S3 URL for documents. Status endpoint returns current verification state. POPIA consent message included. Router registered in main app.
  </done>
</task>

</tasks>

<verification>
- OCR service returns ProofOfResidenceData with address, name, type, confidence
- Image preprocessing improves OCR output (tested with sample images if available)
- EXIF stripping removes GPS and device metadata
- Verification endpoint accepts document_file_id and returns verification result
- User verification_status updated in database
- Upload URL endpoint returns presigned POST for proof_of_residence purpose
- Routes registered in FastAPI app
- `pytest tests/ -x` passes (no regressions)
</verification>

<success_criteria>
- OCR extracts South African addresses from document images
- Confidence scoring determines auto-verify vs manual review
- User accounts updated with verification status and extracted address
- Presigned upload URLs generated for document uploads
- POPIA consent captured before document processing
- Graceful degradation when Tesseract not installed
</success_criteria>

<output>
After completion, create `.planning/phases/03-citizen-reporting-channels/03-03-SUMMARY.md`
</output>
