---
phase: 04-ticket-management-routing
plan: 04
type: execute
wave: 3
depends_on: ["04-02", "04-03"]
files_modified:
  - src/api/v1/tickets.py
  - src/api/v1/__init__.py
  - src/schemas/ticket.py
  - src/core/audit.py
autonomous: true

must_haves:
  truths:
    - "API endpoint updates ticket status and triggers WhatsApp notification"
    - "API endpoint assigns ticket to team with auto-routing option"
    - "Ticket status changes are captured in audit trail with old/new values"
    - "GBV tickets only accessible to SAPS_LIAISON and ADMIN roles"
    - "Ticket response schema includes SLA deadline and assignment info"
    - "All ticket mutations trigger audit log entry via existing after_flush listener"
  artifacts:
    - path: "src/api/v1/tickets.py"
      provides: "Ticket management API endpoints"
      contains: "router"
    - path: "src/schemas/ticket.py"
      provides: "Updated ticket schemas with SLA and assignment fields"
      contains: "TicketDetailResponse"
  key_links:
    - from: "src/api/v1/tickets.py"
      to: "src/services/assignment_service.py"
      via: "calls auto_route_and_assign on ticket creation/assignment"
      pattern: "assignment_service|auto_route"
    - from: "src/api/v1/tickets.py"
      to: "src/tasks/status_notify.py"
      via: "dispatches Celery task on status change"
      pattern: "send_status_notification\\.delay"
    - from: "src/api/v1/tickets.py"
      to: "src/services/sla_service.py"
      via: "sets SLA deadlines on ticket creation"
      pattern: "sla_service|set_ticket_deadlines"
    - from: "src/core/audit.py"
      to: "src/models/ticket.py"
      via: "after_flush captures ticket status changes"
      pattern: "after_flush_audit_handler"
---

<objective>
Create ticket management API endpoints for status updates, assignment, and retrieval with SLA information. Enhance audit logging to capture ticket-specific status changes. Enforce GBV access controls (SEC-05) at the API layer.

Purpose: TKT-01 (notifications triggered by status changes), TKT-05 (audit trail via API + event listener), SEC-05 (GBV access firewall at API level). This plan wires the services from Plans 02-03 into API endpoints that the dashboard (Phase 5) and background tasks will use.

Output: Ticket management API with assignment, status updates, SLA info, audit trail, and GBV access controls.
</objective>

<execution_context>
@C:/Users/Bantu/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Bantu/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-ticket-management-routing/04-RESEARCH.md
@.planning/phases/04-ticket-management-routing/04-01-SUMMARY.md
@.planning/phases/04-ticket-management-routing/04-02-SUMMARY.md
@.planning/phases/04-ticket-management-routing/04-03-SUMMARY.md
@src/api/v1/reports.py
@src/api/v1/__init__.py
@src/schemas/ticket.py
@src/core/audit.py
@src/models/user.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update ticket schemas and create ticket management API</name>
  <files>
    src/schemas/ticket.py
    src/api/v1/tickets.py
    src/api/v1/__init__.py
  </files>
  <action>
    1. Update `src/schemas/ticket.py` - add new schemas and update existing ones:

       a. Update `TicketResponse`:
          - Remove `latitude` and `longitude` fields
          - Add `latitude: float | None` and `longitude: float | None` as computed/optional fields (backward compat)
          - Add `assigned_team_id: UUID | None`
          - Add `escalated_at: datetime | None`
          - Add `first_responded_at: datetime | None`
          - Add `sla_response_deadline: datetime | None`
          - Add `sla_resolution_deadline: datetime | None`
          - Add `assigned_to: UUID | None`

       b. Add `TicketDetailResponse(TicketResponse)` that extends TicketResponse with:
          - `assignment_history: list[AssignmentBrief]` (optional, populated when requested)
          - `sla_status: str | None` (computed: "on_track", "warning", "breached_response", "breached_resolution")
          - `escalation_reason: str | None`

       c. Add `AssignmentBrief(BaseModel)`:
          - `team_name: str | None`
          - `assigned_to_name: str | None`
          - `assigned_by: str | None`
          - `reason: str | None`
          - `created_at: datetime`
          - ConfigDict(from_attributes=True)

       d. Add `TicketStatusUpdate(BaseModel)`:
          - `status: str` (required)
          - Validate status against TicketStatus values
          - Validate transition rules: open -> in_progress/escalated/closed, in_progress -> escalated/resolved/closed, escalated -> in_progress/resolved/closed, resolved -> closed/in_progress (reopen), closed -> (no transitions, or open for reopen)

       e. Add `TicketAssignRequest(BaseModel)`:
          - `team_id: UUID | None = None` (if None, auto-route)
          - `assigned_to: UUID | None = None`
          - `reason: str | None = None`

       f. Update `TicketCreate`:
          - Keep latitude/longitude as optional float fields for backward compatibility in API requests
          - These will be converted to PostGIS geometry in the endpoint

    2. Create `src/api/v1/tickets.py` - Ticket management API router:

       a. `GET /tickets/` - List tickets (manager/admin only):
          - Requires authentication (get_current_user)
          - RBAC: UserRole.MANAGER, UserRole.ADMIN, UserRole.SAPS_LIAISON
          - Pagination: limit (default 50), offset
          - Filters: status (optional), category (optional), assigned_team_id (optional)
          - For SAPS_LIAISON role: ONLY return is_sensitive=True tickets (GBV only)
          - For MANAGER/ADMIN: return all non-sensitive tickets (is_sensitive=False). To see GBV tickets, must be SAPS_LIAISON.
          - Order by created_at descending

       b. `GET /tickets/{ticket_id}` - Get ticket detail:
          - Requires authentication
          - RBAC: ticket owner (citizen), MANAGER, ADMIN, SAPS_LIAISON
          - SEC-05: If ticket.is_sensitive, only SAPS_LIAISON and ADMIN can view. Return 403 for others.
          - Include assignment history if user is MANAGER/ADMIN/SAPS_LIAISON
          - Compute SLA status from deadlines

       c. `PATCH /tickets/{ticket_id}/status` - Update ticket status:
          - Requires authentication
          - RBAC: MANAGER, ADMIN, SAPS_LIAISON (for GBV tickets)
          - Accept TicketStatusUpdate body
          - Validate status transition
          - Update ticket.status
          - If new status is "resolved": set ticket.resolved_at = utcnow()
          - If new status is "in_progress" and first_responded_at is None: set first_responded_at = utcnow()
          - Dispatch send_status_notification.delay() Celery task to notify citizen:
            - Look up user phone from ticket.user_id
            - Only send if user has phone number and new_status is meaningful (in_progress, escalated, resolved, closed)
          - Return updated TicketResponse

       d. `POST /tickets/{ticket_id}/assign` - Assign ticket to team:
          - Requires authentication
          - RBAC: MANAGER, ADMIN
          - Accept TicketAssignRequest body
          - If team_id is None: call AssignmentService.auto_route_and_assign()
          - If team_id provided: call AssignmentService.assign_ticket()
          - SEC-05: If ticket is GBV, validate team has is_saps=True
          - Set SLA deadlines via SLAService.set_ticket_deadlines()
          - Return updated TicketResponse

       e. `GET /tickets/{ticket_id}/history` - Get ticket assignment/audit history:
          - Requires authentication
          - RBAC: MANAGER, ADMIN, SAPS_LIAISON (for GBV)
          - Call AssignmentService.get_assignment_history()
          - Also query AuditLog for ticket changes: `WHERE table_name='tickets' AND record_id=ticket_id`
          - Return combined history (assignments + audit entries) ordered by timestamp

    3. Update `src/api/v1/__init__.py`:
       - Import and include the tickets router in the v1 router
       - `from src.api.v1.tickets import router as tickets_router`
       - `v1_router.include_router(tickets_router)`

    IMPORTANT on SEC-05 enforcement:
    - Every endpoint that accesses a ticket MUST check is_sensitive
    - GBV tickets (is_sensitive=True) are ONLY accessible to SAPS_LIAISON and ADMIN roles
    - Return HTTP 403 with message "Not authorized to access sensitive reports" for unauthorized access
    - This is defense-in-depth: RLS + application filter + API RBAC

    IMPORTANT on notification dispatch:
    - Use `send_status_notification.delay(ticket_id=str(ticket.id), user_phone=phone, ...)` -- Celery .delay() for async dispatch
    - If Celery is not running (dev mode), wrap in try/except and log warning. The notification is best-effort, not critical path.

    IMPORTANT on location handling:
    - TicketCreate still accepts latitude/longitude as floats
    - In the API endpoint, convert to WKTElement: `WKTElement(f"POINT({longitude} {latitude})", srid=4326)` and set on ticket.location
    - Import from geoalchemy2.elements import WKTElement
  </action>
  <verify>
    Run `python -c "from src.api.v1.tickets import router; print(f'Tickets router: {len(router.routes)} routes')"` shows 5 routes.
    Run `python -c "from src.schemas.ticket import TicketDetailResponse, TicketStatusUpdate, TicketAssignRequest; print('New schemas OK')"` succeeds.
    Verify tickets.py contains SEC-05 checks (is_sensitive + role check) on every endpoint.
    Verify tickets.py dispatches send_status_notification.delay() on status change.
    Run existing tests to confirm no regressions.
  </verify>
  <done>
    Ticket management API has 5 endpoints (list, detail, status update, assign, history). GBV access control enforced on every endpoint (SEC-05). Status changes trigger async WhatsApp notifications via Celery. SLA deadlines set on assignment. All ticket mutations go through SQLAlchemy ORM to trigger audit trail.
  </done>
</task>

<task type="auto">
  <name>Task 2: Enhance audit trail for ticket-specific status change tracking</name>
  <files>src/core/audit.py</files>
  <action>
    The existing `after_flush_audit_handler` in `src/core/audit.py` already captures ALL model changes (INSERT, UPDATE, DELETE) via the Session after_flush event. This includes ticket status changes, assignments, and escalations -- they all go through SQLAlchemy ORM models.

    Enhancements needed:

    1. Add ticket-specific change detection in the UPDATE handler:
       - After the existing `_get_changes_dict(obj)` call, check if the object is a Ticket
       - If the changed fields include "status", log at INFO level:
         `logger.info(f"Ticket status change: {old_status} -> {new_status}", extra={"ticket_id": str(obj.id), "tracking_number": obj.tracking_number})`
       - If the changed fields include "assigned_team_id", log:
         `logger.info(f"Ticket assignment change: {old_team} -> {new_team}", extra={"ticket_id": str(obj.id)})`
       - If the changed fields include "status" and new value is "escalated", log:
         `logger.info(f"Ticket escalated: {obj.tracking_number}", extra={"ticket_id": str(obj.id), "reason": obj.escalation_reason})`

    2. Add import at top of file:
       ```python
       from src.models.ticket import Ticket
       ```

    3. In the existing UPDATE section of after_flush_audit_handler, after the `_create_audit_log` call, add:
       ```python
       # Enhanced ticket-specific logging
       if isinstance(obj, Ticket) and changes:
           _log_ticket_changes(obj, changes)
       ```

    4. Create helper function `_log_ticket_changes(ticket: Ticket, changes: dict)`:
       - Check for status changes and log at INFO level
       - Check for assignment changes and log at INFO level
       - Check for escalation and log at WARNING level
       - This provides structured logging for ticket lifecycle events beyond the generic audit log

    This approach preserves the existing audit infrastructure (TKT-05 is largely already satisfied by Phase 1's audit system) while adding ticket-specific structured logging for operational visibility.

    IMPORTANT: Do NOT modify the core audit logic. Only ADD the ticket-specific logging enhancement after the existing audit log creation. The generic audit system already handles the database audit trail.
  </action>
  <verify>
    Run `python -c "from src.core.audit import after_flush_audit_handler; print('Audit OK')"` succeeds.
    Verify file imports Ticket model.
    Verify file contains `_log_ticket_changes` function.
    Run existing tests to confirm no regressions in audit behavior: `pytest tests/test_audit.py -v`.
  </verify>
  <done>
    Audit trail enhanced with ticket-specific structured logging for status changes, assignments, and escalations. Generic audit system continues to capture all model changes. TKT-05 fully satisfied by combination of generic audit log + ticket-specific logging + TicketAssignment history + API history endpoint.
  </done>
</task>

</tasks>

<verification>
1. Ticket API has 5 endpoints: list, detail, status update, assign, history
2. GBV tickets return 403 for non-SAPS/non-ADMIN users (SEC-05)
3. Status changes dispatch WhatsApp notification via Celery
4. Assignment endpoint auto-routes when team_id not provided
5. SLA deadlines set on ticket assignment
6. Audit trail captures ticket status changes with structured logging
7. All existing tests pass
</verification>

<success_criteria>
- GET /tickets/ returns filtered list with RBAC enforcement
- GET /tickets/{id} returns detail with SLA status and assignment history
- PATCH /tickets/{id}/status validates transitions and triggers notification
- POST /tickets/{id}/assign routes automatically or to specified team
- GBV access firewall returns 403 for unauthorized roles on all endpoints
- Audit log captures all ticket changes with ticket-specific structured logging
- Zero test regressions
</success_criteria>

<output>
After completion, create `.planning/phases/04-ticket-management-routing/04-04-SUMMARY.md`
</output>
