---
phase: 10.3-crewai-agent-rebuild-and-llm-evaluation-framework
plan: 03
type: execute
wave: 2
depends_on: ["10.3-01"]
files_modified:
  - src/agents/tools/auth_tool.py
  - src/agents/prompts/auth.py
  - src/agents/crews/auth_crew.py
  - src/agents/config/agents.yaml
  - src/agents/config/tasks.yaml
  - src/api/v1/crew_server.py
autonomous: true
requirements:
  - AI-01
  - AI-05
  - AI-06

must_haves:
  truths:
    - "Auth agent can be instantiated with language parameter and creates a valid Crew"
    - "Auth agent uses gpt-4o-mini (not DeepSeek) because auth has heavy tool use"
    - "Auth tools (lookup_user, send_otp, verify_otp, create_supabase_user) are functional"
    - "crew_server.py serves /health and /chat endpoints with Auth agent as first specialist"
    - "Full HTTP -> crew_server -> AuthCrew -> response path works end-to-end"
    - "Auth agent responds as Gugu in the detected language"
  artifacts:
    - path: "src/agents/crews/auth_crew.py"
      provides: "AuthCrew — sequential crew with auth_agent for citizen registration/login"
      contains: "class AuthCrew"
    - path: "src/agents/tools/auth_tool.py"
      provides: "Auth tools: lookup_user_tool, send_otp_tool, verify_otp_tool, create_supabase_user_tool"
      exports: ["lookup_user_tool", "send_otp_tool", "verify_otp_tool", "create_supabase_user_tool"]
    - path: "src/agents/prompts/auth.py"
      provides: "Auth prompts with Gugu persona in EN/ZU/AF + AuthResult Pydantic model"
      contains: "AUTH_PROMPTS"
    - path: "src/api/v1/crew_server.py"
      provides: "Rebuilt crew server with /health, /chat, /session/reset endpoints"
      contains: "crew_app"
  key_links:
    - from: "src/agents/crews/auth_crew.py"
      to: "src/agents/tools/auth_tool.py"
      via: "tools parameter on Agent"
      pattern: "tools=\\[lookup_user_tool"
    - from: "src/api/v1/crew_server.py"
      to: "src/agents/crews/auth_crew.py"
      via: "import and kickoff call"
      pattern: "AuthCrew"
    - from: "src/agents/crews/auth_crew.py"
      to: "src/agents/llm.py"
      via: "get_routing_llm() for gpt-4o-mini"
      pattern: "get_routing_llm"
---

<objective>
Rebuild the Auth Agent from scratch and reconstruct crew_server.py as the HTTP entry point.

Purpose: Auth is the first agent rebuilt because it has the most concrete tool calls (lookup_user, send_otp, verify_otp, create_supabase_user) with clear success/fail states — making it the most testable. The crew_server.py is rebuilt from scratch alongside Auth to prove the full HTTP-to-agent-to-response path end-to-end. This follows the locked decision: "Crew server: Rebuild crew_server.py from scratch alongside the first agent (Auth)."

Output: Working AuthCrew + rebuilt crew_server.py with /health, /chat, /session/reset
</objective>

<execution_context>
@C:/Users/Bantu/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Bantu/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10.3-crewai-agent-rebuild-and-llm-evaluation-framework/10.3-RESEARCH.md
@.planning/phases/10.3-crewai-agent-rebuild-and-llm-evaluation-framework/10.3-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Rebuild Auth Agent — tools, prompts, crew, and YAML config</name>
  <files>
    src/agents/tools/auth_tool.py
    src/agents/prompts/auth.py
    src/agents/crews/auth_crew.py
    src/agents/config/agents.yaml
    src/agents/config/tasks.yaml
  </files>
  <action>
    1. `src/agents/tools/auth_tool.py` — Rebuild auth tools from agents_old reference:
       - Copy tool implementations from `src/agents_old/tools/auth_tool.py` (the actual Supabase calls are proven working)
       - Keep the tool wrapper pattern: implementation function (_send_otp_impl, _verify_otp_impl, etc.) separate from @tool decorator
       - Keep the _log_tool_failure() with 5-min sliding window for POPIA-safe failure logging
       - Keep is_returning_user parameter on send_otp_tool
       - All tools return string messages for LLM consumption (not complex objects)
       - Tools: lookup_user_tool, send_otp_tool, verify_otp_tool, create_supabase_user_tool
       - Import Supabase admin client from `src.core.supabase`

    2. `src/agents/prompts/auth.py` — Rebuild auth prompts:
       - Copy Gugu persona prompts from `src/agents_old/prompts/auth.py`
       - Keep trilingual AUTH_PROMPTS dict: {"en": ..., "zu": ..., "af": ...}
       - Keep CRITICAL IDENTITY anchor at TOP of each prompt
       - Keep GREETING FIRST block for bare greetings
       - Keep LANGUAGE RULES sections
       - Keep AuthResult Pydantic model:
         ```python
         from pydantic import BaseModel, field_validator

         class AuthResult(BaseModel):
             message: str
             requires_otp: bool = False
             session_status: str = "none"
             language: str = "en"

             @field_validator('message')
             @classmethod
             def strip_final_answer(cls, v):
                 if v and v.startswith("Final Answer:"):
                     return v[len("Final Answer:"):].strip()
                 return v
         ```
       - Keep build_auth_task_description() helper that generates different instructions for new vs returning users
       - Apply response guardrail constants (_AUTH_TOOL_HARD_BLOCK_EN/ZU/AF) from agents_old

    3. `src/agents/crews/auth_crew.py` — Rebuild AuthCrew:
       - Extends BaseCrew
       - `__init__(self, language="en", llm=None)`:
         - `super().__init__(language, llm or get_routing_llm())`  # gpt-4o-mini for tool use per locked decision
       - `create_crew(self, context: dict) -> Crew`:
         - Load agent config from agents.yaml
         - Create Agent with: role, goal, backstory from AUTH_PROMPTS[language], tools=[lookup_user_tool, send_otp_tool, verify_otp_tool, create_supabase_user_tool], llm=self.llm, allow_delegation=False
         - Create Task with: description from build_auth_task_description(context), expected_output="...", agent=agent, output_pydantic=AuthResult
         - Return Crew(agents=[agent], tasks=[task], process=Process.sequential, memory=False, verbose=False)
       - `async kickoff(self, context: dict) -> dict`:
         - crew = self.create_crew(context)
         - result = crew.kickoff(inputs=context)
         - return self.parse_result(result)
       - max_iter=15 (auth registration is 6+ steps)

    4. Update `src/agents/config/agents.yaml`:
       ```yaml
       auth_agent:
         role: "Citizen Authentication Assistant"
         goal: "Help citizens register or log in to SALGA Trust Engine"
         backstory: "Selected per language at runtime from AUTH_PROMPTS"
       ```

    5. Update `src/agents/config/tasks.yaml`:
       ```yaml
       auth_task:
         description: "Generated dynamically by build_auth_task_description()"
         expected_output: "A warm, helpful response guiding the citizen through authentication"
       ```
  </action>
  <verify>
    <automated>python -c "from src.agents.crews.auth_crew import AuthCrew; from src.agents.tools.auth_tool import lookup_user_tool, send_otp_tool, verify_otp_tool, create_supabase_user_tool; from src.agents.prompts.auth import AUTH_PROMPTS, AuthResult; print('Auth agent imports OK')"</automated>
  </verify>
  <done>AuthCrew extends BaseCrew, uses gpt-4o-mini, has 4 auth tools, trilingual Gugu prompts, AuthResult Pydantic output model. All imports succeed.</done>
</task>

<task type="auto">
  <name>Task 2: Rebuild crew_server.py from scratch</name>
  <files>
    src/api/v1/crew_server.py
  </files>
  <action>
    Rebuild crew_server.py from scratch — this is the HTTP entry point for all agent interactions. Start with ONLY the Auth agent wired up (other specialists added in later plans as they are rebuilt).

    1. Create `crew_app = FastAPI(title="SALGA Trust Engine - Crew Server")` (separate from main app per locked decision)

    2. **Request/Response models:**
       ```python
       class ChatRequest(BaseModel):
           phone: str
           message: str
           language: str = "en"
           session_override: str | None = None  # "new" | "expired" for testing

       class ChatResponse(BaseModel):
           reply: str
           agent_name: str = "unknown"
           session_status: str = "none"
           language: str = "en"
           debug: dict = {}
       ```

    3. **Endpoints:**
       - `GET /api/v1/health` — returns `{"status": "ok", "agents": ["auth"]}`
       - `POST /api/v1/chat` — main conversation endpoint
       - `POST /api/v1/session/reset` — clears session state

    4. **Chat endpoint logic (simplified for Auth-only):**
       ```python
       @crew_app.post("/api/v1/chat")
       async def chat(request: ChatRequest):
           # Step 1: Get or create conversation state from Redis
           conv_state = conversation_manager.get_or_create_state(phone=request.phone)

           # Step 2: Detect language (lingua-py singleton)
           detected_language = _detect_language(request.message, fallback=request.language)

           # Step 3: Build conversation history string
           history = _format_conversation_history(conv_state.turns)

           # Step 4: Determine routing
           # For now: if session_status is "none" or "otp_pending", route to auth
           # Other specialists will be added as they are rebuilt
           routing_phase = conv_state.routing_phase

           # Step 5: Route to appropriate agent
           if routing_phase == "manager" or conv_state.session_status in ("none", "expired"):
               # Auth agent handles unauthenticated users
               agent_result = await _handle_auth(request, conv_state, detected_language, history)
           else:
               # Placeholder for other agents — will be wired in Plan 07
               agent_result = {"message": "This agent is being rebuilt. Please try again later.", "agent_name": "placeholder"}

           # Step 6: Sanitize response
           reply = sanitize_reply(agent_result.get("message", ""), agent_result.get("agent_name", ""), detected_language)

           # Step 7: Save conversation state
           conversation_manager.append_turn(request.phone, "user", request.message)
           conversation_manager.append_turn(request.phone, "assistant", reply)

           # Step 8: Build response
           return ChatResponse(
               reply=reply,
               agent_name=agent_result.get("agent_name", "auth"),
               session_status=agent_result.get("session_status", conv_state.session_status),
               language=detected_language,
               debug=_build_debug(agent_result, detected_language, routing_phase, conv_state)
           )
       ```

    5. **sanitize_reply() function** — Copy sanitization logic from agents_old crew_server:
       - Strip "Final Answer:" prefix
       - Strip "Thought:", "Action:", "Action Input:" lines
       - Strip delegation artifacts ("As the Manager...", "I'll now delegate...")
       - For GBV: ensure emergency numbers (10111, 0800 150 150) are present
       - Return clean citizen-facing message

    6. **_handle_auth() function:**
       ```python
       async def _handle_auth(request, conv_state, language, history):
           from src.agents.crews.auth_crew import AuthCrew
           context = {
               "message": request.message,
               "phone": request.phone,
               "language": language,
               "session_status": conv_state.session_status,
               "conversation_history": history,
               "user_id": conv_state.user_id or "",
           }
           crew = AuthCrew(language=language)
           result = await crew.kickoff(context)
           result["agent_name"] = "auth"
           return result
       ```

    7. **ConversationManager integration:**
       - Import from existing `src.agents_old.flows.state` temporarily OR copy ConversationManager to new location
       - Use InMemoryConversationManager as fallback when Redis unavailable
       - Keep existing ConversationState fields

    8. **Security:**
       - X-API-Key middleware (skip if CREW_SERVER_API_KEY is empty for dev)
       - CORS configuration
       - Rate limiting placeholder

    9. **_build_debug()** — Debug info for Streamlit:
       - For GBV agent: metadata only (agent_name, turn_count, session_status)
       - For others: agent_name, detected_language, routing_phase, session_status, raw_output (if available)

    IMPORTANT: Keep the Streamlit dashboard pointing at this rebuilt crew_server. The Streamlit code (streamlit_dashboard/) does NOT need changes — it already uses /api/v1/chat, /api/v1/health, /api/v1/session/reset.
  </action>
  <verify>
    <automated>python -c "from src.api.v1.crew_server import crew_app; from starlette.testclient import TestClient; client = TestClient(crew_app); r = client.get('/api/v1/health'); print(r.json()); assert r.status_code == 200"</automated>
  </verify>
  <done>crew_server.py rebuilt from scratch with /health, /chat, /session/reset. Auth agent wired as first specialist. sanitize_reply() strips LLM artifacts. Debug output respects GBV metadata-only rule. Health endpoint returns 200.</done>
</task>

</tasks>

<verification>
- `python -c "from src.agents.crews.auth_crew import AuthCrew"` succeeds
- Health endpoint returns 200 with `{"status": "ok", "agents": ["auth"]}`
- Auth tools import: lookup_user_tool, send_otp_tool, verify_otp_tool, create_supabase_user_tool
- AUTH_PROMPTS has keys "en", "zu", "af"
- AuthResult Pydantic model validates correctly
- sanitize_reply strips "Final Answer:" prefix
</verification>

<success_criteria>
- AuthCrew instantiates and create_crew returns a valid Crew
- crew_server.py /health returns 200
- Auth agent uses gpt-4o-mini (get_routing_llm) per locked decision
- Gugu persona preserved in all 3 languages
- sanitize_reply strips internal artifacts
- Full HTTP -> crew_server -> AuthCrew path is wired (even if LLM call fails due to missing API key, the path is structurally correct)
</success_criteria>

<output>
After completion, create `.planning/phases/10.3-crewai-agent-rebuild-and-llm-evaluation-framework/10.3-03-SUMMARY.md`
</output>
