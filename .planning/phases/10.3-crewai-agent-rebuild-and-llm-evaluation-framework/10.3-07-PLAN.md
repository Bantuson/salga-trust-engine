---
phase: 10.3-crewai-agent-rebuild-and-llm-evaluation-framework
plan: 07
type: execute
wave: 4
depends_on: ["10.3-04", "10.3-05", "10.3-06"]
files_modified:
  - src/agents/flows/intake_flow.py
  - src/api/v1/crew_server.py
  - src/api/v1/messages.py
  - src/services/whatsapp_service.py
  - tests/agents/test_intake_flow.py
autonomous: true
requirements:
  - AI-01
  - AI-02
  - AI-03
  - AI-04

must_haves:
  truths:
    - "IntakeFlow uses @router decorator for deterministic Python routing (no LLM delegation)"
    - "Intent classification uses a direct LLM call (gpt-4o-mini) not a full Crew"
    - "Unauthenticated users always route to Auth agent first"
    - "routing_phase in ConversationState short-circuits classification for active specialist sessions"
    - "GBV confirmation gate works correctly (gbv_pending_confirm state)"
    - "crew_server.py routes all 4 specialists correctly"
    - "WhatsApp service uses IntakeFlow instead of old ManagerCrew"
    - "Messages endpoint uses IntakeFlow instead of old IntakeFlow/ManagerCrew"
  artifacts:
    - path: "src/agents/flows/intake_flow.py"
      provides: "IntakeFlow with @router dispatch to all 4 specialist crews"
      contains: "class IntakeFlow"
    - path: "src/api/v1/crew_server.py"
      provides: "Updated crew server routing all 4 specialists via IntakeFlow"
    - path: "tests/agents/test_intake_flow.py"
      provides: "Unit tests for IntakeFlow routing logic"
      contains: "class TestIntakeFlow"
  key_links:
    - from: "src/agents/flows/intake_flow.py"
      to: "src/agents/crews/auth_crew.py"
      via: "@listen('auth') handler"
      pattern: "AuthCrew"
    - from: "src/agents/flows/intake_flow.py"
      to: "src/agents/crews/municipal_crew.py"
      via: "@listen('municipal') handler"
      pattern: "MunicipalIntakeCrew"
    - from: "src/agents/flows/intake_flow.py"
      to: "src/agents/crews/gbv_crew.py"
      via: "@listen('gbv') handler"
      pattern: "GBVCrew"
    - from: "src/agents/flows/intake_flow.py"
      to: "src/agents/crews/ticket_status_crew.py"
      via: "@listen('ticket_status') handler"
      pattern: "TicketStatusCrew"
    - from: "src/api/v1/crew_server.py"
      to: "src/agents/flows/intake_flow.py"
      via: "IntakeFlow dispatch in chat endpoint"
      pattern: "IntakeFlow"
---

<objective>
Build IntakeFlow with @router dispatch, wire all specialists into crew_server, and update WhatsApp/messages endpoints.

Purpose: This is the capstone integration plan. The IntakeFlow replaces the broken Process.hierarchical ManagerCrew with a deterministic @router Flow. The Flow classifies intent via a direct gpt-4o-mini LLM call, then dispatches to the correct specialist Crew via @listen branches. crew_server.py is updated to route through IntakeFlow instead of individual agent handlers. WhatsApp and messages endpoints are updated to use the new architecture.

Output: Complete routing pipeline — HTTP -> crew_server -> IntakeFlow -> specialist Crew -> response
</objective>

<execution_context>
@C:/Users/Bantu/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Bantu/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/10.3-crewai-agent-rebuild-and-llm-evaluation-framework/10.3-RESEARCH.md
@.planning/phases/10.3-crewai-agent-rebuild-and-llm-evaluation-framework/10.3-03-SUMMARY.md
@.planning/phases/10.3-crewai-agent-rebuild-and-llm-evaluation-framework/10.3-05-SUMMARY.md
@.planning/phases/10.3-crewai-agent-rebuild-and-llm-evaluation-framework/10.3-06-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Build IntakeFlow with @router dispatch and update crew_server</name>
  <files>
    src/agents/flows/intake_flow.py
    src/api/v1/crew_server.py
  </files>
  <action>
    1. `src/agents/flows/intake_flow.py` — The core routing Flow:
       ```python
       from crewai.flow.flow import Flow, listen, router, start
       from src.agents.flows.state import IntakeState
       from src.agents.llm import get_routing_llm
       from src.services.language_service import language_detector

       class IntakeFlow(Flow[IntakeState]):

           @start()
           def classify_intent(self) -> str:
               """Language detection + intent classification via direct LLM call."""
               # Step 1: Detect language
               detected = language_detector.detect(
                   self.state.message,
                   fallback=self.state.language
               )
               self.state.language = detected

               # Step 2: Short-circuit if routing_phase is already set (specialist session active)
               if self.state.routing_phase != "manager":
                   return self.state.routing_phase  # "auth" | "municipal" | "ticket_status" | "gbv"

               # Step 3: Auth gate — unauthenticated users always go to auth first
               if self.state.session_status in ("none", "expired", "otp_pending"):
                   # Save the citizen's original intent for after auth completes
                   self.state.pending_intent = self._classify_raw_intent()
                   return "auth"

               # Step 4: Classify intent via direct LLM call (gpt-4o-mini)
               intent = self._classify_raw_intent()
               self.state.intent = intent
               return intent

           def _classify_raw_intent(self) -> str:
               """Direct LLM call for intent classification. NOT a full Crew."""
               llm = get_routing_llm()
               prompt = f"""Classify the following citizen message into exactly one category.
               Categories: auth, municipal, ticket_status, gbv
               - auth: account registration, login, OTP, verification
               - municipal: service complaints (water, roads, electricity, waste, sanitation)
               - ticket_status: checking status of existing report/ticket
               - gbv: domestic violence, abuse, assault, threats, gender-based violence

               Message: {self.state.message}

               Return ONLY the category name (auth, municipal, ticket_status, or gbv). Nothing else."""

               result = llm.call(prompt)
               intent = result.strip().lower()
               # Validate — default to municipal if unrecognized
               if intent not in ("auth", "municipal", "ticket_status", "gbv"):
                   intent = "municipal"
               return intent

           @router(classify_intent)
           def route_by_intent(self):
               """Pure Python routing — no LLM, no delegation."""
               return self.state.intent or "auth"

           @listen("auth")
           async def handle_auth(self):
               from src.agents.crews.auth_crew import AuthCrew
               crew = AuthCrew(language=self.state.language)
               result = await crew.kickoff({
                   "message": self.state.message,
                   "phone": self.state.phone,
                   "language": self.state.language,
                   "session_status": self.state.session_status,
                   "conversation_history": self.state.conversation_history,
                   "user_id": self.state.user_id or "",
               })
               result["agent_name"] = "auth"
               self.state.result = result

           @listen("municipal")
           async def handle_municipal(self):
               from src.agents.crews.municipal_crew import MunicipalIntakeCrew
               crew = MunicipalIntakeCrew(language=self.state.language)
               result = await crew.kickoff({
                   "message": self.state.message,
                   "phone": self.state.phone,
                   "language": self.state.language,
                   "conversation_history": self.state.conversation_history,
                   "user_id": self.state.user_id or "",
               })
               result["agent_name"] = "municipal"
               self.state.result = result

           @listen("ticket_status")
           async def handle_ticket_status(self):
               from src.agents.crews.ticket_status_crew import TicketStatusCrew
               crew = TicketStatusCrew(language=self.state.language)
               result = await crew.kickoff({
                   "message": self.state.message,
                   "phone": self.state.phone,
                   "language": self.state.language,
                   "conversation_history": self.state.conversation_history,
                   "user_id": self.state.user_id or "",
               })
               result["agent_name"] = "ticket_status"
               self.state.result = result

           @listen("gbv")
           async def handle_gbv(self):
               from src.agents.crews.gbv_crew import GBVCrew
               crew = GBVCrew(language=self.state.language)
               result = await crew.kickoff({
                   "message": self.state.message,
                   "phone": self.state.phone,
                   "language": self.state.language,
                   "conversation_history": self.state.conversation_history,
                   "user_id": self.state.user_id or "",
               })
               result["agent_name"] = "gbv"
               self.state.result = result
       ```

       Key design points:
       - `classify_intent` runs first (@start), detects language and classifies intent
       - Short-circuit: if routing_phase is already set (not "manager"), skip classification
       - Auth gate: unauthenticated users always route to auth, original intent saved in pending_intent
       - `route_by_intent` is pure Python — no LLM call, just returns the intent string
       - Each @listen handler imports its crew lazily (avoids circular imports)
       - Each handler sets agent_name on the result dict

    2. Update `src/api/v1/crew_server.py` — Replace individual agent handlers with IntakeFlow:
       - Chat endpoint now creates IntakeFlow, populates state from conversation manager, kicks off
       - Remove _handle_auth (replaced by IntakeFlow.handle_auth)
       - Add all 4 agents to health endpoint response
       - GBV confirmation gate: if routing_phase is "gbv_pending_confirm", handle confirmation logic before routing to Flow
       - routing_phase persistence: after Flow returns, update ConversationState routing_phase based on result
       - pending_intent: after auth completes (session_status goes to "active"), restore pending_intent as next routing target

       ```python
       @crew_app.post("/api/v1/chat")
       async def chat(request: ChatRequest):
           conv_state = conversation_manager.get_or_create_state(phone=request.phone)

           # Handle GBV confirmation gate
           if conv_state.routing_phase == "gbv_pending_confirm":
               return await _handle_gbv_confirmation(request, conv_state)

           # Build IntakeFlow state
           flow = IntakeFlow()
           flow.state.message = request.message
           flow.state.phone = request.phone
           flow.state.language = request.language
           flow.state.routing_phase = conv_state.routing_phase
           flow.state.session_status = _get_session_status(conv_state, request)
           flow.state.user_id = conv_state.user_id
           flow.state.conversation_history = _format_history(conv_state.turns)
           flow.state.pending_intent = conv_state.pending_intent or ""

           # Kick off Flow
           await flow.kickoff_async()

           # Extract result
           result = flow.state.result
           reply = sanitize_reply(result.get("message", ""), result.get("agent_name", ""), flow.state.language)

           # Update conversation state
           _update_routing_phase(conv_state, result, flow.state)
           conversation_manager.append_turn(request.phone, "user", request.message)
           conversation_manager.append_turn(request.phone, "assistant", reply)

           return ChatResponse(...)
       ```

    3. Update `src/api/v1/messages.py` and `src/services/whatsapp_service.py`:
       - Replace any imports of old IntakeFlow/ManagerCrew with new IntakeFlow
       - Messages endpoint: use IntakeFlow for AI-powered message processing
       - WhatsApp service: use IntakeFlow for incoming WhatsApp message routing
       - Keep stable session_id pattern (wa-{phone} for WhatsApp)
       - These updates should be minimal — the IntakeFlow API is similar to what existed

    IMPORTANT: If CrewAI Flow.kickoff_async() doesn't work as expected (open question from research), fall back to synchronous flow.kickoff() wrapped in asyncio. Test this during implementation.
  </action>
  <verify>
    <automated>python -c "from src.agents.flows.intake_flow import IntakeFlow; from src.agents.flows.state import IntakeState; f = IntakeFlow(); print(f'IntakeFlow created, state type: {type(f.state).__name__}')" && python -c "from src.api.v1.crew_server import crew_app; from starlette.testclient import TestClient; c = TestClient(crew_app); r = c.get('/api/v1/health'); assert 'auth' in str(r.json()); print('crew_server health OK')"</automated>
  </verify>
  <done>IntakeFlow with @router dispatches to all 4 specialist crews. crew_server.py uses IntakeFlow for routing. GBV confirmation gate implemented. WhatsApp and messages endpoints updated. Health endpoint lists all agents.</done>
</task>

<task type="auto">
  <name>Task 2: IntakeFlow and routing unit tests</name>
  <files>
    tests/agents/test_intake_flow.py
  </files>
  <action>
    Create unit tests for IntakeFlow routing logic. All specialist crews and LLM calls are mocked.

    **Section 1: Intent Classification Tests**
    - `test_classify_intent_municipal` — Message "broken pipe on Main Road" classifies as "municipal"
    - `test_classify_intent_auth` — Message from unauthenticated user routes to "auth"
    - `test_classify_intent_gbv` — Message about domestic violence classifies as "gbv"
    - `test_classify_intent_ticket_status` — Message with tracking number classifies as "ticket_status"
    - `test_classify_intent_unknown_defaults_to_municipal` — Unrecognized intent defaults to "municipal"

    **Section 2: Routing Logic Tests**
    - `test_unauthenticated_always_routes_to_auth` — session_status="none" routes to auth regardless of message content
    - `test_otp_pending_routes_to_auth` — session_status="otp_pending" continues to auth
    - `test_active_session_routes_by_intent` — session_status="active" uses intent classification
    - `test_routing_phase_shortcircuit` — routing_phase="municipal" skips classification
    - `test_pending_intent_preserved` — When auth routes, original intent saved in pending_intent
    - `test_gbv_pending_confirm_not_routed_to_flow` — This state is handled by crew_server, not Flow

    **Section 3: Language Detection Tests**
    - `test_language_detection_english` — English message detected as "en"
    - `test_language_detection_zulu` — isiZulu message detected as "zu"
    - `test_language_detection_fallback` — Short/ambiguous message uses fallback language

    **Section 4: Specialist Dispatch Tests (mocked)**
    - `test_auth_dispatch_calls_auth_crew` — Mock AuthCrew, verify kickoff called with correct context
    - `test_municipal_dispatch_calls_municipal_crew` — Mock MunicipalIntakeCrew
    - `test_gbv_dispatch_calls_gbv_crew` — Mock GBVCrew
    - `test_ticket_status_dispatch_calls_ticket_status_crew` — Mock TicketStatusCrew

    **Mock pattern:**
    - Patch `src.agents.llm.get_routing_llm` to return mock_llm that returns intent strings
    - Patch each specialist crew import within the Flow handlers
    - Use IntakeState directly (no HTTP layer)
  </action>
  <verify>
    <automated>pytest tests/agents/test_intake_flow.py -x --no-header -q</automated>
  </verify>
  <done>18+ routing tests covering intent classification, auth gate, routing_phase short-circuit, pending_intent preservation, language detection, and specialist dispatch. All tests pass.</done>
</task>

</tasks>

<verification>
- `pytest tests/agents/test_intake_flow.py -x -q` — all pass
- `pytest tests/agents/ -x -q` — full suite green (all agent tests + flow tests + crew server tests)
- `python -c "from src.agents.flows.intake_flow import IntakeFlow"` succeeds
- crew_server health endpoint lists all 4 agents
</verification>

<success_criteria>
- IntakeFlow uses @router (not Process.hierarchical) for deterministic routing
- Intent classification via direct LLM call (gpt-4o-mini), not a full Crew
- Auth gate: unauthenticated users always route to auth first
- routing_phase short-circuit works for active specialist sessions
- All 4 specialist crews dispatched correctly
- GBV confirmation gate implemented in crew_server
- WhatsApp and messages endpoints updated to new architecture
- 18+ routing unit tests passing
- Full tests/agents/ suite green
</success_criteria>

<output>
After completion, create `.planning/phases/10.3-crewai-agent-rebuild-and-llm-evaluation-framework/10.3-07-SUMMARY.md`
</output>
